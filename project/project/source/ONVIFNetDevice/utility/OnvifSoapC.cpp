#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "OnvifSoapH.h"

#ifdef __cplusplus
extern "C" 
{
#endif

//public resource
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6Address(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__IPv6Address);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__IPv6Address(struct soap *soap, const char *tag, char **a, const char *type)
{	
	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__IPv6Address, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv6Address(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPv6Address);
	if (soap_out_tt__IPv6Address(soap, tag?tag:"byte", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__IPv6Address(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6Address(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv4Address(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__IPv4Address);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__IPv4Address(struct soap *soap, const char *tag, char **a, const char *type)
{	
	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__IPv4Address, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv4Address(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPv4Address);
	if (soap_out_tt__IPv4Address(soap, tag?tag:"byte", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__IPv4Address(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv4Address(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Date(struct soap *soap, struct tt__Date *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Year);
	soap_default_int(soap, &a->Month);
	soap_default_int(soap, &a->Day);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Date(struct soap *soap, const struct tt__Date *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Year, SOAP_TYPE_int);
	soap_embedded(soap, &a->Month, SOAP_TYPE_int);
	soap_embedded(soap, &a->Day, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Date(struct soap *soap, const char *tag, int id, const struct tt__Date *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Date), type))
	{
		return soap->error;
	}
	if (soap_out_int(soap, "tt:Year", -1, &a->Year, ""))
	{
		return soap->error;
	}
	if (soap_out_int(soap, "tt:Month", -1, &a->Month, ""))
	{
		return soap->error;
	}
	if (soap_out_int(soap, "tt:Day", -1, &a->Day, ""))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Date * SOAP_FMAC4 soap_in_tt__Date(struct soap *soap, const char *tag, struct tt__Date *a, const char *type)
{
	size_t soap_flag_Year = 1;
	size_t soap_flag_Month = 1;
	size_t soap_flag_Day = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__Date *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Date, sizeof(struct tt__Date), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__Date(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Year && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Year", &a->Year, "xsd:int"))
				{	
					soap_flag_Year--;
					continue;
				}
			if (soap_flag_Month && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Month", &a->Month, "xsd:int"))
				{	
					soap_flag_Month--;
					continue;
				}
			if (soap_flag_Day && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Day", &a->Day, "xsd:int"))
				{	
					soap_flag_Day--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
			{
				soap->error = soap_ignore_element(soap);
			}
			if (soap->error == SOAP_NO_TAG)
			{
				break;
			}
			if (soap->error)
			{
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__Date *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Date, 0, sizeof(struct tt__Date), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Year > 0 || soap_flag_Month > 0 || soap_flag_Day > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Date(struct soap *soap, const struct tt__Date *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Date);
	if (soap_out_tt__Date(soap, tag?tag:"tt:Date", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Date * SOAP_FMAC4 soap_get_tt__Date(struct soap *soap, struct tt__Date *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Date(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Time(struct soap *soap, struct tt__Time *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Hour);
	soap_default_int(soap, &a->Minute);
	soap_default_int(soap, &a->Second);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Time(struct soap *soap, const struct tt__Time *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Hour, SOAP_TYPE_int);
	soap_embedded(soap, &a->Minute, SOAP_TYPE_int);
	soap_embedded(soap, &a->Second, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Time(struct soap *soap, const char *tag, int id, const struct tt__Time *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Time), type))
	{
		return soap->error;
	}
	if (soap_out_int(soap, "tt:Hour", -1, &a->Hour, ""))
	{
		return soap->error;
	}
	if (soap_out_int(soap, "tt:Minute", -1, &a->Minute, ""))
	{
		return soap->error;
	}
	if (soap_out_int(soap, "tt:Second", -1, &a->Second, ""))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Time * SOAP_FMAC4 soap_in_tt__Time(struct soap *soap, const char *tag, struct tt__Time *a, const char *type)
{
	size_t soap_flag_Hour = 1;
	size_t soap_flag_Minute = 1;
	size_t soap_flag_Second = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__Time *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Time, sizeof(struct tt__Time), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__Time(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Hour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Hour", &a->Hour, "xsd:int"))
				{	
					soap_flag_Hour--;
					continue;
				}
			if (soap_flag_Minute && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Minute", &a->Minute, "xsd:int"))
				{	
					soap_flag_Minute--;
					continue;
				}
			if (soap_flag_Second && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Second", &a->Second, "xsd:int"))
				{	
					soap_flag_Second--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
			{
				soap->error = soap_ignore_element(soap);
			}
			if (soap->error == SOAP_NO_TAG)
			{
				break;
			}
			if (soap->error)
			{
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__Time *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Time, 0, sizeof(struct tt__Time), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Hour > 0 || soap_flag_Minute > 0 || soap_flag_Second > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Time(struct soap *soap, const struct tt__Time *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Time);
	if (soap_out_tt__Time(soap, tag?tag:"tt:Time", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Time * SOAP_FMAC4 soap_get_tt__Time(struct soap *soap, struct tt__Time *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Time(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_default_float(struct soap *soap, float *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_float
	*a = SOAP_DEFAULT_float;
#else
	*a = (float)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{	
	float *p;
	p = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_float);
	if (soap_out_float(soap, tag?tag:"float", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__boolean_(struct soap *soap, enum xsd__boolean_ *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__boolean_
	*a = SOAP_DEFAULT_xsd__boolean_;
#else
	*a = (enum xsd__boolean_)0;
#endif
}

static const struct soap_code_map soap_codes_xsd__boolean_[] =
{	
	{ (long)_false, "false" },
	{ (long)_true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__boolean_2s(struct soap *soap, enum xsd__boolean_ n)
{	const char *s = soap_code_str(soap_codes_xsd__boolean_, (long)n);
	if (s != NULL)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean_(struct soap *soap, const char *tag, int id, const enum xsd__boolean_ *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean_), type) || soap_send(soap, soap_xsd__boolean_2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__boolean_(struct soap *soap, const char *s, enum xsd__boolean_ *a)
{
	const struct soap_code_map *map;
	if (s == NULL)
		return soap->error;
	map = soap_code(soap_codes_xsd__boolean_, s);
	if (map)
		*a = (enum xsd__boolean_)map->code;
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum xsd__boolean_)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xsd__boolean_ * SOAP_FMAC4 soap_in_xsd__boolean_(struct soap *soap, const char *tag, enum xsd__boolean_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum xsd__boolean_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean_, sizeof(enum xsd__boolean_), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	if (soap->body && !*soap->href)
	{	
		if ((a == NULL) || soap_s2xsd__boolean_(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
		return NULL;
	}
	else
	{	
		a = (enum xsd__boolean_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__boolean_, 0, sizeof(enum xsd__boolean_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean_(struct soap *soap, const enum xsd__boolean_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__boolean_);
	if (soap_out_xsd__boolean_(soap, tag?tag:"xsd:boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean_ * SOAP_FMAC4 soap_get_xsd__boolean_(struct soap *soap, enum xsd__boolean_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SearchState(struct soap *soap, enum tt__SearchState *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__SearchState
	*a = SOAP_DEFAULT_tt__SearchState;
#else
	*a = (enum tt__SearchState)0;
#endif
}

static const struct soap_code_map soap_codes_tt__SearchState[] =
{	
	{ (long)tt__SearchState__Queued, "Queued" },
	{ (long)tt__SearchState__Searching, "Searching" },
	{ (long)tt__SearchState__Completed, "Completed" },
	{ (long)tt__SearchState__Unknown, "Unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__SearchState2s(struct soap *soap, enum tt__SearchState n)
{	
	const char *s = soap_code_str(soap_codes_tt__SearchState, (long)n);
	if (s != NULL)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SearchState(struct soap *soap, const char *tag, int id, const enum tt__SearchState *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SearchState), type) || soap_send(soap, soap_tt__SearchState2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__SearchState(struct soap *soap, const char *s, enum tt__SearchState *a)
{
	const struct soap_code_map *map;
	if (s == NULL)
		return soap->error;
	map = soap_code(soap_codes_tt__SearchState, s);
	if (map)
		*a = (enum tt__SearchState)map->code;
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__SearchState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__SearchState * SOAP_FMAC4 soap_in_tt__SearchState(struct soap *soap, const char *tag, enum tt__SearchState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	return NULL;
	a = (enum tt__SearchState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SearchState, sizeof(enum tt__SearchState), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	if (soap->body && !*soap->href)
	{	
		if (!a || soap_s2tt__SearchState(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (enum tt__SearchState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SearchState, 0, sizeof(enum tt__SearchState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SearchState(struct soap *soap, const enum tt__SearchState *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SearchState);
	if (soap_out_tt__SearchState(soap, tag?tag:"tt:SearchState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__SearchState * SOAP_FMAC4 soap_get_tt__SearchState(struct soap *soap, enum tt__SearchState *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SearchState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__hexBinary(struct soap *soap, struct xsd__hexBinary *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__hexBinary(struct soap *soap, struct xsd__hexBinary const*a)
{
	if (a->__ptr)
		soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_xsd__hexBinary);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__hexBinary(struct soap *soap, const char *tag, int id, const struct xsd__hexBinary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__hexBinary);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_puthex(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xsd__hexBinary * SOAP_FMAC4 soap_in_xsd__hexBinary(struct soap *soap, const char *tag, struct xsd__hexBinary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":hexBinary"))
	{	
		soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd__hexBinary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__hexBinary, sizeof(struct xsd__hexBinary), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_xsd__hexBinary(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_gethex(soap, &a->__size);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct xsd__hexBinary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__hexBinary, 0, sizeof(struct xsd__hexBinary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__hexBinary(struct soap *soap, const struct xsd__hexBinary *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_xsd__hexBinary);
	if (soap_out_xsd__hexBinary(soap, tag?tag:"xsd:hexBinary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xsd__hexBinary * SOAP_FMAC4 soap_get_xsd__hexBinary(struct soap *soap, struct xsd__hexBinary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__hexBinary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_QName(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__QName))
		soap_serialize__QName(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_QName(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__QName);
	if (id < 0)
		return soap->error;
	return soap_out__QName(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTo_QName(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__QName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__QName, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_QName(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_QName);
	if (soap_out_PointerTo_QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTo_QName(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	
	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = NULL;//(char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	
	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__boolean_(struct soap *soap, enum xsd__boolean_ *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__boolean_(struct soap *soap, const char *tag, int id, enum xsd__boolean_ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__boolean_);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__boolean_(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum xsd__boolean_ ** SOAP_FMAC4 soap_in_PointerToxsd__boolean_(struct soap *soap, const char *tag, enum xsd__boolean_ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	return NULL;
	if (a == NULL)
		if (!(a = (enum xsd__boolean_ **)soap_malloc(soap, sizeof(enum xsd__boolean_ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_xsd__boolean_(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (enum xsd__boolean_ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean_, sizeof(enum xsd__boolean_), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__boolean_(struct soap *soap, enum xsd__boolean_ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__boolean_);
	if (soap_out_PointerToxsd__boolean_(soap, tag?tag:"xsd:boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean_ ** SOAP_FMAC4 soap_get_PointerToxsd__boolean_(struct soap *soap, enum xsd__boolean_ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__boolean_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	
	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Name(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__Name);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__Name(struct soap *soap, const char *tag, char **a, const char *type)
{	
	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__Name, 1, 0, 64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Name(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Name);
	if (soap_out_tt__Name(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__Name(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Name(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReferenceToken(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__ReferenceToken);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__ReferenceToken(struct soap *soap, const char *tag, char **a, const char *type)
{	
	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__ReferenceToken, 1, 0, 64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReferenceToken(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ReferenceToken);
	if (soap_out_tt__ReferenceToken(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__ReferenceToken(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReferenceToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__token(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__token);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__token(struct soap *soap, const char *tag, char **a, const char *type)
{	
	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__token, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__token(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__token);
	if (soap_out_xsd__token(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__token(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FloatRange(struct soap *soap, struct tt__FloatRange *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FloatRange))
		soap_serialize_tt__FloatRange(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FloatRange(struct soap *soap, const char *tag, int id, struct tt__FloatRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FloatRange);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FloatRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FloatRange ** SOAP_FMAC4 soap_in_PointerTott__FloatRange(struct soap *soap, const char *tag, struct tt__FloatRange **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__FloatRange **)soap_malloc(soap, sizeof(struct tt__FloatRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__FloatRange(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__FloatRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FloatRange, sizeof(struct tt__FloatRange), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FloatRange(struct soap *soap, struct tt__FloatRange *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FloatRange);
	if (soap_out_PointerTott__FloatRange(soap, tag?tag:"tt:FloatRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FloatRange ** SOAP_FMAC4 soap_get_PointerTott__FloatRange(struct soap *soap, struct tt__FloatRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FloatRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FloatRange(struct soap *soap, struct tt__FloatRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->Min);
	soap_default_float(soap, &a->Max);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FloatRange(struct soap *soap, const struct tt__FloatRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Min, SOAP_TYPE_float);
	soap_embedded(soap, &a->Max, SOAP_TYPE_float);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FloatRange(struct soap *soap, const char *tag, int id, const struct tt__FloatRange *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FloatRange), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Min", -1, &a->Min, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Max", -1, &a->Max, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FloatRange * SOAP_FMAC4 soap_in_tt__FloatRange(struct soap *soap, const char *tag, struct tt__FloatRange *a, const char *type)
{
	size_t soap_flag_Min = 1;
	size_t soap_flag_Max = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FloatRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FloatRange, sizeof(struct tt__FloatRange), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__FloatRange(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Min", &a->Min, "xsd:float"))
				{	
					soap_flag_Min--;
					continue;
				}
			if (soap_flag_Max && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Max", &a->Max, "xsd:float"))
				{	
					soap_flag_Max--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__FloatRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FloatRange, 0, sizeof(struct tt__FloatRange), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min > 0 || soap_flag_Max > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FloatRange(struct soap *soap, const struct tt__FloatRange *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__FloatRange);
	if (soap_out_tt__FloatRange(soap, tag?tag:"tt:FloatRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FloatRange * SOAP_FMAC4 soap_get_tt__FloatRange(struct soap *soap, struct tt__FloatRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FloatRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IntRange(struct soap *soap, struct tt__IntRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Min);
	soap_default_int(soap, &a->Max);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IntRange(struct soap *soap, const struct tt__IntRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Min, SOAP_TYPE_int);
	soap_embedded(soap, &a->Max, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRange(struct soap *soap, const char *tag, int id, const struct tt__IntRange *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntRange), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Min", -1, &a->Min, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Max", -1, &a->Max, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IntRange * SOAP_FMAC4 soap_in_tt__IntRange(struct soap *soap, const char *tag, struct tt__IntRange *a, const char *type)
{
	size_t soap_flag_Min = 1;
	size_t soap_flag_Max = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IntRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRange, sizeof(struct tt__IntRange), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__IntRange(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Min", &a->Min, "xsd:int"))
				{	
					soap_flag_Min--;
					continue;
				}
			if (soap_flag_Max && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Max", &a->Max, "xsd:int"))
				{	
					soap_flag_Max--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__IntRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntRange, 0, sizeof(struct tt__IntRange), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min > 0 || soap_flag_Max > 0))
	{	
		soap->error = SOAP_OCCURS;
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IntRange(struct soap *soap, const struct tt__IntRange *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IntRange);
	if (soap_out_tt__IntRange(soap, tag?tag:"tt:IntRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntRange * SOAP_FMAC4 soap_get_tt__IntRange(struct soap *soap, struct tt__IntRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntRange(struct soap *soap, struct tt__IntRange *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntRange))
		soap_serialize_tt__IntRange(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntRange(struct soap *soap, const char *tag, int id, struct tt__IntRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntRange);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IntRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IntRange ** SOAP_FMAC4 soap_in_PointerTott__IntRange(struct soap *soap, const char *tag, struct tt__IntRange **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__IntRange **)soap_malloc(soap, sizeof(struct tt__IntRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__IntRange(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__IntRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntRange, sizeof(struct tt__IntRange), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntRange(struct soap *soap, struct tt__IntRange *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IntRange);
	if (soap_out_PointerTott__IntRange(soap, tag?tag:"tt:IntRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntRange ** SOAP_FMAC4 soap_get_PointerTott__IntRange(struct soap *soap, struct tt__IntRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TrackReference(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__TrackReference);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__TrackReference(struct soap *soap, const char *tag, char **a, const char *type)
{	
	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__TrackReference, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TrackReference(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__TrackReference);
	if (soap_out_tt__TrackReference(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__TrackReference(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TrackReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingReference(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__RecordingReference);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__RecordingReference(struct soap *soap, const char *tag, char **a, const char *type)
{	
	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__RecordingReference, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingReference(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RecordingReference);
	if (soap_out_tt__RecordingReference(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__RecordingReference(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemList(struct soap *soap, struct tt__ItemList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ItemList))
		soap_serialize_tt__ItemList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemList(struct soap *soap, const char *tag, int id, struct tt__ItemList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ItemList);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ItemList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ItemList ** SOAP_FMAC4 soap_in_PointerTott__ItemList(struct soap *soap, const char *tag, struct tt__ItemList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__ItemList **)soap_malloc(soap, sizeof(struct tt__ItemList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__ItemList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__ItemList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemList, sizeof(struct tt__ItemList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemList(struct soap *soap, struct tt__ItemList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ItemList);
	if (soap_out_PointerTott__ItemList(soap, tag?tag:"tt:ItemList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemList ** SOAP_FMAC4 soap_get_PointerTott__ItemList(struct soap *soap, struct tt__ItemList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ItemList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ItemList(struct soap *soap, struct tt__ItemList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeSimpleItem = 0;
	a->SimpleItem = NULL;
	a->__sizeElementItem = 0;
	a->ElementItem = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ItemList(struct soap *soap, const struct tt__ItemList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->SimpleItem)
	{	
		int i;
		for (i = 0; i < a->__sizeSimpleItem; i++)
		{
			soap_embedded(soap, a->SimpleItem + i, SOAP_TYPE__tt__ItemList_SimpleItem);
			soap_serialize__tt__ItemList_SimpleItem(soap, a->SimpleItem + i);
		}
	}
	if (a->ElementItem)
	{	
		int i;
		for (i = 0; i < a->__sizeElementItem; i++)
		{
			soap_embedded(soap, a->ElementItem + i, SOAP_TYPE__tt__ItemList_ElementItem);
			soap_serialize__tt__ItemList_ElementItem(soap, a->ElementItem + i);
		}
	}
	soap_serialize_PointerTott__ItemListExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemList(struct soap *soap, const char *tag, int id, const struct tt__ItemList *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ItemList), type))
		return soap->error;
	if (a->SimpleItem)
	{	
		int i;
		for (i = 0; i < a->__sizeSimpleItem; i++)
			if (soap_out__tt__ItemList_SimpleItem(soap, "tt:SimpleItem", -1, a->SimpleItem + i, ""))
				return soap->error;
	}
	if (a->ElementItem)
	{	
		int i;
		for (i = 0; i < a->__sizeElementItem; i++)
			if (soap_out__tt__ItemList_ElementItem(soap, "tt:ElementItem", -1, a->ElementItem + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ItemListExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ItemList * SOAP_FMAC4 soap_in_tt__ItemList(struct soap *soap, const char *tag, struct tt__ItemList *a, const char *type)
{
	struct soap_blist *soap_blist_SimpleItem = NULL;
	struct soap_blist *soap_blist_ElementItem = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ItemList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemList, sizeof(struct tt__ItemList), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__ItemList(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SimpleItem", 1, NULL))
			{	
				if (a->SimpleItem == NULL)
				{	
					if (soap_blist_SimpleItem == NULL)
						soap_blist_SimpleItem = soap_new_block(soap);
					a->SimpleItem = (struct _tt__ItemList_SimpleItem *)soap_push_block(soap, soap_blist_SimpleItem, sizeof(struct _tt__ItemList_SimpleItem));
					if (a->SimpleItem == NULL)
						return NULL;
					soap_default__tt__ItemList_SimpleItem(soap, a->SimpleItem);
				}
				soap_revert(soap);
				if (soap_in__tt__ItemList_SimpleItem(soap, "tt:SimpleItem", a->SimpleItem, ""))
				{
					a->__sizeSimpleItem++;
					a->SimpleItem = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ElementItem", 1, NULL))
			{	
				if (a->ElementItem == NULL)
				{	
					if (soap_blist_ElementItem == NULL)
						soap_blist_ElementItem = soap_new_block(soap);
					a->ElementItem = (struct _tt__ItemList_ElementItem *)soap_push_block(soap, soap_blist_ElementItem, sizeof(struct _tt__ItemList_ElementItem));
					if (a->ElementItem == NULL)
						return NULL;
					soap_default__tt__ItemList_ElementItem(soap, a->ElementItem);
				}
				soap_revert(soap);
				if (soap_in__tt__ItemList_ElementItem(soap, "tt:ElementItem", a->ElementItem, ""))
				{	
					a->__sizeElementItem++;
					a->ElementItem = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemListExtension(soap, "tt:Extension", &a->Extension, "tt:ItemListExtension"))
				{	
					soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SimpleItem)
			soap_pop_block(soap, soap_blist_SimpleItem);
		if (a->__sizeSimpleItem)
			a->SimpleItem = (struct _tt__ItemList_SimpleItem *)soap_save_block(soap, soap_blist_SimpleItem, NULL, 1);
		else
		{	
			a->SimpleItem = NULL;
			if (soap_blist_SimpleItem)
				soap_end_block(soap, soap_blist_SimpleItem);
		}
		if (a->ElementItem)
			soap_pop_block(soap, soap_blist_ElementItem);
		if (a->__sizeElementItem)
			a->ElementItem = (struct _tt__ItemList_ElementItem *)soap_save_block(soap, soap_blist_ElementItem, NULL, 1);
		else
		{	
			a->ElementItem = NULL;
			if (soap_blist_ElementItem)
				soap_end_block(soap, soap_blist_ElementItem);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__ItemList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemList, 0, sizeof(struct tt__ItemList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ItemList(struct soap *soap, const struct tt__ItemList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ItemList);
	if (soap_out_tt__ItemList(soap, tag?tag:"tt:ItemList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemList * SOAP_FMAC4 soap_get_tt__ItemList(struct soap *soap, struct tt__ItemList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemListExtension(struct soap *soap, struct tt__ItemListExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ItemListExtension))
		soap_serialize_tt__ItemListExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemListExtension(struct soap *soap, const char *tag, int id, struct tt__ItemListExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ItemListExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ItemListExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ItemListExtension ** SOAP_FMAC4 soap_in_PointerTott__ItemListExtension(struct soap *soap, const char *tag, struct tt__ItemListExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__ItemListExtension **)soap_malloc(soap, sizeof(struct tt__ItemListExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__ItemListExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__ItemListExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemListExtension, sizeof(struct tt__ItemListExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemListExtension(struct soap *soap, struct tt__ItemListExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ItemListExtension);
	if (soap_out_PointerTott__ItemListExtension(soap, tag?tag:"tt:ItemListExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemListExtension ** SOAP_FMAC4 soap_get_PointerTott__ItemListExtension(struct soap *soap, struct tt__ItemListExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ItemListExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ItemList_ElementItem(struct soap *soap, struct _tt__ItemList_ElementItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ItemList_ElementItem))
		soap_serialize__tt__ItemList_ElementItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ItemList_ElementItem(struct soap *soap, const char *tag, int id, struct _tt__ItemList_ElementItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ItemList_ElementItem);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ItemList_ElementItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ItemList_ElementItem ** SOAP_FMAC4 soap_in_PointerTo_tt__ItemList_ElementItem(struct soap *soap, const char *tag, struct _tt__ItemList_ElementItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tt__ItemList_ElementItem **)soap_malloc(soap, sizeof(struct _tt__ItemList_ElementItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tt__ItemList_ElementItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tt__ItemList_ElementItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemList_ElementItem, sizeof(struct _tt__ItemList_ElementItem), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ItemList_ElementItem(struct soap *soap, struct _tt__ItemList_ElementItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tt__ItemList_ElementItem);
	if (soap_out_PointerTo_tt__ItemList_ElementItem(soap, tag?tag:"tt:ItemList-ElementItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemList_ElementItem ** SOAP_FMAC4 soap_get_PointerTo_tt__ItemList_ElementItem(struct soap *soap, struct _tt__ItemList_ElementItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ItemList_ElementItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, struct _tt__ItemList_SimpleItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ItemList_SimpleItem))
		soap_serialize__tt__ItemList_SimpleItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, const char *tag, int id, struct _tt__ItemList_SimpleItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ItemList_SimpleItem);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ItemList_SimpleItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ItemList_SimpleItem ** SOAP_FMAC4 soap_in_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, const char *tag, struct _tt__ItemList_SimpleItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tt__ItemList_SimpleItem **)soap_malloc(soap, sizeof(struct _tt__ItemList_SimpleItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tt__ItemList_SimpleItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tt__ItemList_SimpleItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemList_SimpleItem, sizeof(struct _tt__ItemList_SimpleItem), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, struct _tt__ItemList_SimpleItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tt__ItemList_SimpleItem);
	if (soap_out_PointerTo_tt__ItemList_SimpleItem(soap, tag?tag:"tt:ItemList-SimpleItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemList_SimpleItem ** SOAP_FMAC4 soap_get_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, struct _tt__ItemList_SimpleItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ItemList_SimpleItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ItemListExtension(struct soap *soap, struct tt__ItemListExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ItemListExtension(struct soap *soap, const struct tt__ItemListExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemListExtension(struct soap *soap, const char *tag, int id, const struct tt__ItemListExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ItemListExtension), type))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ItemListExtension * SOAP_FMAC4 soap_in_tt__ItemListExtension(struct soap *soap, const char *tag, struct tt__ItemListExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ItemListExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemListExtension, sizeof(struct tt__ItemListExtension), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__ItemListExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__ItemListExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemListExtension, 0, sizeof(struct tt__ItemListExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ItemListExtension(struct soap *soap, const struct tt__ItemListExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ItemListExtension);
	if (soap_out_tt__ItemListExtension(soap, tag?tag:"tt:ItemListExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemListExtension * SOAP_FMAC4 soap_get_tt__ItemListExtension(struct soap *soap, struct tt__ItemListExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemListExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__ItemList_ElementItem(struct soap *soap, struct _tt__ItemList_ElementItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	soap_default_string(soap, &a->Name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__ItemList_ElementItem(struct soap *soap, const struct _tt__ItemList_ElementItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ItemList_ElementItem(struct soap *soap, const char *tag, int id, const struct _tt__ItemList_ElementItem *a, const char *type)
{
	if (a->Name)
		soap_set_attr(soap, "Name", a->Name, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ItemList_ElementItem), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__ItemList_ElementItem * SOAP_FMAC4 soap_in__tt__ItemList_ElementItem(struct soap *soap, const char *tag, struct _tt__ItemList_ElementItem *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tt__ItemList_ElementItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ItemList_ElementItem, sizeof(struct _tt__ItemList_ElementItem), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tt__ItemList_ElementItem(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1), &a->Name, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	
					soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tt__ItemList_ElementItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ItemList_ElementItem, 0, sizeof(struct _tt__ItemList_ElementItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__ItemList_ElementItem(struct soap *soap, const struct _tt__ItemList_ElementItem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tt__ItemList_ElementItem);
	if (soap_out__tt__ItemList_ElementItem(soap, tag?tag:"tt:ItemList-ElementItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemList_ElementItem * SOAP_FMAC4 soap_get__tt__ItemList_ElementItem(struct soap *soap, struct _tt__ItemList_ElementItem *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ItemList_ElementItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__ItemList_SimpleItem(struct soap *soap, struct _tt__ItemList_SimpleItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	soap_default_xsd__anySimpleType(soap, &a->Value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__ItemList_SimpleItem(struct soap *soap, const struct _tt__ItemList_SimpleItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ItemList_SimpleItem(struct soap *soap, const char *tag, int id, const struct _tt__ItemList_SimpleItem *a, const char *type)
{
	if (a->Name)
		soap_set_attr(soap, "Name", a->Name, 1);
	if (a->Value)
		soap_set_attr(soap, "Value", a->Value, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ItemList_SimpleItem), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__ItemList_SimpleItem * SOAP_FMAC4 soap_in__tt__ItemList_SimpleItem(struct soap *soap, const char *tag, struct _tt__ItemList_SimpleItem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tt__ItemList_SimpleItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ItemList_SimpleItem, sizeof(struct _tt__ItemList_SimpleItem), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tt__ItemList_SimpleItem(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1), &a->Name, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Value", 1), &a->Value, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tt__ItemList_SimpleItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ItemList_SimpleItem, 0, sizeof(struct _tt__ItemList_SimpleItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__ItemList_SimpleItem(struct soap *soap, const struct _tt__ItemList_SimpleItem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tt__ItemList_SimpleItem);
	if (soap_out__tt__ItemList_SimpleItem(soap, tag?tag:"tt:ItemList-SimpleItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemList_SimpleItem * SOAP_FMAC4 soap_get__tt__ItemList_SimpleItem(struct soap *soap, struct _tt__ItemList_SimpleItem *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ItemList_SimpleItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedInt(struct soap *soap, unsigned int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedInt(struct soap *soap, const char *tag, int id, unsigned int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedInt);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedInt(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_in_PointerTounsignedInt(struct soap *soap, const char *tag, unsigned int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (unsigned int **)soap_malloc(soap, sizeof(unsigned int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_unsignedInt(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (unsigned int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedInt, sizeof(unsigned int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedInt(struct soap *soap, unsigned int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedInt);
	if (soap_out_PointerTounsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_get_PointerTounsignedInt(struct soap *soap, unsigned int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__MetadataType))
		soap_serialize_wsa5__MetadataType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, int id, struct wsa5__MetadataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__MetadataType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__MetadataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_in_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct wsa5__MetadataType **)soap_malloc(soap, sizeof(struct wsa5__MetadataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_wsa5__MetadataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct wsa5__MetadataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa5__MetadataType);
	if (soap_out_PointerTowsa5__MetadataType(soap, tag?tag:"wsa5:MetadataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_get_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__MetadataType(struct soap *soap, const char *tag, int id, const struct wsa5__MetadataType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__MetadataType), type))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_in_wsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__MetadataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_wsa5__MetadataType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct wsa5__MetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__MetadataType, 0, sizeof(struct wsa5__MetadataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__MetadataType);
	if (soap_out_wsa5__MetadataType(soap, tag?tag:"wsa5:MetadataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_get_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPType(struct soap *soap, enum tt__IPType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__IPType
	*a = SOAP_DEFAULT_tt__IPType;
#else
	*a = (enum tt__IPType)0;
#endif
}

static const struct soap_code_map soap_codes_tt__IPType[] =
{	
	{ (long)tt__IPType__IPv4, "IPv4" },
	{ (long)tt__IPType__IPv6, "IPv6" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__IPType2s(struct soap *soap, enum tt__IPType n)
{	
	const char *s = soap_code_str(soap_codes_tt__IPType, (long)n);
	if (s != NULL)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPType(struct soap *soap, const char *tag, int id, const enum tt__IPType *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPType), type) || soap_send(soap, soap_tt__IPType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__IPType(struct soap *soap, const char *s, enum tt__IPType *a)
{
	const struct soap_code_map *map;
	if (s == NULL)
		return soap->error;
	map = soap_code(soap_codes_tt__IPType, s);
	if (map)
		*a = (enum tt__IPType)map->code;
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__IPType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__IPType * SOAP_FMAC4 soap_in_tt__IPType(struct soap *soap, const char *tag, enum tt__IPType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	return NULL;
	a = (enum tt__IPType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPType, sizeof(enum tt__IPType), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	if (soap->body && !*soap->href)
	{	
		if (!a || soap_s2tt__IPType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (enum tt__IPType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPType, 0, sizeof(enum tt__IPType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPType(struct soap *soap, const enum tt__IPType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPType);
	if (soap_out_tt__IPType(soap, tag?tag:"tt:IPType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IPType * SOAP_FMAC4 soap_get_tt__IPType(struct soap *soap, enum tt__IPType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPAddress(struct soap *soap, struct tt__IPAddress *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPAddress))
		soap_serialize_tt__IPAddress(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPAddress(struct soap *soap, const char *tag, int id, struct tt__IPAddress *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPAddress);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPAddress(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPAddress ** SOAP_FMAC4 soap_in_PointerTott__IPAddress(struct soap *soap, const char *tag, struct tt__IPAddress **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__IPAddress **)soap_malloc(soap, sizeof(struct tt__IPAddress *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__IPAddress(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__IPAddress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPAddress, sizeof(struct tt__IPAddress), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPAddress(struct soap *soap, struct tt__IPAddress *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPAddress);
	if (soap_out_PointerTott__IPAddress(soap, tag?tag:"tt:IPAddress", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPAddress ** SOAP_FMAC4 soap_get_PointerTott__IPAddress(struct soap *soap, struct tt__IPAddress **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPAddress(struct soap *soap, struct tt__IPAddress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__IPType(soap, &a->Type);
	a->IPv4Address = NULL;
	a->IPv6Address = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPAddress(struct soap *soap, const struct tt__IPAddress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IPv4Address(soap, &a->IPv4Address);
	soap_serialize_PointerTott__IPv6Address(soap, &a->IPv6Address);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddress(struct soap *soap, const char *tag, int id, const struct tt__IPAddress *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPAddress), type))
		return soap->error;
	if (soap_out_tt__IPType(soap, "tt:Type", -1, &a->Type, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv4Address(soap, "tt:IPv4Address", -1, &a->IPv4Address, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6Address(soap, "tt:IPv6Address", -1, &a->IPv6Address, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPAddress * SOAP_FMAC4 soap_in_tt__IPAddress(struct soap *soap, const char *tag, struct tt__IPAddress *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_IPv4Address = 1;
	size_t soap_flag_IPv6Address = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IPAddress *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddress, sizeof(struct tt__IPAddress), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__IPAddress(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__IPType(soap, "tt:Type", &a->Type, "tt:IPType"))
				{	
					soap_flag_Type--;
					continue;
				}
			if (soap_flag_IPv4Address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv4Address(soap, "tt:IPv4Address", &a->IPv4Address, "tt:IPv4Address"))
				{	
					soap_flag_IPv4Address--;
					continue;
				}
			if (soap_flag_IPv6Address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv6Address(soap, "tt:IPv6Address", &a->IPv6Address, "tt:IPv6Address"))
				{
					soap_flag_IPv6Address--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__IPAddress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddress, 0, sizeof(struct tt__IPAddress), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPAddress(struct soap *soap, const struct tt__IPAddress *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPAddress);
	if (soap_out_tt__IPAddress(soap, tag?tag:"tt:IPAddress", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPAddress * SOAP_FMAC4 soap_get_tt__IPAddress(struct soap *soap, struct tt__IPAddress *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6Address(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6Address))
		soap_serialize_tt__IPv6Address(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6Address(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6Address);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv6Address(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTott__IPv6Address(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__IPv6Address(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6Address, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6Address(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv6Address);
	if (soap_out_PointerTott__IPv6Address(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTott__IPv6Address(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4Address(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4Address))
		soap_serialize_tt__IPv4Address(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4Address(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4Address);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv4Address(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTott__IPv4Address(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__IPv4Address(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4Address, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4Address(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv4Address);
	if (soap_out_PointerTott__IPv4Address(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTott__IPv4Address(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

//soap resource

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soapParam)
{
	if (soapParam->header != NULL)
	{
		soap_serialize_SOAP_ENV__Header(soapParam, soapParam->header);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soapParam)
{
	if(soapParam->header != NULL)//modify 2012.09.22
	{	
		soapParam->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soapParam, "SOAP-ENV:Header", 0, soapParam->header, NULL))
			return soapParam->error;
		soapParam->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soapParam)
{
	soapParam->part = SOAP_IN_HEADER;
	soapParam->header = soap_in_SOAP_ENV__Header(soapParam, "SOAP-ENV:Header", NULL, NULL);
	soapParam->part = SOAP_END_HEADER;
	return soapParam->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soapParam)
{
	if (soapParam->header == NULL)
	{	
		if ((soapParam->header = (struct SOAP_ENV__Header*)soap_malloc(soapParam, sizeof(struct SOAP_ENV__Header))))
			soap_default_SOAP_ENV__Header(soapParam, soapParam->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soapParam)
{
	if (!soapParam->fault)
	{	
		soapParam->fault = (struct SOAP_ENV__Fault*)soap_malloc(soapParam, sizeof(struct SOAP_ENV__Fault));
		if (!soapParam->fault)
			return;
		soap_default_SOAP_ENV__Fault(soapParam, soapParam->fault);
	}
	if (soapParam->version == 2 && !soapParam->fault->SOAP_ENV__Code)
	{	
		soapParam->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soapParam, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soapParam, soapParam->fault->SOAP_ENV__Code);
	}
	if (soapParam->version == 2 && !soapParam->fault->SOAP_ENV__Reason)
	{	
		soapParam->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soapParam, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soapParam, soapParam->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soapParam)
{
	if (soapParam->fault)
		soap_serialize_SOAP_ENV__Fault(soapParam, soapParam->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soapParam)
{
	if (soapParam->fault)
		return soap_put_SOAP_ENV__Fault(soapParam, soapParam->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soapParam)
{
	return (soapParam->fault = soap_get_SOAP_ENV__Fault(soapParam, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soapParam)
{
	soap_fault(soapParam);
	if (soapParam->version == 2)
		return (const char**)&soapParam->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soapParam->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soapParam)
{
	soap_fault(soapParam);
	if (soapParam->version == 2)
	{	
		if (!soapParam->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	
			soapParam->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soapParam, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soapParam, soapParam->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soapParam->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soapParam->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soapParam)
{
	soap_fault(soapParam);
	if (soapParam->version == 2)
		return (const char**)&soapParam->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soapParam->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soapParam)
{
	soap_fault(soapParam);
	if (soapParam->version == 1)
	{	
		if (!soapParam->fault->detail)
		{	soapParam->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soapParam, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soapParam, soapParam->fault->detail);
		}
		return (const char**)&soapParam->fault->detail->__any;
	}
	if (!soapParam->fault->SOAP_ENV__Detail)
	{	
		soapParam->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soapParam, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soapParam, soapParam->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soapParam->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soapParam)
{
	int t;
	//if (soap->version == 1)
	{	
		for (;;)
		{	
			if (!soap_getelement(soapParam, &t))
				if (soapParam->error || soap_ignore_element(soapParam))
					break;
		}
	}
	if (soapParam->error == SOAP_NO_TAG || soapParam->error == SOAP_EOF)
		soapParam->error = SOAP_OK;
	return soapParam->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soapParam, int *type)
{
	if (soap_peek_element(soapParam))
		return NULL;
	if (!*soapParam->id || !(*type = soap_lookup_type(soapParam, soapParam->id)))
		*type = soap_lookup_type(soapParam, soapParam->href);
	switch (*type)
	{
		case SOAP_TYPE_byte:
			return soap_in_byte(soapParam, NULL, NULL, "xsd:byte");
		case SOAP_TYPE_int:
			return soap_in_int(soapParam, NULL, NULL, "xsd:int");
		case SOAP_TYPE_unsignedInt:
			return soap_in_unsignedInt(soapParam, NULL, NULL, "xsd:unsignedInt");
		case SOAP_TYPE_d__FaultCodeType:
			return soap_in_d__FaultCodeType(soapParam, NULL, NULL, "d:FaultCodeType");
		case SOAP_TYPE_d__RelationshipType:
			return soap_in_d__RelationshipType(soapParam, NULL, NULL, "d:RelationshipType");
		case SOAP_TYPE_wsa__FaultSubcodeValues:
			return soap_in_wsa__FaultSubcodeValues(soapParam, NULL, NULL, "wsa:FaultSubcodeValues");
		case SOAP_TYPE_wsa__RelationshipTypeValues:
			return soap_in_wsa__RelationshipTypeValues(soapParam, NULL, NULL, "wsa:RelationshipTypeValues");
		case SOAP_TYPE_d__AppSequenceType:
			return soap_in_d__AppSequenceType(soapParam, NULL, NULL, "d:AppSequenceType");
		case SOAP_TYPE_d__SigType:
			return soap_in_d__SigType(soapParam, NULL, NULL, "d:SigType");
		case SOAP_TYPE_d__SecurityType:
			return soap_in_d__SecurityType(soapParam, NULL, NULL, "d:SecurityType");
		case SOAP_TYPE_d__ResolveMatchType:
			return soap_in_d__ResolveMatchType(soapParam, NULL, NULL, "d:ResolveMatchType");
		case SOAP_TYPE_d__ResolveMatchesType:
			return soap_in_d__ResolveMatchesType(soapParam, NULL, NULL, "d:ResolveMatchesType");
		case SOAP_TYPE_d__ResolveType:
			return soap_in_d__ResolveType(soapParam, NULL, NULL, "d:ResolveType");
		case SOAP_TYPE_d__ProbeMatchType:
			return soap_in_d__ProbeMatchType(soapParam, NULL, NULL, "d:ProbeMatchType");
		case SOAP_TYPE_d__ProbeMatchesType:
			return soap_in_d__ProbeMatchesType(soapParam, NULL, NULL, "d:ProbeMatchesType");
		case SOAP_TYPE_d__ProbeType:
			return soap_in_d__ProbeType(soapParam, NULL, NULL, "d:ProbeType");
			//case SOAP_TYPE_d__ByeType:
			//	return soap_in_d__ByeType(soapParam, NULL, NULL, "d:ByeType");
		case SOAP_TYPE_d__ScopesType:
			return soap_in_d__ScopesType(soapParam, NULL, NULL, "d:ScopesType");
			//case SOAP_TYPE_d__HelloType:
			//	return soap_in_d__HelloType(soapParam, NULL, NULL, "d:HelloType");
		case SOAP_TYPE_wsa__Relationship:
			return soap_in_wsa__Relationship(soapParam, NULL, NULL, "wsa:Relationship");
		case SOAP_TYPE_wsa__ServiceNameType:
			return soap_in_wsa__ServiceNameType(soapParam, NULL, NULL, "wsa:ServiceNameType");
		case SOAP_TYPE_wsa__ReferenceParametersType:
			return soap_in_wsa__ReferenceParametersType(soapParam, NULL, NULL, "wsa:ReferenceParametersType");
		case SOAP_TYPE_wsa__ReferencePropertiesType:
			return soap_in_wsa__ReferencePropertiesType(soapParam, NULL, NULL, "wsa:ReferencePropertiesType");
		case SOAP_TYPE_wsa__EndpointReferenceType:
			return soap_in_wsa__EndpointReferenceType(soapParam, NULL, NULL, "wsa:EndpointReferenceType");
		case SOAP_TYPE_PointerTod__ByeType:
			return soap_in_PointerTod__ByeType(soapParam, NULL, NULL, "d:ByeType");
		case SOAP_TYPE_PointerTod__ResolveType:
			return soap_in_PointerTod__ResolveType(soapParam, NULL, NULL, "d:ResolveType");
		case SOAP_TYPE_PointerTod__HelloType:
			return soap_in_PointerTod__HelloType(soapParam, NULL, NULL, "d:HelloType");
		case SOAP_TYPE_PointerTod__ProbeMatchesType:
			return soap_in_PointerTod__ProbeMatchesType(soapParam, NULL, NULL, "d:ProbeMatchesType");
		case SOAP_TYPE_PointerTod__ProbeType:
			return soap_in_PointerTod__ProbeType(soapParam, NULL, NULL, "d:ProbeType");
		case SOAP_TYPE_PointerTod__SigType:
			return soap_in_PointerTod__SigType(soapParam, NULL, NULL, "d:SigType");
		case SOAP_TYPE_PointerTod__ResolveMatchType:
			return soap_in_PointerTod__ResolveMatchType(soapParam, NULL, NULL, "d:ResolveMatchType");
		case SOAP_TYPE_PointerTod__ProbeMatchType:
			return soap_in_PointerTod__ProbeMatchType(soapParam, NULL, NULL, "d:ProbeMatchType");
		case SOAP_TYPE_PointerTounsignedInt:
			return soap_in_PointerTounsignedInt(soapParam, NULL, NULL, "xsd:unsignedInt");
		case SOAP_TYPE_PointerTod__ScopesType:
			return soap_in_PointerTod__ScopesType(soapParam, NULL, NULL, "d:ScopesType");
		case SOAP_TYPE_d__FaultCodeOpenType:
			{	
				char **s;
				s = soap_in_d__FaultCodeOpenType(soapParam, NULL, NULL, "d:FaultCodeOpenType");
				return s ? *s : NULL;
			}
		case SOAP_TYPE_d__UriListType:
			{	
				char **s;
				s = soap_in_d__UriListType(soapParam, NULL, NULL, "d:UriListType");
				return s ? *s : NULL;
			}
		case SOAP_TYPE_d__QNameListType:
			{	
				char **s;
				s = soap_in_d__QNameListType(soapParam, NULL, NULL, "d:QNameListType");
				return s ? *s : NULL;
			}
		case SOAP_TYPE_d__OpenRelationshipType:
			{	
				char **s;
				s = soap_in_d__OpenRelationshipType(soapParam, NULL, NULL, "d:OpenRelationshipType");
				return s ? *s : NULL;
			}
		case SOAP_TYPE_xsd__IDREFS:
			{	
				char **s;
				s = soap_in_xsd__IDREFS(soapParam, NULL, NULL, "xsd:IDREFS");
				return s ? *s : NULL;
			}
		case SOAP_TYPE_PointerTo_wsa__FaultTo:
			return soap_in_PointerTo_wsa__FaultTo(soapParam, NULL, NULL, "wsa:FaultTo");
		case SOAP_TYPE_PointerTo_wsa__ReplyTo:
			return soap_in_PointerTo_wsa__ReplyTo(soapParam, NULL, NULL, "wsa:ReplyTo");
		case SOAP_TYPE_PointerTo_wsa__From:
			return soap_in_PointerTo_wsa__From(soapParam, NULL, NULL, "wsa:From");
		case SOAP_TYPE_PointerTo_wsa__RelatesTo:
			return soap_in_PointerTo_wsa__RelatesTo(soapParam, NULL, NULL, "wsa:RelatesTo");
		case SOAP_TYPE_PointerTowsa__ServiceNameType:
			return soap_in_PointerTowsa__ServiceNameType(soapParam, NULL, NULL, "wsa:ServiceNameType");
		case SOAP_TYPE_PointerTo_QName:
			return soap_in_PointerTo_QName(soapParam, NULL, NULL, "xsd:QName");
		case SOAP_TYPE_PointerTowsa__ReferenceParametersType:
			return soap_in_PointerTowsa__ReferenceParametersType(soapParam, NULL, NULL, "wsa:ReferenceParametersType");
		case SOAP_TYPE_PointerTowsa__ReferencePropertiesType:
			return soap_in_PointerTowsa__ReferencePropertiesType(soapParam, NULL, NULL, "wsa:ReferencePropertiesType");
		case SOAP_TYPE__QName:
			{	
				char **s;
				s = soap_in__QName(soapParam, NULL, NULL, "xsd:QName");
				return s ? *s : NULL;
			}
		case SOAP_TYPE_string:
			{	
				char **s;
				s = soap_in_string(soapParam, NULL, NULL, "xsd:string");
				return s ? *s : NULL;
			}
		default:
			{	
				const char *t = soapParam->type;
				if (!*t)
					t = soapParam->tag;
				if (!soap_match_tag(soapParam, t, "xsd:byte"))
				{	
					*type = SOAP_TYPE_byte;
					return soap_in_byte(soapParam, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soapParam, t, "xsd:int"))
				{	
					*type = SOAP_TYPE_int;
					return soap_in_int(soapParam, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soapParam, t, "xsd:unsignedInt"))
				{	
					*type = SOAP_TYPE_unsignedInt;
					return soap_in_unsignedInt(soapParam, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soapParam, t, "d:FaultCodeType"))
				{	
					*type = SOAP_TYPE_d__FaultCodeType;
					return soap_in_d__FaultCodeType(soapParam, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soapParam, t, "d:RelationshipType"))
				{	
					*type = SOAP_TYPE_d__RelationshipType;
					return soap_in_d__RelationshipType(soapParam, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soapParam, t, "wsa:FaultSubcodeValues"))
				{	
					*type = SOAP_TYPE_wsa__FaultSubcodeValues;
					return soap_in_wsa__FaultSubcodeValues(soapParam, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soapParam, t, "wsa:RelationshipTypeValues"))
				{	
					*type = SOAP_TYPE_wsa__RelationshipTypeValues;
					return soap_in_wsa__RelationshipTypeValues(soapParam, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soapParam, t, "d:AppSequenceType"))
				{	
					*type = SOAP_TYPE_d__AppSequenceType;
					return soap_in_d__AppSequenceType(soapParam, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soapParam, t, "d:SigType"))
				{	
					*type = SOAP_TYPE_d__SigType;
					return soap_in_d__SigType(soapParam, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soapParam, t, "d:SecurityType"))
				{	
					*type = SOAP_TYPE_d__SecurityType;
					return soap_in_d__SecurityType(soapParam, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soapParam, t, "d:ResolveMatchType"))
				{	
					*type = SOAP_TYPE_d__ResolveMatchType;
					return soap_in_d__ResolveMatchType(soapParam, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soapParam, t, "d:ResolveMatchesType"))
				{	
					*type = SOAP_TYPE_d__ResolveMatchesType;
					return soap_in_d__ResolveMatchesType(soapParam, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soapParam, t, "d:ResolveType"))
				{	
					*type = SOAP_TYPE_d__ResolveType;
					return soap_in_d__ResolveType(soapParam, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soapParam, t, "d:ProbeMatchType"))
				{	
					*type = SOAP_TYPE_d__ProbeMatchType;
					return soap_in_d__ProbeMatchType(soapParam, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soapParam, t, "d:ProbeMatchesType"))
				{	
					*type = SOAP_TYPE_d__ProbeMatchesType;
					return soap_in_d__ProbeMatchesType(soapParam, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soapParam, t, "d:ProbeType"))
				{	
					*type = SOAP_TYPE_d__ProbeType;
					return soap_in_d__ProbeType(soapParam, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soapParam, t, "d:ByeType"))
				{	
					*type = SOAP_TYPE_d__ByeType;
					return soap_in_d__ByeType(soapParam, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soapParam, t, "d:ScopesType"))
				{	
					*type = SOAP_TYPE_d__ScopesType;
					return soap_in_d__ScopesType(soapParam, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soapParam, t, "d:HelloType"))
				{	
					*type = SOAP_TYPE_d__HelloType;
					return soap_in_d__HelloType(soapParam, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soapParam, t, "wsa:Relationship"))
				{	
					*type = SOAP_TYPE_wsa__Relationship;
					return soap_in_wsa__Relationship(soapParam, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soapParam, t, "wsa:ServiceNameType"))
				{	
					*type = SOAP_TYPE_wsa__ServiceNameType;
					return soap_in_wsa__ServiceNameType(soapParam, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soapParam, t, "wsa:ReferenceParametersType"))
				{	
					*type = SOAP_TYPE_wsa__ReferenceParametersType;
					return soap_in_wsa__ReferenceParametersType(soapParam, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soapParam, t, "wsa:ReferencePropertiesType"))
				{	
					*type = SOAP_TYPE_wsa__ReferencePropertiesType;
					return soap_in_wsa__ReferencePropertiesType(soapParam, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soapParam, t, "wsa:EndpointReferenceType"))
				{	
					*type = SOAP_TYPE_wsa__EndpointReferenceType;
					return soap_in_wsa__EndpointReferenceType(soapParam, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soapParam, t, "d:FaultCodeOpenType"))
				{	
					char **s;
					*type = SOAP_TYPE_d__FaultCodeOpenType;
					s = soap_in_d__FaultCodeOpenType(soapParam, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				if (!soap_match_tag(soapParam, t, "d:UriListType"))
				{	
					char **s;
					*type = SOAP_TYPE_d__UriListType;
					s = soap_in_d__UriListType(soapParam, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				if (!soap_match_tag(soapParam, t, "d:QNameListType"))
				{	
					char **s;
					*type = SOAP_TYPE_d__QNameListType;
					s = soap_in_d__QNameListType(soapParam, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				if (!soap_match_tag(soapParam, t, "d:OpenRelationshipType"))
				{	
					char **s;
					*type = SOAP_TYPE_d__OpenRelationshipType;
					s = soap_in_d__OpenRelationshipType(soapParam, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				if (!soap_match_tag(soapParam, t, "xsd:IDREFS"))
				{	
					char **s;
					*type = SOAP_TYPE_xsd__IDREFS;
					s = soap_in_xsd__IDREFS(soapParam, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				if (!soap_match_tag(soapParam, t, "xsd:QName"))
				{	
					char **s;
					*type = SOAP_TYPE__QName;
					s = soap_in__QName(soapParam, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				if (!soap_match_tag(soapParam, t, "xsd:string"))
				{	
					char **s;
					*type = SOAP_TYPE_string;
					s = soap_in_string(soapParam, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				t = soapParam->tag;
				if (!soap_match_tag(soapParam, t, "wsa:ReplyAfter"))
				{	
					*type = SOAP_TYPE__wsa__ReplyAfter;
					return soap_in__wsa__ReplyAfter(soapParam, NULL, NULL, NULL);
				}

				if (!soap_match_tag(soapParam, t, "wsa:FaultTo"))
				{	
					*type = SOAP_TYPE__wsa__FaultTo;
					return soap_in__wsa__FaultTo(soapParam, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soapParam, t, "wsa:ReplyTo"))
				{	
					*type = SOAP_TYPE__wsa__ReplyTo;
					return soap_in__wsa__ReplyTo(soapParam, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soapParam, t, "wsa:From"))
				{	
					*type = SOAP_TYPE__wsa__From;
					return soap_in__wsa__From(soapParam, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soapParam, t, "wsa:RelatesTo"))
				{	
					*type = SOAP_TYPE__wsa__RelatesTo;
					return soap_in__wsa__RelatesTo(soapParam, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soapParam, t, "wsa:EndpointReference"))
				{	
					*type = SOAP_TYPE__wsa__EndpointReference;
					return soap_in__wsa__EndpointReference(soapParam, NULL, NULL, NULL);
				}
				if (!soap_match_tag(soapParam, t, "wsa:Action"))
				{	
					char **s;
					*type = SOAP_TYPE__wsa__Action;
					s = soap_in__wsa__Action(soapParam, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				if (!soap_match_tag(soapParam, t, "wsa:To"))
				{	
					char **s;
					*type = SOAP_TYPE__wsa__To;
					s = soap_in__wsa__To(soapParam, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
				if (!soap_match_tag(soapParam, t, "wsa:MessageID"))
				{	
					char **s;
					*type = SOAP_TYPE__wsa__MessageID;
					s = soap_in__wsa__MessageID(soapParam, NULL, NULL, NULL);
					return s ? *s : NULL;
				}
		}
	}
	soapParam->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soapParam)
{
	if (!soap_peek_element(soapParam))
	{	
		int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (((soapParam->mode & SOAP_XML_STRICT) && soapParam->part != SOAP_IN_HEADER) || !soap_match_tag(soapParam, soapParam->tag, "SOAP-ENV:"))
		{	
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soapParam->tag));
			return soapParam->error = SOAP_TAG_MISMATCH;
		}
		if (!*soapParam->id || !soap_getelement(soapParam, &t))
		{	
			soapParam->peeked = 0;
			if (soapParam->fignore)
				soapParam->error = soapParam->fignore(soapParam, soapParam->tag);
			else
				soapParam->error = SOAP_OK;
			DBGLOG(TEST, if (!soapParam->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soapParam->tag));
			if (!soapParam->error && soapParam->body)
			{	
				soapParam->level++;
				while (!soap_ignore_element(soapParam))
					;
				if (soapParam->error == SOAP_NO_TAG)
					soapParam->error = soap_element_end_in(soapParam, NULL);
			}
		}
	}
	return soapParam->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soapParam)
{
	int i;
	struct soap_plist *pp;
	if (soapParam->version == 1 
		&& soapParam->encodingStyle 
		&& !(soapParam->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
	{
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soapParam->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soapParam, pp->ptr, "id", pp->id, pp->type))
						return soapParam->error;
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE__wsa__ReplyAfter:
		return soap_out__wsa__ReplyAfter(soap, "wsa:ReplyAfter", id, (const unsigned int *)ptr, NULL);
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_d__FaultCodeType:
		return soap_out_d__FaultCodeType(soap, tag, id, (const enum d__FaultCodeType *)ptr, "d:FaultCodeType");
	case SOAP_TYPE_d__RelationshipType:
		return soap_out_d__RelationshipType(soap, tag, id, (const enum d__RelationshipType *)ptr, "d:RelationshipType");
	case SOAP_TYPE_wsa__FaultSubcodeValues:
		return soap_out_wsa__FaultSubcodeValues(soap, tag, id, (const enum wsa__FaultSubcodeValues *)ptr, "wsa:FaultSubcodeValues");
	case SOAP_TYPE_wsa__RelationshipTypeValues:
		return soap_out_wsa__RelationshipTypeValues(soap, tag, id, (const enum wsa__RelationshipTypeValues *)ptr, "wsa:RelationshipTypeValues");
	case SOAP_TYPE_d__AppSequenceType:
		return soap_out_d__AppSequenceType(soap, tag, id, (const struct d__AppSequenceType *)ptr, "d:AppSequenceType");
	case SOAP_TYPE_d__SigType:
		return soap_out_d__SigType(soap, tag, id, (const struct d__SigType *)ptr, "d:SigType");
	case SOAP_TYPE_d__SecurityType:
		return soap_out_d__SecurityType(soap, tag, id, (const struct d__SecurityType *)ptr, "d:SecurityType");
	case SOAP_TYPE_d__ResolveMatchType:
		return soap_out_d__ResolveMatchType(soap, tag, id, (const struct d__ResolveMatchType *)ptr, "d:ResolveMatchType");
	case SOAP_TYPE_d__ResolveMatchesType:
		return soap_out_d__ResolveMatchesType(soap, tag, id, (const struct d__ResolveMatchesType *)ptr, "d:ResolveMatchesType");
	case SOAP_TYPE_d__ResolveType:
		return soap_out_d__ResolveType(soap, tag, id, (const struct d__ResolveType *)ptr, "d:ResolveType");
	case SOAP_TYPE_d__ProbeMatchType:
		return soap_out_d__ProbeMatchType(soap, tag, id, (const struct d__ProbeMatchType *)ptr, "d:ProbeMatchType");
	case SOAP_TYPE_d__ProbeMatchesType:
		return soap_out_d__ProbeMatchesType(soap, tag, id, (const struct d__ProbeMatchesType *)ptr, "d:ProbeMatchesType");
	case SOAP_TYPE_d__ProbeType:
		return soap_out_d__ProbeType(soap, tag, id, (const struct d__ProbeType *)ptr, "d:ProbeType");
	case SOAP_TYPE_d__ByeType:
		return soap_out_d__ByeType(soap, tag, id, (const struct d__ByeType *)ptr, "d:ByeType");
	case SOAP_TYPE_d__ScopesType:
		return soap_out_d__ScopesType(soap, tag, id, (const struct d__ScopesType *)ptr, "d:ScopesType");
	case SOAP_TYPE_d__HelloType:
		return soap_out_d__HelloType(soap, tag, id, (const struct d__HelloType *)ptr, "d:HelloType");
	case SOAP_TYPE__wsa__FaultTo:
		return soap_out__wsa__FaultTo(soap, "wsa:FaultTo", id, (const struct wsa__EndpointReferenceType *)ptr, NULL);
	case SOAP_TYPE__wsa__ReplyTo:
		return soap_out__wsa__ReplyTo(soap, "wsa:ReplyTo", id, (const struct wsa__EndpointReferenceType *)ptr, NULL);
	case SOAP_TYPE__wsa__From:
		return soap_out__wsa__From(soap, "wsa:From", id, (const struct wsa__EndpointReferenceType *)ptr, NULL);
	case SOAP_TYPE__wsa__RelatesTo:
		return soap_out__wsa__RelatesTo(soap, "wsa:RelatesTo", id, (const struct wsa__Relationship *)ptr, NULL);
	case SOAP_TYPE__wsa__EndpointReference:
		return soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", id, (const struct wsa__EndpointReferenceType *)ptr, NULL);
	case SOAP_TYPE_wsa__Relationship:
		return soap_out_wsa__Relationship(soap, tag, id, (const struct wsa__Relationship *)ptr, "wsa:Relationship");
	case SOAP_TYPE_wsa__ServiceNameType:
		return soap_out_wsa__ServiceNameType(soap, tag, id, (const struct wsa__ServiceNameType *)ptr, "wsa:ServiceNameType");
	case SOAP_TYPE_wsa__ReferenceParametersType:
		return soap_out_wsa__ReferenceParametersType(soap, tag, id, (const struct wsa__ReferenceParametersType *)ptr, "wsa:ReferenceParametersType");
	case SOAP_TYPE_wsa__ReferencePropertiesType:
		return soap_out_wsa__ReferencePropertiesType(soap, tag, id, (const struct wsa__ReferencePropertiesType *)ptr, "wsa:ReferencePropertiesType");
	case SOAP_TYPE_wsa__EndpointReferenceType:
		return soap_out_wsa__EndpointReferenceType(soap, tag, id, (const struct wsa__EndpointReferenceType *)ptr, "wsa:EndpointReferenceType");
	case SOAP_TYPE_PointerTod__ByeType:
		return soap_out_PointerTod__ByeType(soap, tag, id, (struct d__ByeType *const*)ptr, "d:ByeType");
	case SOAP_TYPE_PointerTod__ResolveType:
		return soap_out_PointerTod__ResolveType(soap, tag, id, (struct d__ResolveType *const*)ptr, "d:ResolveType");
	case SOAP_TYPE_PointerTod__HelloType:
		return soap_out_PointerTod__HelloType(soap, tag, id, (struct d__HelloType *const*)ptr, "d:HelloType");
	case SOAP_TYPE_PointerTod__ProbeMatchesType:
		return soap_out_PointerTod__ProbeMatchesType(soap, tag, id, (struct d__ProbeMatchesType *const*)ptr, "d:ProbeMatchesType");
	case SOAP_TYPE_PointerTod__ProbeType:
		return soap_out_PointerTod__ProbeType(soap, tag, id, (struct d__ProbeType *const*)ptr, "d:ProbeType");
	case SOAP_TYPE_PointerTod__SigType:
		return soap_out_PointerTod__SigType(soap, tag, id, (struct d__SigType *const*)ptr, "d:SigType");
	case SOAP_TYPE_PointerTod__ResolveMatchType:
		return soap_out_PointerTod__ResolveMatchType(soap, tag, id, (struct d__ResolveMatchType *const*)ptr, "d:ResolveMatchType");
	case SOAP_TYPE_PointerTod__ProbeMatchType:
		return soap_out_PointerTod__ProbeMatchType(soap, tag, id, (struct d__ProbeMatchType *const*)ptr, "d:ProbeMatchType");
	case SOAP_TYPE_PointerTounsignedInt:
		return soap_out_PointerTounsignedInt(soap, tag, id, (unsigned int *const*)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_PointerTod__ScopesType:
		return soap_out_PointerTod__ScopesType(soap, tag, id, (struct d__ScopesType *const*)ptr, "d:ScopesType");
	case SOAP_TYPE_d__FaultCodeOpenType:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "d:FaultCodeOpenType");
	case SOAP_TYPE_d__UriListType:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "d:UriListType");
	case SOAP_TYPE_d__QNameListType:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "d:QNameListType");
	case SOAP_TYPE_d__OpenRelationshipType:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "d:OpenRelationshipType");
	case SOAP_TYPE_xsd__IDREFS:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:IDREFS");
	case SOAP_TYPE_PointerTo_wsa__FaultTo:
		return soap_out_PointerTo_wsa__FaultTo(soap, tag, id, (struct wsa__EndpointReferenceType *const*)ptr, "wsa:FaultTo");
	case SOAP_TYPE_PointerTo_wsa__ReplyTo:
		return soap_out_PointerTo_wsa__ReplyTo(soap, tag, id, (struct wsa__EndpointReferenceType *const*)ptr, "wsa:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa__From:
		return soap_out_PointerTo_wsa__From(soap, tag, id, (struct wsa__EndpointReferenceType *const*)ptr, "wsa:From");
	case SOAP_TYPE_PointerTo_wsa__RelatesTo:
		return soap_out_PointerTo_wsa__RelatesTo(soap, tag, id, (struct wsa__Relationship *const*)ptr, "wsa:RelatesTo");
	case SOAP_TYPE__wsa__Action:
		return soap_out_string(soap, "wsa:Action", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE__wsa__To:
		return soap_out_string(soap, "wsa:To", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE__wsa__MessageID:
		return soap_out_string(soap, "wsa:MessageID", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE_PointerTowsa__ServiceNameType:
		return soap_out_PointerTowsa__ServiceNameType(soap, tag, id, (struct wsa__ServiceNameType *const*)ptr, "wsa:ServiceNameType");
	case SOAP_TYPE_PointerTo_QName:
		return soap_out_PointerTo_QName(soap, tag, id, (char **const*)ptr, "xsd:QName");
	case SOAP_TYPE_PointerTowsa__ReferenceParametersType:
		return soap_out_PointerTowsa__ReferenceParametersType(soap, tag, id, (struct wsa__ReferenceParametersType *const*)ptr, "wsa:ReferenceParametersType");
	case SOAP_TYPE_PointerTowsa__ReferencePropertiesType:
		return soap_out_PointerTowsa__ReferencePropertiesType(soap, tag, id, (struct wsa__ReferencePropertiesType *const*)ptr, "wsa:ReferencePropertiesType");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE___dnrd__Bye:
		soap_serialize___dnrd__Bye(soap, (const struct __dnrd__Bye *)ptr);
		break;
	case SOAP_TYPE___dnrd__Hello:
		soap_serialize___dnrd__Hello(soap, (const struct __dnrd__Hello *)ptr);
		break;
	case SOAP_TYPE___dndl__Probe:
		soap_serialize___dndl__Probe(soap, (const struct __dndl__Probe *)ptr);
		break;
	case SOAP_TYPE_d__AppSequenceType:
		soap_serialize_d__AppSequenceType(soap, (const struct d__AppSequenceType *)ptr);
		break;
	case SOAP_TYPE_d__SigType:
		soap_serialize_d__SigType(soap, (const struct d__SigType *)ptr);
		break;
	case SOAP_TYPE_d__SecurityType:
		soap_serialize_d__SecurityType(soap, (const struct d__SecurityType *)ptr);
		break;
	case SOAP_TYPE_d__ResolveMatchType:
		soap_serialize_d__ResolveMatchType(soap, (const struct d__ResolveMatchType *)ptr);
		break;
	case SOAP_TYPE_d__ResolveMatchesType:
		soap_serialize_d__ResolveMatchesType(soap, (const struct d__ResolveMatchesType *)ptr);
		break;
	case SOAP_TYPE_d__ResolveType:
		soap_serialize_d__ResolveType(soap, (const struct d__ResolveType *)ptr);
		break;
	case SOAP_TYPE_d__ProbeMatchType:
		soap_serialize_d__ProbeMatchType(soap, (const struct d__ProbeMatchType *)ptr);
		break;
	case SOAP_TYPE_d__ProbeMatchesType:
		soap_serialize_d__ProbeMatchesType(soap, (const struct d__ProbeMatchesType *)ptr);
		break;
	case SOAP_TYPE_d__ProbeType:
		soap_serialize_d__ProbeType(soap, (const struct d__ProbeType *)ptr);
		break;
	case SOAP_TYPE_d__ByeType:
		soap_serialize_d__ByeType(soap, (const struct d__ByeType *)ptr);
		break;
	case SOAP_TYPE_d__ScopesType:
		soap_serialize_d__ScopesType(soap, (const struct d__ScopesType *)ptr);
		break;
	case SOAP_TYPE_d__HelloType:
		soap_serialize_d__HelloType(soap, (const struct d__HelloType *)ptr);
		break;
	case SOAP_TYPE__wsa__FaultTo:
		soap_serialize__wsa__FaultTo(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa__ReplyTo:
		soap_serialize__wsa__ReplyTo(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa__From:
		soap_serialize__wsa__From(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa__RelatesTo:
		soap_serialize__wsa__RelatesTo(soap, (const struct wsa__Relationship *)ptr);
		break;
	case SOAP_TYPE__wsa__EndpointReference:
		soap_serialize__wsa__EndpointReference(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE_wsa__Relationship:
		soap_serialize_wsa__Relationship(soap, (const struct wsa__Relationship *)ptr);
		break;
	case SOAP_TYPE_wsa__ServiceNameType:
		soap_serialize_wsa__ServiceNameType(soap, (const struct wsa__ServiceNameType *)ptr);
		break;
	case SOAP_TYPE_wsa__ReferenceParametersType:
		soap_serialize_wsa__ReferenceParametersType(soap, (const struct wsa__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE_wsa__ReferencePropertiesType:
		soap_serialize_wsa__ReferencePropertiesType(soap, (const struct wsa__ReferencePropertiesType *)ptr);
		break;
	case SOAP_TYPE_wsa__EndpointReferenceType:
		soap_serialize_wsa__EndpointReferenceType(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
		//case SOAP_TYPE_PointerTod__ByeType:
		//	soap_serialize_PointerTod__ByeType(soap, (struct d__ByeType *const*)ptr);
		//	break;
	case SOAP_TYPE_PointerTod__ResolveType:
		soap_serialize_PointerTod__ResolveType(soap, (struct d__ResolveType *const*)ptr);
		break;
		//case SOAP_TYPE_PointerTod__HelloType:
		//	soap_serialize_PointerTod__HelloType(soap, (struct d__HelloType *const*)ptr);
		//	break;
	case SOAP_TYPE_PointerTod__ProbeMatchesType:
		soap_serialize_PointerTod__ProbeMatchesType(soap, (struct d__ProbeMatchesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTod__ProbeType:
		soap_serialize_PointerTod__ProbeType(soap, (struct d__ProbeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTod__SigType:
		soap_serialize_PointerTod__SigType(soap, (struct d__SigType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTod__ResolveMatchType:
		soap_serialize_PointerTod__ResolveMatchType(soap, (struct d__ResolveMatchType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTod__ProbeMatchType:
		soap_serialize_PointerTod__ProbeMatchType(soap, (struct d__ProbeMatchType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedInt:
		soap_serialize_PointerTounsignedInt(soap, (unsigned int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTod__ScopesType:
		soap_serialize_PointerTod__ScopesType(soap, (struct d__ScopesType *const*)ptr);
		break;
	case SOAP_TYPE_d__FaultCodeOpenType:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_d__UriListType:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_d__QNameListType:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_d__OpenRelationshipType:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_xsd__IDREFS:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa__FaultTo:
		soap_serialize_PointerTo_wsa__FaultTo(soap, (struct wsa__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa__ReplyTo:
		soap_serialize_PointerTo_wsa__ReplyTo(soap, (struct wsa__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa__From:
		soap_serialize_PointerTo_wsa__From(soap, (struct wsa__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa__RelatesTo:
		soap_serialize_PointerTo_wsa__RelatesTo(soap, (struct wsa__Relationship *const*)ptr);
		break;
	case SOAP_TYPE__wsa__Action:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__wsa__To:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__wsa__MessageID:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_PointerTowsa__ServiceNameType:
		soap_serialize_PointerTowsa__ServiceNameType(soap, (struct wsa__ServiceNameType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_QName:
		soap_serialize_PointerTo_QName(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa__ReferenceParametersType:
		soap_serialize_PointerTowsa__ReferenceParametersType(soap, (struct wsa__ReferenceParametersType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa__ReferencePropertiesType:
		soap_serialize_PointerTowsa__ReferencePropertiesType(soap, (struct wsa__ReferencePropertiesType *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	
	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	
	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{	
	unsigned int *p;
	p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_d__FaultCodeType(struct soap *soap, enum d__FaultCodeType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_d__FaultCodeType
	*a = SOAP_DEFAULT_d__FaultCodeType;
#else
	*a = (enum d__FaultCodeType)0;
#endif
}

static const struct soap_code_map soap_codes_d__FaultCodeType[] =
{	
	{ (long)d__FaultCodeType__d__MatchingRuleNotSupported, "d:MatchingRuleNotSupported" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_d__FaultCodeType2s(struct soap *soap, enum d__FaultCodeType n)
{	
	const char *s = soap_code_str(soap_codes_d__FaultCodeType, (long)n);
	if (s != NULL)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_d__FaultCodeType(struct soap *soap, const char *tag, int id, const enum d__FaultCodeType *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_d__FaultCodeType), type) || soap_send(soap, soap_d__FaultCodeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2d__FaultCodeType(struct soap *soap, const char *s, enum d__FaultCodeType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (s == NULL)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1);
	map = soap_code(soap_codes_d__FaultCodeType, t);
	if (map != NULL)
	{
		*a = (enum d__FaultCodeType)map->code;
	}
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
			return soap->error = SOAP_TYPE;
		*a = (enum d__FaultCodeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum d__FaultCodeType * SOAP_FMAC4 soap_in_d__FaultCodeType(struct soap *soap, const char *tag, enum d__FaultCodeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	return NULL;
	a = (enum d__FaultCodeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_d__FaultCodeType, sizeof(enum d__FaultCodeType), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	if (soap->body && !*soap->href)
	{	
		if (!a || soap_s2d__FaultCodeType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (enum d__FaultCodeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_d__FaultCodeType, 0, sizeof(enum d__FaultCodeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_d__FaultCodeType(struct soap *soap, const enum d__FaultCodeType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_d__FaultCodeType);
	if (soap_out_d__FaultCodeType(soap, tag?tag:"d:FaultCodeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum d__FaultCodeType * SOAP_FMAC4 soap_get_d__FaultCodeType(struct soap *soap, enum d__FaultCodeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_d__FaultCodeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_d__RelationshipType(struct soap *soap, enum d__RelationshipType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_d__RelationshipType
	*a = SOAP_DEFAULT_d__RelationshipType;
#else
	*a = (enum d__RelationshipType)0;
#endif
}

static const struct soap_code_map soap_codes_d__RelationshipType[] =
{	
	{ (long)d__RelationshipType__d__Suppression, "d:Suppression" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_d__RelationshipType2s(struct soap *soap, enum d__RelationshipType n)
{	
	const char *s = soap_code_str(soap_codes_d__RelationshipType, (long)n);
	if (s != NULL)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_d__RelationshipType(struct soap *soap, const char *tag, int id, const enum d__RelationshipType *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_d__RelationshipType), type) || soap_send(soap, soap_d__RelationshipType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2d__RelationshipType(struct soap *soap, const char *s, enum d__RelationshipType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (s == NULL)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1);
	map = soap_code(soap_codes_d__RelationshipType, t);
	if (map != NULL)
	{
		*a = (enum d__RelationshipType)map->code;
	}
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
			return soap->error = SOAP_TYPE;
		*a = (enum d__RelationshipType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum d__RelationshipType * SOAP_FMAC4 soap_in_d__RelationshipType(struct soap *soap, const char *tag, enum d__RelationshipType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	return NULL;
	a = (enum d__RelationshipType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_d__RelationshipType, sizeof(enum d__RelationshipType), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	if (soap->body && !*soap->href)
	{	
		if (!a || soap_s2d__RelationshipType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (enum d__RelationshipType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_d__RelationshipType, 0, sizeof(enum d__RelationshipType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_d__RelationshipType(struct soap *soap, const enum d__RelationshipType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_d__RelationshipType);
	if (soap_out_d__RelationshipType(soap, tag?tag:"d:RelationshipType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum d__RelationshipType * SOAP_FMAC4 soap_get_d__RelationshipType(struct soap *soap, enum d__RelationshipType *p, const char *tag, const char *type)
{
	if ((p = soap_in_d__RelationshipType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__FaultSubcodeValues(struct soap *soap, enum wsa__FaultSubcodeValues *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsa__FaultSubcodeValues
	*a = SOAP_DEFAULT_wsa__FaultSubcodeValues;
#else
	*a = (enum wsa__FaultSubcodeValues)0;
#endif
}

static const struct soap_code_map soap_codes_wsa__FaultSubcodeValues[] =
{	
	{ (long)wsa__InvalidMessageInformationHeader, "wsa:InvalidMessageInformationHeader" },
	{ (long)wsa__MessageInformationHeaderRequired, "wsa:MessageInformationHeaderRequired" },
	{ (long)wsa__DestinationUnreachable, "wsa:DestinationUnreachable" },
	{ (long)wsa__ActionNotSupported, "wsa:ActionNotSupported" },
	{ (long)wsa__EndpointUnavailable, "wsa:EndpointUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa__FaultSubcodeValues2s(struct soap *soap, enum wsa__FaultSubcodeValues n)
{	
	const char *s = soap_code_str(soap_codes_wsa__FaultSubcodeValues, (long)n);
	if (s != NULL)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__FaultSubcodeValues(struct soap *soap, const char *tag, int id, const enum wsa__FaultSubcodeValues *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__FaultSubcodeValues), type) || soap_send(soap, soap_wsa__FaultSubcodeValues2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa__FaultSubcodeValues(struct soap *soap, const char *s, enum wsa__FaultSubcodeValues *a)
{
	const struct soap_code_map *map;
	char *t;
	if (s == NULL)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1);
	map = soap_code(soap_codes_wsa__FaultSubcodeValues, t);
	if (map)
		*a = (enum wsa__FaultSubcodeValues)map->code;
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsa__FaultSubcodeValues)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa__FaultSubcodeValues * SOAP_FMAC4 soap_in_wsa__FaultSubcodeValues(struct soap *soap, const char *tag, enum wsa__FaultSubcodeValues *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	return NULL;
	a = (enum wsa__FaultSubcodeValues *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__FaultSubcodeValues, sizeof(enum wsa__FaultSubcodeValues), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	if (soap->body && !*soap->href)
	{	
		if (!a || soap_s2wsa__FaultSubcodeValues(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (enum wsa__FaultSubcodeValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__FaultSubcodeValues, 0, sizeof(enum wsa__FaultSubcodeValues), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__FaultSubcodeValues(struct soap *soap, const enum wsa__FaultSubcodeValues *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__FaultSubcodeValues);
	if (soap_out_wsa__FaultSubcodeValues(soap, tag?tag:"wsa:FaultSubcodeValues", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa__FaultSubcodeValues * SOAP_FMAC4 soap_get_wsa__FaultSubcodeValues(struct soap *soap, enum wsa__FaultSubcodeValues *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__FaultSubcodeValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__RelationshipTypeValues(struct soap *soap, enum wsa__RelationshipTypeValues *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsa__RelationshipTypeValues
	*a = SOAP_DEFAULT_wsa__RelationshipTypeValues;
#else
	*a = (enum wsa__RelationshipTypeValues)0;
#endif
}

static const struct soap_code_map soap_codes_wsa__RelationshipTypeValues[] =
{	
	{ (long)wsa__Reply, "wsa:Reply" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa__RelationshipTypeValues2s(struct soap *soap, enum wsa__RelationshipTypeValues n)
{	
	const char *s = soap_code_str(soap_codes_wsa__RelationshipTypeValues, (long)n);
	if (s != NULL)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__RelationshipTypeValues(struct soap *soap, const char *tag, int id, const enum wsa__RelationshipTypeValues *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__RelationshipTypeValues), type) || soap_send(soap, soap_wsa__RelationshipTypeValues2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa__RelationshipTypeValues(struct soap *soap, const char *s, enum wsa__RelationshipTypeValues *a)
{
	const struct soap_code_map *map;
	char *t;
	if (s == NULL)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1);
	map = soap_code(soap_codes_wsa__RelationshipTypeValues, t);
	if (map)
		*a = (enum wsa__RelationshipTypeValues)map->code;
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsa__RelationshipTypeValues)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa__RelationshipTypeValues * SOAP_FMAC4 soap_in_wsa__RelationshipTypeValues(struct soap *soap, const char *tag, enum wsa__RelationshipTypeValues *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa__RelationshipTypeValues *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__RelationshipTypeValues, sizeof(enum wsa__RelationshipTypeValues), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	if (soap->body && !*soap->href)
	{	
		if (!a || soap_s2wsa__RelationshipTypeValues(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (enum wsa__RelationshipTypeValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__RelationshipTypeValues, 0, sizeof(enum wsa__RelationshipTypeValues), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__RelationshipTypeValues(struct soap *soap, const enum wsa__RelationshipTypeValues *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__RelationshipTypeValues);
	if (soap_out_wsa__RelationshipTypeValues(soap, tag?tag:"wsa:RelationshipTypeValues", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa__RelationshipTypeValues * SOAP_FMAC4 soap_get_wsa__RelationshipTypeValues(struct soap *soap, enum wsa__RelationshipTypeValues *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__RelationshipTypeValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	
					soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	
					soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	
					soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	
					soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	
					soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	
					soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	
					soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	
					soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	
					soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	
					soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	
					soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	
					soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
#endif

#ifndef WITH_NOGLOBAL
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	
					soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	
					soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_d__AppSequenceType(struct soap *soap, struct d__AppSequenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->InstanceId);
	soap_default_string(soap, &a->SequenceId);
	soap_default_unsignedInt(soap, &a->MessageNumber);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_d__AppSequenceType(struct soap *soap, const struct d__AppSequenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_d__AppSequenceType(struct soap *soap, const char *tag, int id, const struct d__AppSequenceType *a, const char *type)
{
	soap_set_attr(soap, "InstanceId", soap_unsignedInt2s(soap, a->InstanceId), 1);
	if (a->SequenceId)
		soap_set_attr(soap, "SequenceId", a->SequenceId, 1);
	soap_set_attr(soap, "MessageNumber", soap_unsignedInt2s(soap, a->MessageNumber), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_d__AppSequenceType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct d__AppSequenceType * SOAP_FMAC4 soap_in_d__AppSequenceType(struct soap *soap, const char *tag, struct d__AppSequenceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct d__AppSequenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_d__AppSequenceType, sizeof(struct d__AppSequenceType), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_d__AppSequenceType(soap, a);
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "InstanceId", 1), &a->InstanceId))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SequenceId", 0), &a->SequenceId, 0, -1))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "MessageNumber", 1), &a->MessageNumber))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct d__AppSequenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_d__AppSequenceType, 0, sizeof(struct d__AppSequenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_d__AppSequenceType(struct soap *soap, const struct d__AppSequenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_d__AppSequenceType);
	if (soap_out_d__AppSequenceType(soap, tag?tag:"d:AppSequenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__AppSequenceType * SOAP_FMAC4 soap_get_d__AppSequenceType(struct soap *soap, struct d__AppSequenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_d__AppSequenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_d__SigType(struct soap *soap, struct d__SigType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_string(soap, &a->Scheme);
	soap_default_string(soap, &a->KeyId);
	soap_default_xsd__IDREFS(soap, &a->Refs);
	soap_default_string(soap, &a->Sig);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_d__SigType(struct soap *soap, const struct d__SigType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_d__SigType(struct soap *soap, const char *tag, int id, const struct d__SigType *a, const char *type)
{
	if (a->Scheme)
		soap_set_attr(soap, "Scheme", a->Scheme, 1);
	if (a->KeyId)
		soap_set_attr(soap, "KeyId", a->KeyId, 1);
	if (a->Refs)
		soap_set_attr(soap, "Refs", a->Refs, 1);
	if (a->Sig)
		soap_set_attr(soap, "Sig", a->Sig, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_d__SigType), type))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct d__SigType * SOAP_FMAC4 soap_in_d__SigType(struct soap *soap, const char *tag, struct d__SigType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct d__SigType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_d__SigType, sizeof(struct d__SigType), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_d__SigType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Scheme", 1), &a->Scheme, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "KeyId", 0), &a->KeyId, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Refs", 1), &a->Refs, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Sig", 1), &a->Sig, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct d__SigType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_d__SigType, 0, sizeof(struct d__SigType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_d__SigType(struct soap *soap, const struct d__SigType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_d__SigType);
	if (soap_out_d__SigType(soap, tag?tag:"d:SigType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__SigType * SOAP_FMAC4 soap_get_d__SigType(struct soap *soap, struct d__SigType *p, const char *tag, const char *type)
{
	if ((p = soap_in_d__SigType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_d__SecurityType(struct soap *soap, struct d__SecurityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Sig = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_d__SecurityType(struct soap *soap, const struct d__SecurityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTod__SigType(soap, &a->Sig);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_d__SecurityType(struct soap *soap, const char *tag, int id, const struct d__SecurityType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_d__SecurityType), type))
		return soap->error;
	if (soap_out_PointerTod__SigType(soap, "d:Sig", -1, &a->Sig, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct d__SecurityType * SOAP_FMAC4 soap_in_d__SecurityType(struct soap *soap, const char *tag, struct d__SecurityType *a, const char *type)
{
	size_t soap_flag_Sig = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct d__SecurityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_d__SecurityType, sizeof(struct d__SecurityType), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_d__SecurityType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Sig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTod__SigType(soap, "d:Sig", &a->Sig, "d:SigType"))
				{	
					soap_flag_Sig--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct d__SecurityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_d__SecurityType, 0, sizeof(struct d__SecurityType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_d__SecurityType(struct soap *soap, const struct d__SecurityType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_d__SecurityType);
	if (soap_out_d__SecurityType(soap, tag?tag:"d:SecurityType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__SecurityType * SOAP_FMAC4 soap_get_d__SecurityType(struct soap *soap, struct d__SecurityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_d__SecurityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


//security in soap header
SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Created);
	soap_default_string(soap, &a->Expires);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Created);
	soap_serialize_string(soap, &a->Expires);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsu__Timestamp(struct soap *soap, const char *tag, int id, const struct _wsu__Timestamp *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsu__Timestamp), type))
		return soap->error;
	if (soap_out_string(soap, "wsu:Created", -1, &a->Created, ""))
		return soap->error;
	if (soap_out_string(soap, "wsu:Expires", -1, &a->Expires, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_in__wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp *a, const char *type)
{
	size_t soap_flag_Created = 1;
	size_t soap_flag_Expires = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsu__Timestamp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsu__Timestamp(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			if (soap_in_string(soap, "wsu:Created", &a->Created, "xsd:string"))
			{	soap_flag_Created--;
		continue;
		}
		if (soap_flag_Expires && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			if (soap_in_string(soap, "wsu:Expires", &a->Expires, "xsd:string"))
			{	soap_flag_Expires--;
		continue;
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsu__Timestamp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsu__Timestamp, 0, sizeof(struct _wsu__Timestamp), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsu__Timestamp);
	if (soap_out__wsu__Timestamp(soap, tag?tag:"wsu:Timestamp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_get__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsu__Timestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsu__Timestamp))
		soap_serialize__wsu__Timestamp(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, int id, struct _wsu__Timestamp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsu__Timestamp);
	if (id < 0)
		return soap->error;
	return soap_out__wsu__Timestamp(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_in_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsu__Timestamp **)soap_malloc(soap, sizeof(struct _wsu__Timestamp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in__wsu__Timestamp(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct _wsu__Timestamp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsu__Timestamp);
	if (soap_out_PointerTo_wsu__Timestamp(soap, tag?tag:"wsu:Timestamp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_get_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsu__Timestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Password(struct soap *soap, struct _wsse__Password *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Password(struct soap *soap, const struct _wsse__Password *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Password(struct soap *soap, const char *tag, int id, const struct _wsse__Password *a, const char *type)
{
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_in__wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__Password *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__Password(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, 0, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Password(struct soap *soap, const struct _wsse__Password *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Password);
	if (soap_out__wsse__Password(soap, tag?tag:"wsse:Password", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_get__wsse__Password(struct soap *soap, struct _wsse__Password *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Password(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Password))
		soap_serialize__wsse__Password(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Password(struct soap *soap, const char *tag, int id, struct _wsse__Password *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Password);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Password(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_in_PointerTo_wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Password **)soap_malloc(soap, sizeof(struct _wsse__Password *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in__wsse__Password(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct _wsse__Password **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Password);
	if (soap_out_PointerTo_wsse__Password(soap, tag?tag:"wsse:Password", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_get_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Password(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Username);
	a->Password = NULL;
	soap_default_string(soap, &a->Nonce);
	soap_default_string(soap, &a->wsu__Created);
	soap_default_string(soap, &a->wsu__Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Username);
	soap_serialize_PointerTo_wsse__Password(soap, &a->Password);
	soap_serialize_string(soap, &a->Nonce);
	soap_serialize_string(soap, &a->wsu__Created);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__UsernameToken(struct soap *soap, const char *tag, int id, const struct _wsse__UsernameToken *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__UsernameToken), type))
		return soap->error;
	if (soap_out_string(soap, "wsse:Username", -1, &a->Username, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__Password(soap, "wsse:Password", -1, &a->Password, ""))
		return soap->error;
	if (soap_out_string(soap, "wsse:Nonce", -1, &a->Nonce, ""))
		return soap->error;
	if (soap_out_string(soap, "wsu:Created", -1, &a->wsu__Created, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_in__wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken *a, const char *type)
{
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_Nonce = 1;
	size_t soap_flag_wsu__Created = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__UsernameToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__UsernameToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			if (soap_in_string(soap, "wsse:Username", &a->Username, "xsd:string"))
			{	soap_flag_Username--;
		continue;
		}
		if (soap_flag_Password && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_wsse__Password(soap, "wsse:Password", &a->Password, ""))
			{	soap_flag_Password--;
		continue;
		}
		if (soap_flag_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			if (soap_in_string(soap, "wsse:Nonce", &a->Nonce, "xsd:string"))
			{	soap_flag_Nonce--;
		continue;
		}
		if (soap_flag_wsu__Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			if (soap_in_string(soap, "wsu:Created", &a->wsu__Created, "xsd:string"))
			{	soap_flag_wsu__Created--;
		continue;
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__UsernameToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__UsernameToken, 0, sizeof(struct _wsse__UsernameToken), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__UsernameToken);
	if (soap_out__wsse__UsernameToken(soap, tag?tag:"wsse:UsernameToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_get__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__UsernameToken))
		soap_serialize__wsse__UsernameToken(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, int id, struct _wsse__UsernameToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__UsernameToken);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__UsernameToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__UsernameToken **)soap_malloc(soap, sizeof(struct _wsse__UsernameToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in__wsse__UsernameToken(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct _wsse__UsernameToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__UsernameToken);
	if (soap_out_PointerTo_wsse__UsernameToken(soap, tag?tag:"wsse:UsernameToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, const struct _wsse__BinarySecurityToken *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", a->EncodingType, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_in__wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__BinarySecurityToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__BinarySecurityToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 0), &a->EncodingType, 0, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__BinarySecurityToken);
	if (soap_out__wsse__BinarySecurityToken(soap, tag?tag:"wsse:BinarySecurityToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_get__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__BinarySecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__BinarySecurityToken))
		soap_serialize__wsse__BinarySecurityToken(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, struct _wsse__BinarySecurityToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__BinarySecurityToken);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__BinarySecurityToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__BinarySecurityToken **)soap_malloc(soap, sizeof(struct _wsse__BinarySecurityToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in__wsse__BinarySecurityToken(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct _wsse__BinarySecurityToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__BinarySecurityToken);
	if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, tag?tag:"wsse:BinarySecurityToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__BinarySecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->KeySize = NULL;
	soap_default_string(soap, &a->OAEPparams);
	soap_default_string(soap, &a->Algorithm);
	a->__mixed = NULL;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionMethodType(struct soap *soap, const struct xenc__EncryptionMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->KeySize);
	soap_serialize_string(soap, &a->OAEPparams);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionMethodType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionMethodType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "xenc:KeySize", -1, &a->KeySize, ""))
		return soap->error;
	if (soap_out_string(soap, "xenc:OAEPparams", -1, &a->OAEPparams, ""))
		return soap->error;
	soap_outliteral(soap, "-mixed", &a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType * SOAP_FMAC4 soap_in_xenc__EncryptionMethodType(struct soap *soap, const char *tag, struct xenc__EncryptionMethodType *a, const char *type)
{
	size_t soap_flag_KeySize = 1;
	size_t soap_flag_OAEPparams = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptionMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionMethodType, sizeof(struct xenc__EncryptionMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_KeySize && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerToint(soap, "xenc:KeySize", &a->KeySize, "xsd:int"))
			{	soap_flag_KeySize--;
		continue;
		}
		if (soap_flag_OAEPparams && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			if (soap_in_string(soap, "xenc:OAEPparams", &a->OAEPparams, "xsd:string"))
			{	soap_flag_OAEPparams--;
		continue;
		}
		if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			if (soap_inliteral(soap, "-mixed", &a->__mixed))
			{	soap_flag___mixed--;
		continue;
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionMethodType, 0, sizeof(struct xenc__EncryptionMethodType), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionMethodType(struct soap *soap, const struct xenc__EncryptionMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptionMethodType);
	if (soap_out_xenc__EncryptionMethodType(soap, tag?tag:"xenc:EncryptionMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType * SOAP_FMAC4 soap_get_xenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptionMethodType))
		soap_serialize_xenc__EncryptionMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptionMethodType(struct soap *soap, const char *tag, int id, struct xenc__EncryptionMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptionMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__EncryptionMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptionMethodType(struct soap *soap, const char *tag, struct xenc__EncryptionMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptionMethodType **)soap_malloc(soap, sizeof(struct xenc__EncryptionMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_xenc__EncryptionMethodType(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct xenc__EncryptionMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptionMethodType, sizeof(struct xenc__EncryptionMethodType), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__EncryptionMethodType);
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, tag?tag:"xenc:EncryptionMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptionMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Modulus);
	soap_default_string(soap, &a->Exponent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Modulus);
	soap_serialize_string(soap, &a->Exponent);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__RSAKeyValueType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RSAKeyValueType), type))
		return soap->error;
	if (a->Modulus)
	{	if (soap_out_string(soap, "ds:Modulus", -1, &a->Modulus, ""))
	return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Modulus"))
		return soap->error;
	if (a->Exponent)
	{	if (soap_out_string(soap, "ds:Exponent", -1, &a->Exponent, ""))
	return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Exponent"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_in_ds__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType *a, const char *type)
{
	size_t soap_flag_Modulus = 1;
	size_t soap_flag_Exponent = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__RSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RSAKeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_Modulus && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			if (soap_in_string(soap, "ds:Modulus", &a->Modulus, "xsd:string"))
			{	soap_flag_Modulus--;
		continue;
		}
		if (soap_flag_Exponent && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			if (soap_in_string(soap, "ds:Exponent", &a->Exponent, "xsd:string"))
			{	soap_flag_Exponent--;
		continue;
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__RSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RSAKeyValueType, 0, sizeof(struct ds__RSAKeyValueType), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Modulus > 0 || soap_flag_Exponent > 0))
	{	soap->error = SOAP_OCCURS;
	return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__RSAKeyValueType);
	if (soap_out_ds__RSAKeyValueType(soap, tag?tag:"ds:RSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_get_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->G);
	soap_default_string(soap, &a->Y);
	soap_default_string(soap, &a->J);
	soap_default_string(soap, &a->P);
	soap_default_string(soap, &a->Q);
	soap_default_string(soap, &a->Seed);
	soap_default_string(soap, &a->PgenCounter);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->G);
	soap_serialize_string(soap, &a->Y);
	soap_serialize_string(soap, &a->J);
	soap_serialize_string(soap, &a->P);
	soap_serialize_string(soap, &a->Q);
	soap_serialize_string(soap, &a->Seed);
	soap_serialize_string(soap, &a->PgenCounter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__DSAKeyValueType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DSAKeyValueType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:G", -1, &a->G, ""))
		return soap->error;
	if (a->Y)
	{	if (soap_out_string(soap, "ds:Y", -1, &a->Y, ""))
	return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Y"))
		return soap->error;
	if (soap_out_string(soap, "ds:J", -1, &a->J, ""))
		return soap->error;
	if (a->P)
	{	if (soap_out_string(soap, "ds:P", -1, &a->P, ""))
	return soap->error;
	}
	else if (soap_element_nil(soap, "ds:P"))
		return soap->error;
	if (a->Q)
	{	if (soap_out_string(soap, "ds:Q", -1, &a->Q, ""))
	return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Q"))
		return soap->error;
	if (a->Seed)
	{	if (soap_out_string(soap, "ds:Seed", -1, &a->Seed, ""))
	return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Seed"))
		return soap->error;
	if (a->PgenCounter)
	{	if (soap_out_string(soap, "ds:PgenCounter", -1, &a->PgenCounter, ""))
	return soap->error;
	}
	else if (soap_element_nil(soap, "ds:PgenCounter"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_in_ds__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType *a, const char *type)
{
	size_t soap_flag_G = 1;
	size_t soap_flag_Y = 1;
	size_t soap_flag_J = 1;
	size_t soap_flag_P = 1;
	size_t soap_flag_Q = 1;
	size_t soap_flag_Seed = 1;
	size_t soap_flag_PgenCounter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__DSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DSAKeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_G && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			if (soap_in_string(soap, "ds:G", &a->G, "xsd:string"))
			{	soap_flag_G--;
		continue;
		}
		if (soap_flag_Y && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			if (soap_in_string(soap, "ds:Y", &a->Y, "xsd:string"))
			{	soap_flag_Y--;
		continue;
		}
		if (soap_flag_J && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			if (soap_in_string(soap, "ds:J", &a->J, "xsd:string"))
			{	soap_flag_J--;
		continue;
		}
		if (soap_flag_P && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			if (soap_in_string(soap, "ds:P", &a->P, "xsd:string"))
			{	soap_flag_P--;
		continue;
		}
		if (soap_flag_Q && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			if (soap_in_string(soap, "ds:Q", &a->Q, "xsd:string"))
			{	soap_flag_Q--;
		continue;
		}
		if (soap_flag_Seed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			if (soap_in_string(soap, "ds:Seed", &a->Seed, "xsd:string"))
			{	soap_flag_Seed--;
		continue;
		}
		if (soap_flag_PgenCounter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			if (soap_in_string(soap, "ds:PgenCounter", &a->PgenCounter, "xsd:string"))
			{	soap_flag_PgenCounter--;
		continue;
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__DSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DSAKeyValueType, 0, sizeof(struct ds__DSAKeyValueType), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Y > 0 || soap_flag_P > 0 || soap_flag_Q > 0 || soap_flag_Seed > 0 || soap_flag_PgenCounter > 0))
	{	soap->error = SOAP_OCCURS;
	return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__DSAKeyValueType);
	if (soap_out_ds__DSAKeyValueType(soap, tag?tag:"ds:DSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_get_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__RSAKeyValueType))
		soap_serialize_ds__RSAKeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__RSAKeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RSAKeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__RSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__RSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__RSAKeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_ds__RSAKeyValueType(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct ds__RSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__RSAKeyValueType);
	if (soap_out_PointerTods__RSAKeyValueType(soap, tag?tag:"ds:RSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__DSAKeyValueType))
		soap_serialize_ds__DSAKeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__DSAKeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DSAKeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__DSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__DSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__DSAKeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_ds__DSAKeyValueType(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct ds__DSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__DSAKeyValueType);
	if (soap_out_PointerTods__DSAKeyValueType(soap, tag?tag:"ds:DSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DSAKeyValue = NULL;
	a->RSAKeyValue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__DSAKeyValueType(soap, &a->DSAKeyValue);
	soap_serialize_PointerTods__RSAKeyValueType(soap, &a->RSAKeyValue);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyValueType(struct soap *soap, const char *tag, int id, const struct ds__KeyValueType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyValueType), type))
		return soap->error;
	if (a->DSAKeyValue)
	{	if (soap_out_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", -1, &a->DSAKeyValue, ""))
	return soap->error;
	}
	else if (soap_element_nil(soap, "ds:DSAKeyValue"))
		return soap->error;
	if (a->RSAKeyValue)
	{	if (soap_out_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", -1, &a->RSAKeyValue, ""))
	return soap->error;
	}
	else if (soap_element_nil(soap, "ds:RSAKeyValue"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_in_ds__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType *a, const char *type)
{
	size_t soap_flag_DSAKeyValue = 1;
	size_t soap_flag_RSAKeyValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__KeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_DSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", &a->DSAKeyValue, "ds:DSAKeyValueType"))
			{	soap_flag_DSAKeyValue--;
		continue;
		}
		if (soap_flag_RSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", &a->RSAKeyValue, "ds:RSAKeyValueType"))
			{	soap_flag_RSAKeyValue--;
		continue;
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__KeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyValueType, 0, sizeof(struct ds__KeyValueType), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DSAKeyValue > 0 || soap_flag_RSAKeyValue > 0))
	{	soap->error = SOAP_OCCURS;
	return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__KeyValueType);
	if (soap_out_ds__KeyValueType(soap, tag?tag:"ds:KeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_get_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyValueType))
		soap_serialize_ds__KeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__KeyValueType(struct soap *soap, const char *tag, int id, struct ds__KeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__KeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_in_PointerTods__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyValueType **)soap_malloc(soap, sizeof(struct ds__KeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_ds__KeyValueType(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct ds__KeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__KeyValueType);
	if (soap_out_PointerTods__KeyValueType(soap, tag?tag:"ds:KeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_get_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->PrefixList);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, const struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (a->PrefixList)
		soap_set_attr(soap, "PrefixList", a->PrefixList, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__c14n__InclusiveNamespaces), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_in__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _c14n__InclusiveNamespaces *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__c14n__InclusiveNamespaces(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "PrefixList", 0), &a->PrefixList, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _c14n__InclusiveNamespaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__c14n__InclusiveNamespaces, 0, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__c14n__InclusiveNamespaces);
	if (soap_out__c14n__InclusiveNamespaces(soap, tag?tag:"c14n:InclusiveNamespaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_get__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__c14n__InclusiveNamespaces))
		soap_serialize__c14n__InclusiveNamespaces(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, struct _c14n__InclusiveNamespaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__c14n__InclusiveNamespaces);
	if (id < 0)
		return soap->error;
	return soap_out__c14n__InclusiveNamespaces(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_in_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _c14n__InclusiveNamespaces **)soap_malloc(soap, sizeof(struct _c14n__InclusiveNamespaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in__c14n__InclusiveNamespaces(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct _c14n__InclusiveNamespaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces);
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, tag?tag:"c14n:InclusiveNamespaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_get_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformType(struct soap *soap, struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->c14n__InclusiveNamespaces = NULL;
	a->__any = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformType(struct soap *soap, const struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformType(struct soap *soap, const char *tag, int id, const struct ds__TransformType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_in_ds__TransformType(struct soap *soap, const char *tag, struct ds__TransformType *a, const char *type)
{
	size_t soap_flag_c14n__InclusiveNamespaces = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__TransformType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 0), &a->Algorithm, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
			{	soap_flag_c14n__InclusiveNamespaces--;
		continue;
		}
		if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			if (soap_inliteral(soap, "-any", &a->__any))
			{	soap_flag___any--;
		continue;
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformType, 0, sizeof(struct ds__TransformType), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformType(struct soap *soap, const struct ds__TransformType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__TransformType);
	if (soap_out_ds__TransformType(soap, tag?tag:"ds:TransformType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_get_ds__TransformType(struct soap *soap, struct ds__TransformType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformsType(struct soap *soap, struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTransform = 0;
	a->Transform = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Transform)
	{	int i;
	for (i = 0; i < a->__sizeTransform; i++)
	{
		soap_embedded(soap, a->Transform + i, SOAP_TYPE_ds__TransformType);
		soap_serialize_ds__TransformType(soap, a->Transform + i);
	}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformsType(struct soap *soap, const char *tag, int id, const struct ds__TransformsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformsType), type))
		return soap->error;
	if (a->Transform)
	{	int i;
	for (i = 0; i < a->__sizeTransform; i++)
		if (soap_out_ds__TransformType(soap, "ds:Transform", -1, a->Transform + i, ""))
			return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_in_ds__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType *a, const char *type)
{
	struct soap_blist *soap_blist_Transform = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__TransformsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Transform", 1, NULL))
		{	if (a->Transform == NULL)
		{	if (soap_blist_Transform == NULL)
		soap_blist_Transform = soap_new_block(soap);
		a->Transform = (struct ds__TransformType *)soap_push_block(soap, soap_blist_Transform, sizeof(struct ds__TransformType));
		if (a->Transform == NULL)
			return NULL;
		soap_default_ds__TransformType(soap, a->Transform);
		}
		soap_revert(soap);
		if (soap_in_ds__TransformType(soap, "ds:Transform", a->Transform, "ds:TransformType"))
		{	a->__sizeTransform++;
		a->Transform = NULL;
		continue;
		}
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (a->Transform)
			soap_pop_block(soap, soap_blist_Transform);
		if (a->__sizeTransform)
			a->Transform = (struct ds__TransformType *)soap_save_block(soap, soap_blist_Transform, NULL, 1);
		else
		{	a->Transform = NULL;
		if (soap_blist_Transform)
			soap_end_block(soap, soap_blist_Transform);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformsType, 0, sizeof(struct ds__TransformsType), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__TransformsType);
	if (soap_out_ds__TransformsType(soap, tag?tag:"ds:TransformsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_get_ds__TransformsType(struct soap *soap, struct ds__TransformsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__TransformsType))
		soap_serialize_ds__TransformsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__TransformsType(struct soap *soap, const char *tag, int id, struct ds__TransformsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__TransformsType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__TransformsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_in_PointerTods__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__TransformsType **)soap_malloc(soap, sizeof(struct ds__TransformsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_ds__TransformsType(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct ds__TransformsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__TransformsType);
	if (soap_out_PointerTods__TransformsType(soap, tag?tag:"ds:TransformsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_get_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RetrievalMethodType(struct soap *soap, const char *tag, int id, const struct ds__RetrievalMethodType *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RetrievalMethodType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_in_ds__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__RetrievalMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RetrievalMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
			{	soap_flag_Transforms--;
		continue;
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__RetrievalMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RetrievalMethodType, 0, sizeof(struct ds__RetrievalMethodType), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__RetrievalMethodType);
	if (soap_out_ds__RetrievalMethodType(soap, tag?tag:"ds:RetrievalMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_get_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__RetrievalMethodType))
		soap_serialize_ds__RetrievalMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, int id, struct ds__RetrievalMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RetrievalMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__RetrievalMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_in_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__RetrievalMethodType **)soap_malloc(soap, sizeof(struct ds__RetrievalMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_ds__RetrievalMethodType(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct ds__RetrievalMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__RetrievalMethodType);
	if (soap_out_PointerTods__RetrievalMethodType(soap, tag?tag:"ds:RetrievalMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_get_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->X509IssuerName);
	soap_default_int(soap, &a->X509SerialNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->X509IssuerName);
	soap_embedded(soap, &a->X509SerialNumber, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509IssuerSerialType(struct soap *soap, const char *tag, int id, const struct ds__X509IssuerSerialType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509IssuerSerialType), type))
		return soap->error;
	if (a->X509IssuerName)
	{	if (soap_out_string(soap, "ds:X509IssuerName", -1, &a->X509IssuerName, ""))
	return soap->error;
	}
	else if (soap_element_nil(soap, "ds:X509IssuerName"))
		return soap->error;
	if (soap_out_int(soap, "ds:X509SerialNumber", -1, &a->X509SerialNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_in_ds__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType *a, const char *type)
{
	size_t soap_flag_X509IssuerName = 1;
	size_t soap_flag_X509SerialNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__X509IssuerSerialType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509IssuerSerialType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_X509IssuerName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			if (soap_in_string(soap, "ds:X509IssuerName", &a->X509IssuerName, "xsd:string"))
			{	soap_flag_X509IssuerName--;
		continue;
		}
		if (soap_flag_X509SerialNumber && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_int(soap, "ds:X509SerialNumber", &a->X509SerialNumber, "xsd:int"))
			{	soap_flag_X509SerialNumber--;
		continue;
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__X509IssuerSerialType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509IssuerSerialType, 0, sizeof(struct ds__X509IssuerSerialType), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_X509IssuerName > 0 || soap_flag_X509SerialNumber > 0))
	{	soap->error = SOAP_OCCURS;
	return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__X509IssuerSerialType);
	if (soap_out_ds__X509IssuerSerialType(soap, tag?tag:"ds:X509IssuerSerialType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_get_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509IssuerSerialType))
		soap_serialize_ds__X509IssuerSerialType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, int id, struct ds__X509IssuerSerialType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509IssuerSerialType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__X509IssuerSerialType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_in_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__X509IssuerSerialType **)soap_malloc(soap, sizeof(struct ds__X509IssuerSerialType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_ds__X509IssuerSerialType(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct ds__X509IssuerSerialType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__X509IssuerSerialType);
	if (soap_out_PointerTods__X509IssuerSerialType(soap, tag?tag:"ds:X509IssuerSerialType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_get_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509DataType(struct soap *soap, struct ds__X509DataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->X509IssuerSerial = NULL;
	soap_default_string(soap, &a->X509SKI);
	soap_default_string(soap, &a->X509SubjectName);
	soap_default_string(soap, &a->X509Certificate);
	soap_default_string(soap, &a->X509CRL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__X509IssuerSerialType(soap, &a->X509IssuerSerial);
	soap_serialize_string(soap, &a->X509SKI);
	soap_serialize_string(soap, &a->X509SubjectName);
	soap_serialize_string(soap, &a->X509Certificate);
	soap_serialize_string(soap, &a->X509CRL);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509DataType(struct soap *soap, const char *tag, int id, const struct ds__X509DataType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509DataType), type))
		return soap->error;
	if (a->X509IssuerSerial)
	{	if (soap_out_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", -1, &a->X509IssuerSerial, ""))
	return soap->error;
	}
	else if (soap_element_nil(soap, "ds:X509IssuerSerial"))
		return soap->error;
	if (a->X509SKI)
	{	if (soap_out_string(soap, "ds:X509SKI", -1, &a->X509SKI, ""))
	return soap->error;
	}
	else if (soap_element_nil(soap, "ds:X509SKI"))
		return soap->error;
	if (a->X509SubjectName)
	{	if (soap_out_string(soap, "ds:X509SubjectName", -1, &a->X509SubjectName, ""))
	return soap->error;
	}
	else if (soap_element_nil(soap, "ds:X509SubjectName"))
		return soap->error;
	if (a->X509Certificate)
	{	if (soap_out_string(soap, "ds:X509Certificate", -1, &a->X509Certificate, ""))
	return soap->error;
	}
	else if (soap_element_nil(soap, "ds:X509Certificate"))
		return soap->error;
	if (a->X509CRL)
	{	if (soap_out_string(soap, "ds:X509CRL", -1, &a->X509CRL, ""))
	return soap->error;
	}
	else if (soap_element_nil(soap, "ds:X509CRL"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_in_ds__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType *a, const char *type)
{
	size_t soap_flag_X509IssuerSerial = 1;
	size_t soap_flag_X509SKI = 1;
	size_t soap_flag_X509SubjectName = 1;
	size_t soap_flag_X509Certificate = 1;
	size_t soap_flag_X509CRL = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__X509DataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509DataType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_X509IssuerSerial && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", &a->X509IssuerSerial, "ds:X509IssuerSerialType"))
			{	soap_flag_X509IssuerSerial--;
		continue;
		}
		if (soap_flag_X509SKI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			if (soap_in_string(soap, "ds:X509SKI", &a->X509SKI, "xsd:string"))
			{	soap_flag_X509SKI--;
		continue;
		}
		if (soap_flag_X509SubjectName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			if (soap_in_string(soap, "ds:X509SubjectName", &a->X509SubjectName, "xsd:string"))
			{	soap_flag_X509SubjectName--;
		continue;
		}
		if (soap_flag_X509Certificate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			if (soap_in_string(soap, "ds:X509Certificate", &a->X509Certificate, "xsd:string"))
			{	soap_flag_X509Certificate--;
		continue;
		}
		if (soap_flag_X509CRL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			if (soap_in_string(soap, "ds:X509CRL", &a->X509CRL, "xsd:string"))
			{	soap_flag_X509CRL--;
		continue;
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__X509DataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509DataType, 0, sizeof(struct ds__X509DataType), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_X509IssuerSerial > 0 || soap_flag_X509SKI > 0 || soap_flag_X509SubjectName > 0 || soap_flag_X509Certificate > 0 || soap_flag_X509CRL > 0))
	{	soap->error = SOAP_OCCURS;
	return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__X509DataType);
	if (soap_out_ds__X509DataType(soap, tag?tag:"ds:X509DataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_get_ds__X509DataType(struct soap *soap, struct ds__X509DataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509DataType))
		soap_serialize_ds__X509DataType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__X509DataType(struct soap *soap, const char *tag, int id, struct ds__X509DataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509DataType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__X509DataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_in_PointerTods__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__X509DataType **)soap_malloc(soap, sizeof(struct ds__X509DataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_ds__X509DataType(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct ds__X509DataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__X509DataType);
	if (soap_out_PointerTods__X509DataType(soap, tag?tag:"ds:X509DataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_get_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Reference(struct soap *soap, struct _wsse__Reference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Reference(struct soap *soap, const char *tag, int id, const struct _wsse__Reference *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Reference), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_in__wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Reference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Reference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Reference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Reference, 0, sizeof(struct _wsse__Reference), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Reference);
	if (soap_out__wsse__Reference(soap, tag?tag:"wsse:Reference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_get__wsse__Reference(struct soap *soap, struct _wsse__Reference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Reference))
		soap_serialize__wsse__Reference(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Reference(struct soap *soap, const char *tag, int id, struct _wsse__Reference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Reference);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Reference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_in_PointerTo_wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Reference **)soap_malloc(soap, sizeof(struct _wsse__Reference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in__wsse__Reference(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct _wsse__Reference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Reference);
	if (soap_out_PointerTo_wsse__Reference(soap, tag?tag:"wsse:Reference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_get_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, const struct _wsse__KeyIdentifier *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", a->EncodingType, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_in__wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__KeyIdentifier *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__KeyIdentifier(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 0), &a->EncodingType, 0, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__KeyIdentifier);
	if (soap_out__wsse__KeyIdentifier(soap, tag?tag:"wsse:KeyIdentifier", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_get__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__KeyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__KeyIdentifier))
		soap_serialize__wsse__KeyIdentifier(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, struct _wsse__KeyIdentifier *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__KeyIdentifier);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__KeyIdentifier(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_in_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__KeyIdentifier **)soap_malloc(soap, sizeof(struct _wsse__KeyIdentifier *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in__wsse__KeyIdentifier(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct _wsse__KeyIdentifier **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__KeyIdentifier);
	if (soap_out_PointerTo_wsse__KeyIdentifier(soap, tag?tag:"wsse:KeyIdentifier", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_get_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__KeyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Embedded(struct soap *soap, const char *tag, int id, const struct _wsse__Embedded *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Embedded), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_in__wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Embedded *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Embedded(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Embedded *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Embedded, 0, sizeof(struct _wsse__Embedded), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Embedded);
	if (soap_out__wsse__Embedded(soap, tag?tag:"wsse:Embedded", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_get__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Embedded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Embedded))
		soap_serialize__wsse__Embedded(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, int id, struct _wsse__Embedded *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Embedded);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Embedded(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_in_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Embedded **)soap_malloc(soap, sizeof(struct _wsse__Embedded *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in__wsse__Embedded(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct _wsse__Embedded **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Embedded);
	if (soap_out_PointerTo_wsse__Embedded(soap, tag?tag:"wsse:Embedded", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_get_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Embedded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Reference = NULL;
	a->KeyIdentifier = NULL;
	a->Embedded = NULL;
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Usage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsse__Reference(soap, &a->Reference);
	soap_serialize_PointerTo_wsse__KeyIdentifier(soap, &a->KeyIdentifier);
	soap_serialize_PointerTo_wsse__Embedded(soap, &a->Embedded);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, const struct _wsse__SecurityTokenReference *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->Usage)
		soap_set_attr(soap, "Usage", a->Usage, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__SecurityTokenReference), type))
		return soap->error;
	if (soap_out_PointerTo_wsse__Reference(soap, "wsse:Reference", -1, &a->Reference, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", -1, &a->KeyIdentifier, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__Embedded(soap, "wsse:Embedded", -1, &a->Embedded, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_in__wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference *a, const char *type)
{
	size_t soap_flag_Reference = 1;
	size_t soap_flag_KeyIdentifier = 1;
	size_t soap_flag_Embedded = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__SecurityTokenReference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__SecurityTokenReference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Usage", 0), &a->Usage, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_Reference && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_wsse__Reference(soap, "wsse:Reference", &a->Reference, ""))
			{	soap_flag_Reference--;
		continue;
		}
		if (soap_flag_KeyIdentifier && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", &a->KeyIdentifier, ""))
			{	soap_flag_KeyIdentifier--;
		continue;
		}
		if (soap_flag_Embedded && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_wsse__Embedded(soap, "wsse:Embedded", &a->Embedded, ""))
			{	soap_flag_Embedded--;
		continue;
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__SecurityTokenReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__SecurityTokenReference, 0, sizeof(struct _wsse__SecurityTokenReference), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__SecurityTokenReference);
	if (soap_out__wsse__SecurityTokenReference(soap, tag?tag:"wsse:SecurityTokenReference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_get__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__SecurityTokenReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__SecurityTokenReference))
		soap_serialize__wsse__SecurityTokenReference(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, struct _wsse__SecurityTokenReference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__SecurityTokenReference);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__SecurityTokenReference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_in_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__SecurityTokenReference **)soap_malloc(soap, sizeof(struct _wsse__SecurityTokenReference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in__wsse__SecurityTokenReference(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct _wsse__SecurityTokenReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__SecurityTokenReference);
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, tag?tag:"wsse:SecurityTokenReference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_get_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__SecurityTokenReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->KeyName);
	a->KeyValue = NULL;
	a->RetrievalMethod = NULL;
	a->X509Data = NULL;
	a->wsse__SecurityTokenReference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->KeyName);
	soap_serialize_PointerTods__KeyValueType(soap, &a->KeyValue);
	soap_serialize_PointerTods__RetrievalMethodType(soap, &a->RetrievalMethod);
	soap_serialize_PointerTods__X509DataType(soap, &a->X509Data);
	soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, &a->wsse__SecurityTokenReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyInfoType(struct soap *soap, const char *tag, int id, const struct ds__KeyInfoType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyInfoType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:KeyName", -1, &a->KeyName, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyValueType(soap, "ds:KeyValue", -1, &a->KeyValue, ""))
		return soap->error;
	if (soap_out_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", -1, &a->RetrievalMethod, ""))
		return soap->error;
	if (soap_out_PointerTods__X509DataType(soap, "ds:X509Data", -1, &a->X509Data, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", -1, &a->wsse__SecurityTokenReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_in_ds__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType *a, const char *type)
{
	size_t soap_flag_KeyName = 1;
	size_t soap_flag_KeyValue = 1;
	size_t soap_flag_RetrievalMethod = 1;
	size_t soap_flag_X509Data = 1;
	size_t soap_flag_wsse__SecurityTokenReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__KeyInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_KeyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			if (soap_in_string(soap, "ds:KeyName", &a->KeyName, "xsd:string"))
			{	soap_flag_KeyName--;
		continue;
		}
		if (soap_flag_KeyValue && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTods__KeyValueType(soap, "ds:KeyValue", &a->KeyValue, "ds:KeyValueType"))
			{	soap_flag_KeyValue--;
		continue;
		}
		if (soap_flag_RetrievalMethod && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", &a->RetrievalMethod, "ds:RetrievalMethodType"))
			{	soap_flag_RetrievalMethod--;
		continue;
		}
		if (soap_flag_X509Data && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTods__X509DataType(soap, "ds:X509Data", &a->X509Data, "ds:X509DataType"))
			{	soap_flag_X509Data--;
		continue;
		}
		if (soap_flag_wsse__SecurityTokenReference && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", &a->wsse__SecurityTokenReference, ""))
			{	soap_flag_wsse__SecurityTokenReference--;
		continue;
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyInfoType, 0, sizeof(struct ds__KeyInfoType), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__KeyInfoType);
	if (soap_out_ds__KeyInfoType(soap, tag?tag:"ds:KeyInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_get_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ds__KeyInfo))
		soap_serialize__ds__KeyInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ds__KeyInfo(struct soap *soap, const char *tag, int id, struct ds__KeyInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ds__KeyInfo);
	if (id < 0)
		return soap->error;
	return soap_out__ds__KeyInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_in_PointerTo_ds__KeyInfo(struct soap *soap, const char *tag, struct ds__KeyInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyInfoType **)soap_malloc(soap, sizeof(struct ds__KeyInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in__ds__KeyInfo(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ds__KeyInfo, sizeof(struct ds__KeyInfoType), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ds__KeyInfo);
	if (soap_out_PointerTo_ds__KeyInfo(soap, tag?tag:"ds:KeyInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_get_PointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ds__KeyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__TransformsType(struct soap *soap, struct xenc__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__ds__Transform(soap, &a->ds__Transform);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__TransformsType(struct soap *soap, const struct xenc__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__ds__Transform(soap, &a->ds__Transform);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__TransformsType(struct soap *soap, const char *tag, int id, const struct xenc__TransformsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__TransformsType), type))
		return soap->error;
	if (soap_out__ds__Transform(soap, "ds:Transform", -1, &a->ds__Transform, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__TransformsType * SOAP_FMAC4 soap_in_xenc__TransformsType(struct soap *soap, const char *tag, struct xenc__TransformsType *a, const char *type)
{
	size_t soap_flag_ds__Transform = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__TransformsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__TransformsType, sizeof(struct xenc__TransformsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__TransformsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_ds__Transform && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in__ds__Transform(soap, "ds:Transform", &a->ds__Transform, ""))
			{	soap_flag_ds__Transform--;
		continue;
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__TransformsType, 0, sizeof(struct xenc__TransformsType), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ds__Transform > 0))
	{	soap->error = SOAP_OCCURS;
	return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__TransformsType(struct soap *soap, const struct xenc__TransformsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__TransformsType);
	if (soap_out_xenc__TransformsType(soap, tag?tag:"xenc:TransformsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__TransformsType * SOAP_FMAC4 soap_get_xenc__TransformsType(struct soap *soap, struct xenc__TransformsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__TransformsType(struct soap *soap, struct xenc__TransformsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__TransformsType))
		soap_serialize_xenc__TransformsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__TransformsType(struct soap *soap, const char *tag, int id, struct xenc__TransformsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__TransformsType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__TransformsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__TransformsType ** SOAP_FMAC4 soap_in_PointerToxenc__TransformsType(struct soap *soap, const char *tag, struct xenc__TransformsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__TransformsType **)soap_malloc(soap, sizeof(struct xenc__TransformsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_xenc__TransformsType(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct xenc__TransformsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__TransformsType, sizeof(struct xenc__TransformsType), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__TransformsType(struct soap *soap, struct xenc__TransformsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__TransformsType);
	if (soap_out_PointerToxenc__TransformsType(soap, tag?tag:"xenc:TransformsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__TransformsType ** SOAP_FMAC4 soap_get_PointerToxenc__TransformsType(struct soap *soap, struct xenc__TransformsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	soap_default_string(soap, &a->URI);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__CipherReferenceType(struct soap *soap, const struct xenc__CipherReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxenc__TransformsType(soap, &a->Transforms);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__CipherReferenceType(struct soap *soap, const char *tag, int id, const struct xenc__CipherReferenceType *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__CipherReferenceType), type))
		return soap->error;
	if (soap_out_PointerToxenc__TransformsType(soap, "xenc:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__CipherReferenceType * SOAP_FMAC4 soap_in_xenc__CipherReferenceType(struct soap *soap, const char *tag, struct xenc__CipherReferenceType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__CipherReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__CipherReferenceType, sizeof(struct xenc__CipherReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__CipherReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 1), &a->URI, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerToxenc__TransformsType(soap, "xenc:Transforms", &a->Transforms, "xenc:TransformsType"))
			{	soap_flag_Transforms--;
		continue;
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__CipherReferenceType, 0, sizeof(struct xenc__CipherReferenceType), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__CipherReferenceType(struct soap *soap, const struct xenc__CipherReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__CipherReferenceType);
	if (soap_out_xenc__CipherReferenceType(soap, tag?tag:"xenc:CipherReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherReferenceType * SOAP_FMAC4 soap_get_xenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__CipherReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__CipherReferenceType))
		soap_serialize_xenc__CipherReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__CipherReferenceType(struct soap *soap, const char *tag, int id, struct xenc__CipherReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__CipherReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__CipherReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__CipherReferenceType ** SOAP_FMAC4 soap_in_PointerToxenc__CipherReferenceType(struct soap *soap, const char *tag, struct xenc__CipherReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__CipherReferenceType **)soap_malloc(soap, sizeof(struct xenc__CipherReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_xenc__CipherReferenceType(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct xenc__CipherReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__CipherReferenceType, sizeof(struct xenc__CipherReferenceType), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__CipherReferenceType);
	if (soap_out_PointerToxenc__CipherReferenceType(soap, tag?tag:"xenc:CipherReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherReferenceType ** SOAP_FMAC4 soap_get_PointerToxenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__CipherReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->CipherValue);
	a->CipherReference = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__CipherDataType(struct soap *soap, const struct xenc__CipherDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->CipherValue);
	soap_serialize_PointerToxenc__CipherReferenceType(soap, &a->CipherReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__CipherDataType(struct soap *soap, const char *tag, int id, const struct xenc__CipherDataType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__CipherDataType), type))
		return soap->error;
	if (soap_out_string(soap, "xenc:CipherValue", -1, &a->CipherValue, ""))
		return soap->error;
	if (soap_out_PointerToxenc__CipherReferenceType(soap, "xenc:CipherReference", -1, &a->CipherReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__CipherDataType * SOAP_FMAC4 soap_in_xenc__CipherDataType(struct soap *soap, const char *tag, struct xenc__CipherDataType *a, const char *type)
{
	size_t soap_flag_CipherValue = 1;
	size_t soap_flag_CipherReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__CipherDataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__CipherDataType, sizeof(struct xenc__CipherDataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__CipherDataType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_CipherValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			if (soap_in_string(soap, "xenc:CipherValue", &a->CipherValue, "xsd:string"))
			{	soap_flag_CipherValue--;
		continue;
		}
		if (soap_flag_CipherReference && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerToxenc__CipherReferenceType(soap, "xenc:CipherReference", &a->CipherReference, "xenc:CipherReferenceType"))
			{	soap_flag_CipherReference--;
		continue;
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__CipherDataType, 0, sizeof(struct xenc__CipherDataType), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__CipherDataType(struct soap *soap, const struct xenc__CipherDataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__CipherDataType);
	if (soap_out_xenc__CipherDataType(soap, tag?tag:"xenc:CipherDataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherDataType * SOAP_FMAC4 soap_get_xenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__CipherDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__CipherDataType))
		soap_serialize_xenc__CipherDataType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__CipherDataType(struct soap *soap, const char *tag, int id, struct xenc__CipherDataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__CipherDataType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__CipherDataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__CipherDataType ** SOAP_FMAC4 soap_in_PointerToxenc__CipherDataType(struct soap *soap, const char *tag, struct xenc__CipherDataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__CipherDataType **)soap_malloc(soap, sizeof(struct xenc__CipherDataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_xenc__CipherDataType(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct xenc__CipherDataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__CipherDataType, sizeof(struct xenc__CipherDataType), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__CipherDataType);
	if (soap_out_PointerToxenc__CipherDataType(soap, tag?tag:"xenc:CipherDataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherDataType ** SOAP_FMAC4 soap_get_PointerToxenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__CipherDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Target);
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionPropertyType(struct soap *soap, const struct xenc__EncryptionPropertyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionPropertyType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionPropertyType *a, const char *type)
{
	if (a->Target)
		soap_set_attr(soap, "Target", a->Target, 1);
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionPropertyType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType * SOAP_FMAC4 soap_in_xenc__EncryptionPropertyType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptionPropertyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionPropertyType, sizeof(struct xenc__EncryptionPropertyType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionPropertyType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Target", 0), &a->Target, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionPropertyType, 0, sizeof(struct xenc__EncryptionPropertyType), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionPropertyType(struct soap *soap, const struct xenc__EncryptionPropertyType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptionPropertyType);
	if (soap_out_xenc__EncryptionPropertyType(soap, tag?tag:"xenc:EncryptionPropertyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType * SOAP_FMAC4 soap_get_xenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionPropertyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeEncryptionProperty = 0;
	a->EncryptionProperty = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionPropertiesType(struct soap *soap, const struct xenc__EncryptionPropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->EncryptionProperty)
	{	int i;
	for (i = 0; i < a->__sizeEncryptionProperty; i++)
	{
		soap_embedded(soap, a->EncryptionProperty + i, SOAP_TYPE_xenc__EncryptionPropertyType);
		soap_serialize_xenc__EncryptionPropertyType(soap, a->EncryptionProperty + i);
	}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionPropertiesType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionPropertiesType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionPropertiesType), type))
		return soap->error;
	if (a->EncryptionProperty)
	{	int i;
	for (i = 0; i < a->__sizeEncryptionProperty; i++)
		if (soap_out_xenc__EncryptionPropertyType(soap, "xenc:EncryptionProperty", -1, a->EncryptionProperty + i, ""))
			return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType * SOAP_FMAC4 soap_in_xenc__EncryptionPropertiesType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertiesType *a, const char *type)
{
	struct soap_blist *soap_blist_EncryptionProperty = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptionPropertiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionPropertiesType, sizeof(struct xenc__EncryptionPropertiesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionPropertiesType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "xenc:EncryptionProperty", 1, NULL))
		{	if (a->EncryptionProperty == NULL)
		{	if (soap_blist_EncryptionProperty == NULL)
		soap_blist_EncryptionProperty = soap_new_block(soap);
		a->EncryptionProperty = (struct xenc__EncryptionPropertyType *)soap_push_block(soap, soap_blist_EncryptionProperty, sizeof(struct xenc__EncryptionPropertyType));
		if (a->EncryptionProperty == NULL)
			return NULL;
		soap_default_xenc__EncryptionPropertyType(soap, a->EncryptionProperty);
		}
		soap_revert(soap);
		if (soap_in_xenc__EncryptionPropertyType(soap, "xenc:EncryptionProperty", a->EncryptionProperty, "xenc:EncryptionPropertyType"))
		{	a->__sizeEncryptionProperty++;
		a->EncryptionProperty = NULL;
		continue;
		}
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (a->EncryptionProperty)
			soap_pop_block(soap, soap_blist_EncryptionProperty);
		if (a->__sizeEncryptionProperty)
			a->EncryptionProperty = (struct xenc__EncryptionPropertyType *)soap_save_block(soap, soap_blist_EncryptionProperty, NULL, 1);
		else
		{	a->EncryptionProperty = NULL;
		if (soap_blist_EncryptionProperty)
			soap_end_block(soap, soap_blist_EncryptionProperty);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionPropertiesType, 0, sizeof(struct xenc__EncryptionPropertiesType), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeEncryptionProperty < 1))
	{	soap->error = SOAP_OCCURS;
	return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionPropertiesType(struct soap *soap, const struct xenc__EncryptionPropertiesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptionPropertiesType);
	if (soap_out_xenc__EncryptionPropertiesType(soap, tag?tag:"xenc:EncryptionPropertiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType * SOAP_FMAC4 soap_get_xenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptionPropertiesType))
		soap_serialize_xenc__EncryptionPropertiesType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptionPropertiesType(struct soap *soap, const char *tag, int id, struct xenc__EncryptionPropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptionPropertiesType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__EncryptionPropertiesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptionPropertiesType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertiesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptionPropertiesType **)soap_malloc(soap, sizeof(struct xenc__EncryptionPropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_xenc__EncryptionPropertiesType(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptionPropertiesType, sizeof(struct xenc__EncryptionPropertiesType), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__EncryptionPropertiesType);
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, tag?tag:"xenc:EncryptionPropertiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptionPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->URI);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__ReferenceType(struct soap *soap, const struct xenc__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__ReferenceType(struct soap *soap, const char *tag, int id, const struct xenc__ReferenceType *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__ReferenceType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__ReferenceType * SOAP_FMAC4 soap_in_xenc__ReferenceType(struct soap *soap, const char *tag, struct xenc__ReferenceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__ReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__ReferenceType, sizeof(struct xenc__ReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__ReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 1), &a->URI, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__ReferenceType, 0, sizeof(struct xenc__ReferenceType), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__ReferenceType(struct soap *soap, const struct xenc__ReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__ReferenceType);
	if (soap_out_xenc__ReferenceType(soap, tag?tag:"xenc:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__ReferenceType * SOAP_FMAC4 soap_get_xenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__ReferenceType))
		soap_serialize_xenc__ReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__ReferenceType(struct soap *soap, const char *tag, int id, struct xenc__ReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__ReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__ReferenceType ** SOAP_FMAC4 soap_in_PointerToxenc__ReferenceType(struct soap *soap, const char *tag, struct xenc__ReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__ReferenceType **)soap_malloc(soap, sizeof(struct xenc__ReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_xenc__ReferenceType(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct xenc__ReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__ReferenceType, sizeof(struct xenc__ReferenceType), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__ReferenceType);
	if (soap_out_PointerToxenc__ReferenceType(soap, tag?tag:"xenc:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__ReferenceType ** SOAP_FMAC4 soap_get_PointerToxenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DataReference = NULL;
	a->KeyReference = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___xenc__union_ReferenceList(struct soap *soap, const struct __xenc__union_ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxenc__ReferenceType(soap, &a->DataReference);
	soap_serialize_PointerToxenc__ReferenceType(soap, &a->KeyReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___xenc__union_ReferenceList(struct soap *soap, const char *tag, int id, const struct __xenc__union_ReferenceList *a, const char *type)
{
	if (soap_out_PointerToxenc__ReferenceType(soap, "xenc:DataReference", -1, &a->DataReference, ""))
		return soap->error;
	if (soap_out_PointerToxenc__ReferenceType(soap, "xenc:KeyReference", -1, &a->KeyReference, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __xenc__union_ReferenceList * SOAP_FMAC4 soap_in___xenc__union_ReferenceList(struct soap *soap, const char *tag, struct __xenc__union_ReferenceList *a, const char *type)
{
	size_t soap_flag_DataReference = 1;
	size_t soap_flag_KeyReference = 1;
	short soap_flag;
	a = (struct __xenc__union_ReferenceList *)soap_id_enter(soap, "", a, SOAP_TYPE___xenc__union_ReferenceList, sizeof(struct __xenc__union_ReferenceList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___xenc__union_ReferenceList(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	soap->error = SOAP_TAG_MISMATCH;
	if (soap_flag_DataReference && soap->error == SOAP_TAG_MISMATCH)
		if (soap_in_PointerToxenc__ReferenceType(soap, "xenc:DataReference", &a->DataReference, "xenc:ReferenceType"))
		{	soap_flag_DataReference--;
	continue;
	}
	if (soap_flag_KeyReference && soap->error == SOAP_TAG_MISMATCH)
		if (soap_in_PointerToxenc__ReferenceType(soap, "xenc:KeyReference", &a->KeyReference, "xenc:ReferenceType"))
		{	soap_flag_KeyReference--;
	continue;
	}
	if (soap->error == SOAP_TAG_MISMATCH)
		if (soap_flag)
		{	soap->error = SOAP_OK;
	break;
	}
	if (soap_flag && soap->error == SOAP_NO_TAG)
		break;
	if (soap->error)
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___xenc__union_ReferenceList(struct soap *soap, const struct __xenc__union_ReferenceList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___xenc__union_ReferenceList(soap, tag?tag:"-xenc:union-ReferenceList", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __xenc__union_ReferenceList * SOAP_FMAC4 soap_get___xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *p, const char *tag, const char *type)
{
	if ((p = soap_in___xenc__union_ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_default__xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_ReferenceList = 0;
	a->__union_ReferenceList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__xenc__ReferenceList(struct soap *soap, const struct _xenc__ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__union_ReferenceList)
	{	
		int i;
		for (i = 0; i < a->__size_ReferenceList; i++)
		{
			soap_serialize___xenc__union_ReferenceList(soap, a->__union_ReferenceList + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__xenc__ReferenceList(struct soap *soap, const char *tag, int id, const struct _xenc__ReferenceList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__xenc__ReferenceList), type))
		return soap->error;
	if (a->__union_ReferenceList)
	{	int i;
	for (i = 0; i < a->__size_ReferenceList; i++)
		if (soap_out___xenc__union_ReferenceList(soap, "-union-ReferenceList", -1, a->__union_ReferenceList + i, ""))
			return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _xenc__ReferenceList * SOAP_FMAC4 soap_in__xenc__ReferenceList(struct soap *soap, const char *tag, struct _xenc__ReferenceList *a, const char *type)
{
	struct soap_blist *soap_blist___union_ReferenceList = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _xenc__ReferenceList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__xenc__ReferenceList, sizeof(struct _xenc__ReferenceList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__xenc__ReferenceList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
		{	if (a->__union_ReferenceList == NULL)
		{	if (soap_blist___union_ReferenceList == NULL)
		soap_blist___union_ReferenceList = soap_new_block(soap);
		a->__union_ReferenceList = (struct __xenc__union_ReferenceList *)soap_push_block(soap, soap_blist___union_ReferenceList, sizeof(struct __xenc__union_ReferenceList));
		if (a->__union_ReferenceList == NULL)
			return NULL;
		soap_default___xenc__union_ReferenceList(soap, a->__union_ReferenceList);
		}
		if (soap_in___xenc__union_ReferenceList(soap, "-union-ReferenceList", a->__union_ReferenceList, "-xenc:union-ReferenceList"))
		{	a->__size_ReferenceList++;
		a->__union_ReferenceList = NULL;
		continue;
		}
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (a->__union_ReferenceList)
			soap_pop_block(soap, soap_blist___union_ReferenceList);
		if (a->__size_ReferenceList)
			a->__union_ReferenceList = (struct __xenc__union_ReferenceList *)soap_save_block(soap, soap_blist___union_ReferenceList, NULL, 1);
		else
		{	a->__union_ReferenceList = NULL;
		if (soap_blist___union_ReferenceList)
			soap_end_block(soap, soap_blist___union_ReferenceList);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _xenc__ReferenceList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__xenc__ReferenceList, 0, sizeof(struct _xenc__ReferenceList), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__size_ReferenceList < 1))
	{	soap->error = SOAP_OCCURS;
	return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xenc__ReferenceList(struct soap *soap, const struct _xenc__ReferenceList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__xenc__ReferenceList);
	if (soap_out__xenc__ReferenceList(soap, tag?tag:"xenc:ReferenceList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xenc__ReferenceList * SOAP_FMAC4 soap_get__xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *p, const char *tag, const char *type)
{
	if ((p = soap_in__xenc__ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__xenc__ReferenceList))
		soap_serialize__xenc__ReferenceList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_xenc__ReferenceList(struct soap *soap, const char *tag, int id, struct _xenc__ReferenceList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__xenc__ReferenceList);
	if (id < 0)
		return soap->error;
	return soap_out__xenc__ReferenceList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _xenc__ReferenceList ** SOAP_FMAC4 soap_in_PointerTo_xenc__ReferenceList(struct soap *soap, const char *tag, struct _xenc__ReferenceList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _xenc__ReferenceList **)soap_malloc(soap, sizeof(struct _xenc__ReferenceList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in__xenc__ReferenceList(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct _xenc__ReferenceList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__xenc__ReferenceList, sizeof(struct _xenc__ReferenceList), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_xenc__ReferenceList);
	if (soap_out_PointerTo_xenc__ReferenceList(soap, tag?tag:"xenc:ReferenceList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xenc__ReferenceList ** SOAP_FMAC4 soap_get_PointerTo_xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_xenc__ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EncryptionMethod = NULL;
	a->ds__KeyInfo = NULL;
	a->CipherData = NULL;
	a->EncryptionProperties = NULL;
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->MimeType);
	soap_default_string(soap, &a->Encoding);
	a->ReferenceList = NULL;
	soap_default_string(soap, &a->CarriedKeyName);
	soap_default_string(soap, &a->Recipient);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedKeyType(struct soap *soap, const struct xenc__EncryptedKeyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
	soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
	soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
	soap_serialize_PointerTo_xenc__ReferenceList(soap, &a->ReferenceList);
	soap_serialize_string(soap, &a->CarriedKeyName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedKeyType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedKeyType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	if (a->MimeType)
		soap_set_attr(soap, "MimeType", a->MimeType, 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", a->Encoding, 1);
	if (a->Recipient)
		soap_set_attr(soap, "Recipient", a->Recipient, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedKeyType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	if (a->CipherData)
	{	if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
	return soap->error;
	}
	else if (soap_element_nil(soap, "xenc:CipherData"))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
		return soap->error;
	if (soap_out_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", -1, &a->ReferenceList, ""))
		return soap->error;
	if (soap_out_string(soap, "xenc:CarriedKeyName", -1, &a->CarriedKeyName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType * SOAP_FMAC4 soap_in_xenc__EncryptedKeyType(struct soap *soap, const char *tag, struct xenc__EncryptedKeyType *a, const char *type)
{
	size_t soap_flag_EncryptionMethod = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	size_t soap_flag_CipherData = 1;
	size_t soap_flag_EncryptionProperties = 1;
	size_t soap_flag_ReferenceList = 1;
	size_t soap_flag_CarriedKeyName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptedKeyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptedKeyType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 0), &a->MimeType, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 0), &a->Encoding, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Recipient", 0), &a->Recipient, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType"))
			{	soap_flag_EncryptionMethod--;
		continue;
		}
		if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
			{	soap_flag_ds__KeyInfo--;
		continue;
		}
		if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType"))
			{	soap_flag_CipherData--;
		continue;
		}
		if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType"))
			{	soap_flag_EncryptionProperties--;
		continue;
		}
		if (soap_flag_ReferenceList && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", &a->ReferenceList, ""))
			{	soap_flag_ReferenceList--;
		continue;
		}
		if (soap_flag_CarriedKeyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			if (soap_in_string(soap, "xenc:CarriedKeyName", &a->CarriedKeyName, "xsd:string"))
			{	soap_flag_CarriedKeyName--;
		continue;
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptedKeyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedKeyType, 0, sizeof(struct xenc__EncryptedKeyType), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CipherData > 0))
	{	soap->error = SOAP_OCCURS;
	return NULL;
	}
	return a;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedKeyType(struct soap *soap, const struct xenc__EncryptedKeyType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptedKeyType);
	if (soap_out_xenc__EncryptedKeyType(soap, tag?tag:"xenc:EncryptedKeyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType * SOAP_FMAC4 soap_get_xenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptedKeyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptedKeyType))
		soap_serialize_xenc__EncryptedKeyType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptedKeyType(struct soap *soap, const char *tag, int id, struct xenc__EncryptedKeyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptedKeyType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__EncryptedKeyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptedKeyType(struct soap *soap, const char *tag, struct xenc__EncryptedKeyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptedKeyType **)soap_malloc(soap, sizeof(struct xenc__EncryptedKeyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_xenc__EncryptedKeyType(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct xenc__EncryptedKeyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__EncryptedKeyType);
	if (soap_out_PointerToxenc__EncryptedKeyType(soap, tag?tag:"xenc:EncryptedKeyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptedKeyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
	a->c14n__InclusiveNamespaces = NULL;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, const struct ds__CanonicalizationMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__CanonicalizationMethodType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_in_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType *a, const char *type)
{
	size_t soap_flag_c14n__InclusiveNamespaces = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__CanonicalizationMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__CanonicalizationMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
			{	soap_flag_c14n__InclusiveNamespaces--;
		continue;
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__CanonicalizationMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__CanonicalizationMethodType, 0, sizeof(struct ds__CanonicalizationMethodType), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__CanonicalizationMethodType);
	if (soap_out_ds__CanonicalizationMethodType(soap, tag?tag:"ds:CanonicalizationMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_get_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__CanonicalizationMethodType))
		soap_serialize_ds__CanonicalizationMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, struct ds__CanonicalizationMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__CanonicalizationMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__CanonicalizationMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_in_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__CanonicalizationMethodType **)soap_malloc(soap, sizeof(struct ds__CanonicalizationMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_ds__CanonicalizationMethodType(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct ds__CanonicalizationMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__CanonicalizationMethodType);
	if (soap_out_PointerTods__CanonicalizationMethodType(soap, tag?tag:"ds:CanonicalizationMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_get_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->HMACOutputLength = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->HMACOutputLength);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureMethodType(struct soap *soap, const char *tag, int id, const struct ds__SignatureMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureMethodType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ds:HMACOutputLength", -1, &a->HMACOutputLength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_in_ds__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType *a, const char *type)
{
	size_t soap_flag_HMACOutputLength = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignatureMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_HMACOutputLength && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerToint(soap, "ds:HMACOutputLength", &a->HMACOutputLength, "xsd:int"))
			{	soap_flag_HMACOutputLength--;
		continue;
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureMethodType, 0, sizeof(struct ds__SignatureMethodType), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignatureMethodType);
	if (soap_out_ds__SignatureMethodType(soap, tag?tag:"ds:SignatureMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_get_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureMethodType))
		soap_serialize_ds__SignatureMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, int id, struct ds__SignatureMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignatureMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_in_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureMethodType **)soap_malloc(soap, sizeof(struct ds__SignatureMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_ds__SignatureMethodType(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct ds__SignatureMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignatureMethodType);
	if (soap_out_PointerTods__SignatureMethodType(soap, tag?tag:"ds:SignatureMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_get_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DigestMethodType(struct soap *soap, const char *tag, int id, const struct ds__DigestMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DigestMethodType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_in_ds__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__DigestMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DigestMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__DigestMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DigestMethodType, 0, sizeof(struct ds__DigestMethodType), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__DigestMethodType);
	if (soap_out_ds__DigestMethodType(soap, tag?tag:"ds:DigestMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_get_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__DigestMethodType))
		soap_serialize_ds__DigestMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__DigestMethodType(struct soap *soap, const char *tag, int id, struct ds__DigestMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DigestMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__DigestMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_in_PointerTods__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__DigestMethodType **)soap_malloc(soap, sizeof(struct ds__DigestMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_ds__DigestMethodType(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct ds__DigestMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__DigestMethodType);
	if (soap_out_PointerTods__DigestMethodType(soap, tag?tag:"ds:DigestMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_get_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	a->DigestMethod = NULL;
	soap_default_string(soap, &a->DigestValue);
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
	soap_serialize_PointerTods__DigestMethodType(soap, &a->DigestMethod);
	soap_serialize_string(soap, &a->DigestValue);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__ReferenceType(struct soap *soap, const char *tag, int id, const struct ds__ReferenceType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__ReferenceType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	if (a->DigestMethod)
	{	if (soap_out_PointerTods__DigestMethodType(soap, "ds:DigestMethod", -1, &a->DigestMethod, ""))
	return soap->error;
	}
	else if (soap_element_nil(soap, "ds:DigestMethod"))
		return soap->error;
	if (a->DigestValue)
	{	if (soap_out_string(soap, "ds:DigestValue", -1, &a->DigestValue, ""))
	return soap->error;
	}
	else if (soap_element_nil(soap, "ds:DigestValue"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_in_ds__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	size_t soap_flag_DigestMethod = 1;
	size_t soap_flag_DigestValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__ReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__ReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
			{	soap_flag_Transforms--;
		continue;
		}
		if (soap_flag_DigestMethod && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTods__DigestMethodType(soap, "ds:DigestMethod", &a->DigestMethod, "ds:DigestMethodType"))
			{	soap_flag_DigestMethod--;
		continue;
		}
		if (soap_flag_DigestValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			if (soap_in_string(soap, "ds:DigestValue", &a->DigestValue, "xsd:string"))
			{	soap_flag_DigestValue--;
		continue;
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__ReferenceType, 0, sizeof(struct ds__ReferenceType), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DigestMethod > 0 || soap_flag_DigestValue > 0))
	{	soap->error = SOAP_OCCURS;
	return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__ReferenceType);
	if (soap_out_ds__ReferenceType(soap, tag?tag:"ds:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_get_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__ReferenceType))
		soap_serialize_ds__ReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__ReferenceType(struct soap *soap, const char *tag, int id, struct ds__ReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__ReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_in_PointerTods__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__ReferenceType **)soap_malloc(soap, sizeof(struct ds__ReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_ds__ReferenceType(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct ds__ReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__ReferenceType);
	if (soap_out_PointerTods__ReferenceType(soap, tag?tag:"ds:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_get_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CanonicalizationMethod = NULL;
	a->SignatureMethod = NULL;
	a->__sizeReference = 0;
	a->Reference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__CanonicalizationMethodType(soap, &a->CanonicalizationMethod);
	soap_serialize_PointerTods__SignatureMethodType(soap, &a->SignatureMethod);
	if (a->Reference)
	{	
		int i;
		for (i = 0; i < a->__sizeReference; i++)
		{
			soap_serialize_PointerTods__ReferenceType(soap, a->Reference + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignedInfoType(struct soap *soap, const char *tag, int id, const struct ds__SignedInfoType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignedInfoType), type))
		return soap->error;
	if (a->CanonicalizationMethod)
	{	if (soap_out_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", -1, &a->CanonicalizationMethod, ""))
	return soap->error;
	}
	else if (soap_element_nil(soap, "ds:CanonicalizationMethod"))
		return soap->error;
	if (a->SignatureMethod)
	{	if (soap_out_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", -1, &a->SignatureMethod, ""))
	return soap->error;
	}
	else if (soap_element_nil(soap, "ds:SignatureMethod"))
		return soap->error;
	if (a->Reference)
	{	int i;
	for (i = 0; i < a->__sizeReference; i++)
		if (soap_out_PointerTods__ReferenceType(soap, "ds:Reference", -1, a->Reference + i, ""))
			return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_in_ds__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType *a, const char *type)
{
	size_t soap_flag_CanonicalizationMethod = 1;
	size_t soap_flag_SignatureMethod = 1;
	struct soap_blist *soap_blist_Reference = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignedInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignedInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_CanonicalizationMethod && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", &a->CanonicalizationMethod, "ds:CanonicalizationMethodType"))
			{	soap_flag_CanonicalizationMethod--;
		continue;
		}
		if (soap_flag_SignatureMethod && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", &a->SignatureMethod, "ds:SignatureMethodType"))
			{	soap_flag_SignatureMethod--;
		continue;
		}
		if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Reference", 1, NULL))
		{	if (a->Reference == NULL)
		{	if (soap_blist_Reference == NULL)
		soap_blist_Reference = soap_new_block(soap);
		a->Reference = (struct ds__ReferenceType **)soap_push_block(soap, soap_blist_Reference, sizeof(struct ds__ReferenceType *));
		if (a->Reference == NULL)
			return NULL;
		*a->Reference = NULL;
		}
		soap_revert(soap);
		if (soap_in_PointerTods__ReferenceType(soap, "ds:Reference", a->Reference, "ds:ReferenceType"))
		{	a->__sizeReference++;
		a->Reference = NULL;
		continue;
		}
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (a->Reference)
			soap_pop_block(soap, soap_blist_Reference);
		if (a->__sizeReference)
			a->Reference = (struct ds__ReferenceType **)soap_save_block(soap, soap_blist_Reference, NULL, 1);
		else
		{	a->Reference = NULL;
		if (soap_blist_Reference)
			soap_end_block(soap, soap_blist_Reference);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignedInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignedInfoType, 0, sizeof(struct ds__SignedInfoType), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CanonicalizationMethod > 0 || soap_flag_SignatureMethod > 0))
	{	soap->error = SOAP_OCCURS;
	return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignedInfoType);
	if (soap_out_ds__SignedInfoType(soap, tag?tag:"ds:SignedInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_get_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignedInfoType))
		soap_serialize_ds__SignedInfoType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignedInfoType(struct soap *soap, const char *tag, int id, struct ds__SignedInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignedInfoType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignedInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_in_PointerTods__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignedInfoType **)soap_malloc(soap, sizeof(struct ds__SignedInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_ds__SignedInfoType(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct ds__SignedInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignedInfoType);
	if (soap_out_PointerTods__SignedInfoType(soap, tag?tag:"ds:SignedInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_get_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyInfoType))
		soap_serialize_ds__KeyInfoType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__KeyInfoType(struct soap *soap, const char *tag, int id, struct ds__KeyInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyInfoType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__KeyInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_in_PointerTods__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyInfoType **)soap_malloc(soap, sizeof(struct ds__KeyInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_ds__KeyInfoType(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__KeyInfoType);
	if (soap_out_PointerTods__KeyInfoType(soap, tag?tag:"ds:KeyInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_get_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureType(struct soap *soap, struct ds__SignatureType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SignedInfo = NULL;
	soap_default_string(soap, &a->SignatureValue);
	a->KeyInfo = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__SignedInfoType(soap, &a->SignedInfo);
	soap_serialize_string(soap, &a->SignatureValue);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->KeyInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureType(struct soap *soap, const char *tag, int id, const struct ds__SignatureType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureType), type))
		return soap->error;
	if (soap_out_PointerTods__SignedInfoType(soap, "ds:SignedInfo", -1, &a->SignedInfo, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:SignatureValue", -1, &a->SignatureValue, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "ds:KeyInfo", -1, &a->KeyInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_in_ds__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType *a, const char *type)
{
	size_t soap_flag_SignedInfo = 1;
	size_t soap_flag_SignatureValue = 1;
	size_t soap_flag_KeyInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignatureType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_SignedInfo && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTods__SignedInfoType(soap, "ds:SignedInfo", &a->SignedInfo, "ds:SignedInfoType"))
			{	soap_flag_SignedInfo--;
		continue;
		}
		if (soap_flag_SignatureValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			if (soap_in_string(soap, "ds:SignatureValue", &a->SignatureValue, "xsd:string"))
			{	soap_flag_SignatureValue--;
		continue;
		}
		if (soap_flag_KeyInfo && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTods__KeyInfoType(soap, "ds:KeyInfo", &a->KeyInfo, "ds:KeyInfoType"))
			{	soap_flag_KeyInfo--;
		continue;
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureType, 0, sizeof(struct ds__SignatureType), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignatureType);
	if (soap_out_ds__SignatureType(soap, tag?tag:"ds:SignatureType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_get_ds__SignatureType(struct soap *soap, struct ds__SignatureType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureType))
		soap_serialize_ds__SignatureType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignatureType(struct soap *soap, const char *tag, int id, struct ds__SignatureType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignatureType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_in_PointerTods__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureType **)soap_malloc(soap, sizeof(struct ds__SignatureType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_ds__SignatureType(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct ds__SignatureType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignatureType);
	if (soap_out_PointerTods__SignatureType(soap, tag?tag:"ds:SignatureType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_get_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Security(struct soap *soap, struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsu__Timestamp = NULL;
	a->UsernameToken = NULL;
	a->BinarySecurityToken = NULL;
	a->xenc__EncryptedKey = NULL;
	a->xenc__ReferenceList = NULL;
	a->ds__Signature = NULL;
	soap_default_string(soap, &a->SOAP_ENV__actor);
	soap_default_string(soap, &a->SOAP_ENV__role);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Security(struct soap *soap, const struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsu__Timestamp(soap, &a->wsu__Timestamp);
	soap_serialize_PointerTo_wsse__UsernameToken(soap, &a->UsernameToken);
	soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, &a->BinarySecurityToken);
	soap_serialize_PointerToxenc__EncryptedKeyType(soap, &a->xenc__EncryptedKey);
	soap_serialize_PointerTo_xenc__ReferenceList(soap, &a->xenc__ReferenceList);
	soap_serialize_PointerTods__SignatureType(soap, &a->ds__Signature);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Security(struct soap *soap, const char *tag, int id, const struct _wsse__Security *a, const char *type)
{
	if (a->SOAP_ENV__actor)
		soap_set_attr(soap, "SOAP-ENV:actor", a->SOAP_ENV__actor, 1);
	if (a->SOAP_ENV__role)
		soap_set_attr(soap, "SOAP-ENV:role", a->SOAP_ENV__role, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Security), type))
		return soap->error;
	if (soap_out_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", -1, &a->wsu__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", -1, &a->UsernameToken, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", -1, &a->BinarySecurityToken, ""))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", -1, &a->xenc__EncryptedKey, ""))
		return soap->error;
	if (soap_out_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", -1, &a->xenc__ReferenceList, ""))
		return soap->error;
	if (soap_out_PointerTods__SignatureType(soap, "ds:Signature", -1, &a->ds__Signature, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_in__wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security *a, const char *type)
{
	size_t soap_flag_wsu__Timestamp = 1;
	size_t soap_flag_UsernameToken = 1;
	size_t soap_flag_BinarySecurityToken = 1;
	size_t soap_flag_xenc__EncryptedKey = 1;
	size_t soap_flag_xenc__ReferenceList = 1;
	size_t soap_flag_ds__Signature = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Security *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Security(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:actor", 0), &a->SOAP_ENV__actor, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:role", 0), &a->SOAP_ENV__role, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_wsu__Timestamp && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", &a->wsu__Timestamp, ""))
			{	soap_flag_wsu__Timestamp--;
		continue;
		}
		if (soap_flag_UsernameToken && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", &a->UsernameToken, ""))
			{	soap_flag_UsernameToken--;
		continue;
		}
		if (soap_flag_BinarySecurityToken && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", &a->BinarySecurityToken, ""))
			{	soap_flag_BinarySecurityToken--;
		continue;
		}
		if (soap_flag_xenc__EncryptedKey && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", &a->xenc__EncryptedKey, "xenc:EncryptedKeyType"))
			{	soap_flag_xenc__EncryptedKey--;
		continue;
		}
		if (soap_flag_xenc__ReferenceList && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", &a->xenc__ReferenceList, ""))
			{	soap_flag_xenc__ReferenceList--;
		continue;
		}
		if (soap_flag_ds__Signature && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTods__SignatureType(soap, "ds:Signature", &a->ds__Signature, "ds:SignatureType"))
			{	soap_flag_ds__Signature--;
		continue;
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Security *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Security, 0, sizeof(struct _wsse__Security), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Security(struct soap *soap, const struct _wsse__Security *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Security);
	if (soap_out__wsse__Security(soap, tag?tag:"wsse:Security", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_get__wsse__Security(struct soap *soap, struct _wsse__Security *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Security))
		soap_serialize__wsse__Security(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Security(struct soap *soap, const char *tag, int id, struct _wsse__Security *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Security);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Security(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_in_PointerTo_wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Security **)soap_malloc(soap, sizeof(struct _wsse__Security *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in__wsse__Security(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct _wsse__Security **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Security);
	if (soap_out_PointerTo_wsse__Security(soap, tag?tag:"wsse:Security", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_get_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, char **a, const char *type)
{	
	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
	if (soap_out_wsa5__RelationshipTypeOpenEnum(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_wsa5__RelationshipTypeOpenEnum(soap, &a->RelationshipType);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelatesToType(struct soap *soap, const char *tag, int id, const struct wsa5__RelatesToType *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", a->RelationshipType, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_in_wsa5__RelatesToType(struct soap *soap, const char *tag, struct wsa5__RelatesToType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa5__RelatesToType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelatesToType, sizeof(struct wsa5__RelatesToType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa5__RelatesToType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "RelationshipType", 0), &a->RelationshipType, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, "wsa5:RelatesToType"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__RelatesToType);
	if (soap_out_wsa5__RelatesToType(soap, tag?tag:"wsa5:RelatesToType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_get_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelatesToType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__RelatesTo))
		soap_serialize__wsa5__RelatesTo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, int id, struct wsa5__RelatesToType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__RelatesTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__RelatesTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, struct wsa5__RelatesToType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__RelatesToType **)soap_malloc(soap, sizeof(struct wsa5__RelatesToType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in__wsa5__RelatesTo(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct wsa5__RelatesToType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__RelatesTo, sizeof(struct wsa5__RelatesToType), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa5__RelatesTo);
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, tag?tag:"wsa5:RelatesTo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__RelatesTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__From))
		soap_serialize__wsa5__From(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__From(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__From);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__From(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__From(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in__wsa5__From(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__From, sizeof(struct wsa5__EndpointReferenceType), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa5__From);
	if (soap_out_PointerTo_wsa5__From(soap, tag?tag:"wsa5:From", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__From(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__ReplyTo))
		soap_serialize__wsa5__ReplyTo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__ReplyTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__ReplyTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in__wsa5__ReplyTo(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__ReplyTo, sizeof(struct wsa5__EndpointReferenceType), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa5__ReplyTo);
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, tag?tag:"wsa5:ReplyTo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__ReplyTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__FaultTo))
		soap_serialize__wsa5__FaultTo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__FaultTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__FaultTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in__wsa5__FaultTo(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__FaultTo, sizeof(struct wsa5__EndpointReferenceType), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa5__FaultTo);
	if (soap_out_PointerTo_wsa5__FaultTo(soap, tag?tag:"wsa5:FaultTo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__FaultTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa5__ReferenceParametersType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ReferenceParametersType), type))
		return soap->error;
	if (a->__any)
	{	int i;
	for (i = 0; i < a->__size; i++)
		soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__ReferenceParametersType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ReferenceParametersType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
		{	if (a->__any == NULL)
		{	if (soap_blist___any == NULL)
		soap_blist___any = soap_new_block(soap);
		a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
		if (a->__any == NULL)
			return NULL;
		*a->__any = NULL;
		}
		if (soap_inliteral(soap, "-any", a->__any))
		{	a->__size++;
		a->__any = NULL;
		continue;
		}
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
		if (soap_blist___any)
			soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ReferenceParametersType, 0, sizeof(struct wsa5__ReferenceParametersType), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__ReferenceParametersType);
	if (soap_out_wsa5__ReferenceParametersType(soap, tag?tag:"wsa5:ReferenceParametersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__ReferenceParametersType))
		soap_serialize_wsa5__ReferenceParametersType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, struct wsa5__ReferenceParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__ReferenceParametersType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__ReferenceParametersType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__ReferenceParametersType **)soap_malloc(soap, sizeof(struct wsa5__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_wsa5__ReferenceParametersType(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa5__ReferenceParametersType);
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, tag?tag:"wsa5:ReferenceParametersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	a->ReferenceParameters = NULL;
	a->Metadata = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Address);
	soap_serialize_PointerTowsa5__ReferenceParametersType(soap, &a->ReferenceParameters);
	soap_serialize_PointerTowsa5__MetadataType(soap, &a->Metadata);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa5__EndpointReferenceType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__EndpointReferenceType), type))
		return soap->error;
	if (a->Address)
	{	if (soap_out_string(soap, "wsa5:Address", -1, &a->Address, ""))
	return soap->error;
	}
	else if (soap_element_nil(soap, "wsa5:Address"))
		return soap->error;
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", -1, &a->ReferenceParameters, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", -1, &a->Metadata, ""))
		return soap->error;
	if (a->__any)
	{	int i;
	for (i = 0; i < a->__size; i++)
		soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_ReferenceParameters = 1;
	size_t soap_flag_Metadata = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__EndpointReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			if (soap_in_string(soap, "wsa5:Address", &a->Address, "xsd:string"))
			{	soap_flag_Address--;
		continue;
		}
		if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", &a->ReferenceParameters, "wsa5:ReferenceParametersType"))
			{	soap_flag_ReferenceParameters--;
		continue;
		}
		if (soap_flag_Metadata && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", &a->Metadata, "wsa5:MetadataType"))
			{	soap_flag_Metadata--;
		continue;
		}
		if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
		{	if (a->__any == NULL)
		{	if (soap_blist___any == NULL)
		soap_blist___any = soap_new_block(soap);
		a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
		if (a->__any == NULL)
			return NULL;
		*a->__any = NULL;
		}
		if (soap_inliteral(soap, "-any", a->__any))
		{	a->__size++;
		a->__any = NULL;
		continue;
		}
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
		if (soap_blist___any)
			soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__EndpointReferenceType, 0, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0))
	{	soap->error = SOAP_OCCURS;
	return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__EndpointReferenceType);
	if (soap_out_wsa5__EndpointReferenceType(soap, tag?tag:"wsa5:EndpointReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__MessageID(soap, &a->wsa__MessageID);
	a->wsa__RelatesTo = NULL;
	a->wsa__From = NULL;
	a->wsa__ReplyTo = NULL;
	a->wsa__FaultTo = NULL;

	a->password = NULL;
	a->username = NULL;
    a->ns1_customerId = NULL;

	soap_default__wsa__To(soap, &a->wsa__To);
	soap_default__wsa__Action(soap, &a->wsa__Action);

	soap_default__wsa5__MessageID(soap, &a->wsa5__MessageID);
	a->wsa5__RelatesTo = NULL;
	a->wsa5__From = NULL;
	a->wsa5__ReplyTo = NULL;
	a->wsa5__FaultTo = NULL;
	soap_default__wsa5__To(soap, &a->wsa5__To);
	soap_default__wsa5__Action(soap, &a->wsa5__Action);
	a->wsse__Security = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__wsa__MessageID(soap, &a->wsa__MessageID);
	soap_serialize_PointerTo_wsa__RelatesTo(soap, &a->wsa__RelatesTo);
	soap_serialize_PointerTo_wsa__From(soap, &a->wsa__From);
	soap_serialize_PointerTo_wsa__ReplyTo(soap, &a->wsa__ReplyTo);
	soap_serialize_PointerTo_wsa__FaultTo(soap, &a->wsa__FaultTo);
	soap_serialize__wsa__To(soap, &a->wsa__To);
	soap_serialize__wsa__Action(soap, &a->wsa__Action);
    
	soap_serialize__wsa5__MessageID(soap, &a->wsa5__MessageID);
	soap_serialize_PointerTo_wsa5__RelatesTo(soap, &a->wsa5__RelatesTo);
	soap_serialize_PointerTo_wsa5__From(soap, &a->wsa5__From);
	soap_serialize_PointerTo_wsa5__ReplyTo(soap, &a->wsa5__ReplyTo);
	soap_serialize_PointerTo_wsa5__FaultTo(soap, &a->wsa5__FaultTo);
	soap_serialize__wsa5__To(soap, &a->wsa5__To);
	soap_serialize__wsa5__Action(soap, &a->wsa5__Action);
	soap_serialize_PointerTo_wsse__Security(soap, &a->wsse__Security);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;

	if (soap_out__wsa__MessageID(soap, "wsa:MessageID", -1, &a->wsa__MessageID, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa__RelatesTo(soap, "wsa:RelatesTo", -1, &a->wsa__RelatesTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa__From(soap, "wsa:From", -1, &a->wsa__From, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa__ReplyTo(soap, "wsa:ReplyTo", -1, &a->wsa__ReplyTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa__FaultTo(soap, "wsa:FaultTo", -1, &a->wsa__FaultTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa__To(soap, "wsa:To", -1, &a->wsa__To, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa__Action(soap, "wsa:Action", -1, &a->wsa__Action, ""))
		return soap->error;

    if(a->bDiscover == false)
	{
		if(a->bDigest == _true)
		{
			if (soap_out__wsa5__Action(soap, "wsa5:Action", -1, &a->wsa5__Action, ""))
				return soap->error;
			soap->mustUnderstand = 0;

			if (soap_out__wsa5__MessageID(soap, "wsa5:MessageID", -1, &a->wsa5__MessageID, ""))
				return soap->error;
			if (soap_out_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", -1, &a->wsa5__RelatesTo, ""))
				return soap->error;
			if (soap_out_PointerTo_wsa5__From(soap, "wsa5:From", -1, &a->wsa5__From, ""))
				return soap->error;
			soap->mustUnderstand = 0;
			if (soap_out_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", -1, &a->wsa5__ReplyTo, ""))
				return soap->error;
			soap->mustUnderstand = 0;
			if (soap_out_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", -1, &a->wsa5__FaultTo, ""))
				return soap->error;
			soap->mustUnderstand = 0;

			if (soap_out__wsa5__To(soap, "wsa5:To", -1, &a->wsa5__To, ""))
				return soap->error;
			soap->mustUnderstand = 0;

			if (soap_out_PointerTo_wsse__Security(soap, "wsse:Security", -1, &a->wsse__Security, ""))
				return soap->error;

		}
		else
		{
			
			if(soap_element_begin_out(soap,"wsse:Security",-1,"")
				|| soap_element_begin_out(soap,"wsse:UsernameToken",-1,"")
				|| soap_out_string(soap,"wsse:Username",-1,&a->username,"")
				|| soap_out_string(soap,"wsse:Password",-1,&a->password,"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordText")
				|| soap_element_end_out(soap,"wsse:UsernameToken")
				|| soap_element_end_out(soap,"wsse:Security")
			)
			return soap->error;
			soap->mustUnderstand = 0;
			//*/
			//if (soap_out_string(soap, "ns1:customerId", -1, &a->ns1__customerId, ""))
			//     return soap->error;
		}
	} //not discovery
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_wsa__MessageID = 1;
	size_t soap_flag_wsa__RelatesTo = 1;
	size_t soap_flag_wsa__From = 1;
	size_t soap_flag_wsa__ReplyTo = 1;
	size_t soap_flag_wsa__FaultTo = 1;
	size_t soap_flag_wsa__To = 1;
	size_t soap_flag_wsa__Action = 1;

	size_t soap_flag_wsa5__MessageID = 1;
	size_t soap_flag_wsa5__RelatesTo = 1;
	size_t soap_flag_wsa5__From = 1;
	size_t soap_flag_wsa5__ReplyTo = 1;
	size_t soap_flag_wsa5__FaultTo = 1;
	size_t soap_flag_wsa5__To = 1;
	size_t soap_flag_wsa5__Action = 1;
	size_t soap_flag_wsse__Security = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa__MessageID(soap, "wsa:MessageID", &a->wsa__MessageID, ""))
				{	
					soap_flag_wsa__MessageID--;
					continue;
				}
			if (soap_flag_wsa__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__RelatesTo(soap, "wsa:RelatesTo", &a->wsa__RelatesTo, ""))
				{	
					soap_flag_wsa__RelatesTo--;
					continue;
				}
			if (soap_flag_wsa__From && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__From(soap, "wsa:From", &a->wsa__From, ""))
				{	
					soap_flag_wsa__From--;
					continue;
				}
			if (soap_flag_wsa__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__ReplyTo(soap, "wsa:ReplyTo", &a->wsa__ReplyTo, ""))
				{	
					soap_flag_wsa__ReplyTo--;
					continue;
				}
			if (soap_flag_wsa__FaultTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__FaultTo(soap, "wsa:FaultTo", &a->wsa__FaultTo, ""))
				{	
					soap_flag_wsa__FaultTo--;
					continue;
				}
			if (soap_flag_wsa__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa__To(soap, "wsa:To", &a->wsa__To, ""))
				{	
					soap_flag_wsa__To--;
					continue;
				}	
			if (soap_flag_wsa__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa__Action(soap, "wsa:Action", &a->wsa__Action, ""))
				{	
					soap_flag_wsa__Action--;
					continue;
				}
			if (soap_flag_wsa5__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa5__MessageID(soap, "wsa5:MessageID", &a->wsa5__MessageID, ""))
				{	
					soap_flag_wsa5__MessageID--;
				    continue;
				}
			if (soap_flag_wsa5__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", &a->wsa5__RelatesTo, ""))
				{	
					soap_flag_wsa5__RelatesTo--;
				    continue;
				}
			if (soap_flag_wsa5__From && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__From(soap, "wsa5:From", &a->wsa5__From, ""))
				{	
					soap_flag_wsa5__From--;
				    continue;
				}
			if (soap_flag_wsa5__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", &a->wsa5__ReplyTo, ""))
					{	
						soap_flag_wsa5__ReplyTo--;
				        continue;
				    }
			if (soap_flag_wsa5__FaultTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", &a->wsa5__FaultTo, ""))
				{	
					soap_flag_wsa5__FaultTo--;
				    continue;
				}
			if (soap_flag_wsa5__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa5__To(soap, "wsa5:To", &a->wsa5__To, ""))
				{	
					soap_flag_wsa5__To--;
					continue;
				}
			if (soap_flag_wsa5__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa5__Action(soap, "wsa5:Action", &a->wsa5__Action, ""))
				{	
					soap_flag_wsa5__Action--;
					continue;
				}
			if (soap_flag_wsse__Security && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Security(soap, "wsse:Security", &a->wsse__Security, ""))
				{	
					soap_flag_wsse__Security--;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__Relationship(struct soap *soap, struct wsa__Relationship *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__QName(soap, &a->RelationshipType);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__Relationship(struct soap *soap, const struct wsa__Relationship *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__Relationship(struct soap *soap, const char *tag, int id, const struct wsa__Relationship *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", soap_QName2s(soap, a->RelationshipType), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa__Relationship * SOAP_FMAC4 soap_in_wsa__Relationship(struct soap *soap, const char *tag, struct wsa__Relationship *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__Relationship *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__Relationship, sizeof(struct wsa__Relationship), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa__Relationship(soap, a);
	if (soap_s2QName(soap, soap_attr_value(soap, "RelationshipType", 0), &a->RelationshipType, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, "wsa:Relationship"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__Relationship(struct soap *soap, const struct wsa__Relationship *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__Relationship);
	if (soap_out_wsa__Relationship(soap, tag?tag:"wsa:Relationship", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__Relationship * SOAP_FMAC4 soap_get_wsa__Relationship(struct soap *soap, struct wsa__Relationship *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__Relationship(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->__item);
	soap_default_string(soap, &a->PortName);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ServiceNameType(struct soap *soap, const struct wsa__ServiceNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ServiceNameType(struct soap *soap, const char *tag, int id, const struct wsa__ServiceNameType *a, const char *type)
{
	const char *soap_tmp___item = soap_QName2s(soap, a->__item);
	if (a->PortName)
		soap_set_attr(soap, "PortName", a->PortName, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	return soap_out__QName(soap, tag, id, (char*const*)&soap_tmp___item, "");
}

SOAP_FMAC3 struct wsa__ServiceNameType * SOAP_FMAC4 soap_in_wsa__ServiceNameType(struct soap *soap, const char *tag, struct wsa__ServiceNameType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__ServiceNameType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ServiceNameType, sizeof(struct wsa__ServiceNameType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa__ServiceNameType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "PortName", 0), &a->PortName, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (!soap_in__QName(soap, tag, &a->__item, "wsa:ServiceNameType"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ServiceNameType(struct soap *soap, const struct wsa__ServiceNameType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__ServiceNameType);
	if (soap_out_wsa__ServiceNameType(soap, tag?tag:"wsa:ServiceNameType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ServiceNameType * SOAP_FMAC4 soap_get_wsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ServiceNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{
		a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_d__FaultCodeOpenType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_d__FaultCodeOpenType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_d__FaultCodeOpenType(struct soap *soap, const char *tag, char **a, const char *type)
{	
	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_d__FaultCodeOpenType, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_d__FaultCodeOpenType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_d__FaultCodeOpenType);
	if (soap_out_d__FaultCodeOpenType(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_d__FaultCodeOpenType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_d__FaultCodeOpenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_d__UriListType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_d__UriListType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_d__UriListType(struct soap *soap, const char *tag, char **a, const char *type)
{	
	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_d__UriListType, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_d__UriListType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_d__UriListType);
	if (soap_out_d__UriListType(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_d__UriListType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_d__UriListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_d__QNameListType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_d__QNameListType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_d__QNameListType(struct soap *soap, const char *tag, char **a, const char *type)
{	
	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_d__QNameListType, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_d__QNameListType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_d__QNameListType);
	if (soap_out_d__QNameListType(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_d__QNameListType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_d__QNameListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_d__OpenRelationshipType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_d__OpenRelationshipType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_d__OpenRelationshipType(struct soap *soap, const char *tag, char **a, const char *type)
{	
	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_d__OpenRelationshipType, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_d__OpenRelationshipType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_d__OpenRelationshipType);
	if (soap_out_d__OpenRelationshipType(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_d__OpenRelationshipType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_d__OpenRelationshipType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__IDREFS(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__IDREFS);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__IDREFS(struct soap *soap, const char *tag, char **a, const char *type)
{	
	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__IDREFS, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__IDREFS(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__IDREFS);
	if (soap_out_xsd__IDREFS(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__IDREFS(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__IDREFS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__FaultTo))
		soap_serialize__wsa__FaultTo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa__FaultTo(struct soap *soap, const char *tag, int id, struct wsa__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__FaultTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__FaultTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa__FaultTo(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct wsa__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__wsa__FaultTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__FaultTo, sizeof(struct wsa__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa__FaultTo);
	if (soap_out_PointerTo_wsa__FaultTo(soap, tag?tag:"wsa:FaultTo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__FaultTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__ReplyTo))
		soap_serialize__wsa__ReplyTo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa__ReplyTo(struct soap *soap, const char *tag, int id, struct wsa__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__ReplyTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__ReplyTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa__ReplyTo(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct wsa__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__wsa__ReplyTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__ReplyTo, sizeof(struct wsa__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa__ReplyTo);
	if (soap_out_PointerTo_wsa__ReplyTo(soap, tag?tag:"wsa:ReplyTo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__ReplyTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa__From(struct soap *soap, struct wsa__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__From))
		soap_serialize__wsa__From(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa__From(struct soap *soap, const char *tag, int id, struct wsa__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__From);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__From(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa__From(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct wsa__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__wsa__From(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__From, sizeof(struct wsa__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa__From(struct soap *soap, struct wsa__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa__From);
	if (soap_out_PointerTo_wsa__From(soap, tag?tag:"wsa:From", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa__From(struct soap *soap, struct wsa__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__From(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa__RelatesTo(struct soap *soap, struct wsa__Relationship *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__RelatesTo))
		soap_serialize__wsa__RelatesTo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa__RelatesTo(struct soap *soap, const char *tag, int id, struct wsa__Relationship *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__RelatesTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__RelatesTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__Relationship ** SOAP_FMAC4 soap_in_PointerTo_wsa__RelatesTo(struct soap *soap, const char *tag, struct wsa__Relationship **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct wsa__Relationship **)soap_malloc(soap, sizeof(struct wsa__Relationship *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__wsa__RelatesTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct wsa__Relationship **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__RelatesTo, sizeof(struct wsa__Relationship), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa__RelatesTo(struct soap *soap, struct wsa__Relationship *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa__RelatesTo);
	if (soap_out_PointerTo_wsa__RelatesTo(soap, tag?tag:"wsa:RelatesTo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__Relationship ** SOAP_FMAC4 soap_get_PointerTo_wsa__RelatesTo(struct soap *soap, struct wsa__Relationship **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__RelatesTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__ServiceNameType))
		soap_serialize_wsa__ServiceNameType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__ServiceNameType(struct soap *soap, const char *tag, int id, struct wsa__ServiceNameType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__ServiceNameType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa__ServiceNameType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__ServiceNameType ** SOAP_FMAC4 soap_in_PointerTowsa__ServiceNameType(struct soap *soap, const char *tag, struct wsa__ServiceNameType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct wsa__ServiceNameType **)soap_malloc(soap, sizeof(struct wsa__ServiceNameType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_wsa__ServiceNameType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct wsa__ServiceNameType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__ServiceNameType, sizeof(struct wsa__ServiceNameType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa__ServiceNameType);
	if (soap_out_PointerTowsa__ServiceNameType(soap, tag?tag:"wsa:ServiceNameType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ServiceNameType ** SOAP_FMAC4 soap_get_PointerTowsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__ServiceNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

//device discover
SOAP_FMAC3 void SOAP_FMAC4 soap_default___dndl__Probe(struct soap *soap, struct __dndl__Probe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->d__Probe = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___dndl__Probe(struct soap *soap, const struct __dndl__Probe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTod__ProbeType(soap, &a->d__Probe);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___dndl__Probe(struct soap *soap, const char *tag, int id, const struct __dndl__Probe *a, const char *type)
{
	if (soap_out_PointerTod__ProbeType(soap, "d:Probe", -1, &a->d__Probe, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __dndl__Probe * SOAP_FMAC4 soap_in___dndl__Probe(struct soap *soap, const char *tag, struct __dndl__Probe *a, const char *type)
{
	size_t soap_flag_d__Probe = 1;
	short soap_flag;
	a = (struct __dndl__Probe *)soap_id_enter(soap, "", a, SOAP_TYPE___dndl__Probe, sizeof(struct __dndl__Probe), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___dndl__Probe(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_d__Probe && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTod__ProbeType(soap, "d:Probe", &a->d__Probe, "d:ProbeType"))
			{	
				soap_flag_d__Probe--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___dndl__Probe(struct soap *soap, const struct __dndl__Probe *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___dndl__Probe(soap, tag?tag:"-dndl:Probe", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __dndl__Probe * SOAP_FMAC4 soap_get___dndl__Probe(struct soap *soap, struct __dndl__Probe *p, const char *tag, const char *type)
{
	if ((p = soap_in___dndl__Probe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_default_d__ProbeMatchesType(struct soap *soap, struct d__ProbeMatchesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeProbeMatch = 0;
	a->ProbeMatch = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_d__ProbeMatchesType(struct soap *soap, const struct d__ProbeMatchesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ProbeMatch)
	{	
		int i;
		for (i = 0; i < a->__sizeProbeMatch; i++)
		{
			soap_embedded(soap, a->ProbeMatch + i, SOAP_TYPE_d__ProbeMatchType);
			soap_serialize_d__ProbeMatchType(soap, a->ProbeMatch + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_d__ProbeMatchesType(struct soap *soap, const char *tag, int id, const struct d__ProbeMatchesType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_d__ProbeMatchesType), type))
		return soap->error;
	soap_element_result(soap, "-sizeProbeMatch");
	if (a->ProbeMatch)
	{	
		int i;
		for (i = 0; i < a->__sizeProbeMatch; i++)
			if (soap_out_d__ProbeMatchType(soap, "d:ProbeMatch", -1, a->ProbeMatch + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct d__ProbeMatchesType * SOAP_FMAC4 soap_in_d__ProbeMatchesType(struct soap *soap, const char *tag, struct d__ProbeMatchesType *a, const char *type)
{
	struct soap_blist *soap_blist_ProbeMatch = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct d__ProbeMatchesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_d__ProbeMatchesType, sizeof(struct d__ProbeMatchesType), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_d__ProbeMatchesType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "d:ProbeMatch", 1, NULL))
			{	
				if (a->ProbeMatch == NULL)
				{	
					if (soap_blist_ProbeMatch == NULL)
						soap_blist_ProbeMatch = soap_new_block(soap);
					a->ProbeMatch = (struct d__ProbeMatchType *)soap_push_block(soap, soap_blist_ProbeMatch, sizeof(struct d__ProbeMatchType));
					if (a->ProbeMatch == NULL)
						return NULL;
					soap_default_d__ProbeMatchType(soap, a->ProbeMatch);
				}
				soap_revert(soap);
				if (soap_in_d__ProbeMatchType(soap, "d:ProbeMatch", a->ProbeMatch, "d:ProbeMatchType"))
				{	
					a->__sizeProbeMatch++;
					a->ProbeMatch = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeProbeMatch");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ProbeMatch)
			soap_pop_block(soap, soap_blist_ProbeMatch);
		if (a->__sizeProbeMatch)
			a->ProbeMatch = (struct d__ProbeMatchType *)soap_save_block(soap, soap_blist_ProbeMatch, NULL, 1);
		else
		{	
			a->ProbeMatch = NULL;
			if (soap_blist_ProbeMatch)
				soap_end_block(soap, soap_blist_ProbeMatch);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct d__ProbeMatchesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_d__ProbeMatchesType, 0, sizeof(struct d__ProbeMatchesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_d__ProbeMatchesType(struct soap *soap, const struct d__ProbeMatchesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_d__ProbeMatchesType);
	if (soap_out_d__ProbeMatchesType(soap, tag?tag:"d:ProbeMatchesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__ProbeMatchesType * SOAP_FMAC4 soap_get_d__ProbeMatchesType(struct soap *soap, struct d__ProbeMatchesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_d__ProbeMatchesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_d__ScopesType(struct soap *soap, struct d__ScopesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_d__UriListType(soap, &a->__item);
	soap_default_string(soap, &a->MatchBy);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_d__ScopesType(struct soap *soap, const struct d__ScopesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_d__UriListType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_d__ScopesType(struct soap *soap, const char *tag, int id, const struct d__ScopesType *a, const char *type)
{
	if (a->MatchBy)
		soap_set_attr(soap, "MatchBy", a->MatchBy, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	return soap_out_d__UriListType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct d__ScopesType * SOAP_FMAC4 soap_in_d__ScopesType(struct soap *soap, const char *tag, struct d__ScopesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct d__ScopesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_d__ScopesType, sizeof(struct d__ScopesType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_d__ScopesType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "MatchBy", 0), &a->MatchBy, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (!soap_in_d__UriListType(soap, tag, &a->__item, "d:ScopesType"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_d__ScopesType(struct soap *soap, const struct d__ScopesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_d__ScopesType);
	if (soap_out_d__ScopesType(soap, tag?tag:"d:ScopesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__ScopesType * SOAP_FMAC4 soap_get_d__ScopesType(struct soap *soap, struct d__ScopesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_d__ScopesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_d__ProbeType(struct soap *soap, struct d__ProbeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_d__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_d__ProbeType(struct soap *soap, const struct d__ProbeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_d__QNameListType(soap, &a->Types);
	soap_serialize_PointerTod__ScopesType(soap, &a->Scopes);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_d__ProbeType(struct soap *soap, const char *tag, int id, const struct d__ProbeType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_d__ProbeType), type))
		return soap->error;
	if (soap_out_d__QNameListType(soap, "d:Types", -1, &a->Types, ""))
		return soap->error;
	if (soap_out_PointerTod__ScopesType(soap, "d:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct d__ProbeType * SOAP_FMAC4 soap_in_d__ProbeType(struct soap *soap, const char *tag, struct d__ProbeType *a, const char *type)
{
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct d__ProbeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_d__ProbeType, sizeof(struct d__ProbeType), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_d__ProbeType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_d__QNameListType(soap, "d:Types", &a->Types, "d:QNameListType"))
				{	
					soap_flag_Types--;
					continue;
				}
				if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTod__ScopesType(soap, "d:Scopes", &a->Scopes, "d:ScopesType"))
					{	
						soap_flag_Scopes--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
					{	
						if (a->__any == NULL)
						{	
							if (soap_blist___any == NULL)
								soap_blist___any = soap_new_block(soap);
							a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
							if (a->__any == NULL)
								return NULL;
							*a->__any = NULL;
						}
						if (soap_inliteral(soap, "-any", a->__any))
						{	
							a->__size++;
							a->__any = NULL;
							continue;
						}
					}
					if (soap->error == SOAP_TAG_MISMATCH)
						soap->error = soap_ignore_element(soap);
					if (soap->error == SOAP_NO_TAG)
						break;
					if (soap->error)
						return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct d__ProbeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_d__ProbeType, 0, sizeof(struct d__ProbeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_d__ProbeType(struct soap *soap, const struct d__ProbeType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_d__ProbeType);
	if (soap_out_d__ProbeType(soap, tag?tag:"d:ProbeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__ProbeType * SOAP_FMAC4 soap_get_d__ProbeType(struct soap *soap, struct d__ProbeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_d__ProbeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_d__ProbeMatchType(struct soap *soap, struct d__ProbeMatchType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_default_d__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	soap_default_d__UriListType(soap, &a->XAddrs);
	soap_default_unsignedInt(soap, &a->MetadataVersion);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_d__ProbeMatchType(struct soap *soap, const struct d__ProbeMatchType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_serialize_d__QNameListType(soap, &a->Types);
	soap_serialize_PointerTod__ScopesType(soap, &a->Scopes);
	soap_serialize_d__UriListType(soap, &a->XAddrs);
	soap_embedded(soap, &a->MetadataVersion, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_d__ProbeMatchType(struct soap *soap, const char *tag, int id, const struct d__ProbeMatchType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_d__ProbeMatchType), type))
		return soap->error;
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	if (soap_out_d__QNameListType(soap, "d:Types", -1, &a->Types, ""))
		return soap->error;
	if (soap_out_PointerTod__ScopesType(soap, "d:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (soap_out_d__UriListType(soap, "d:XAddrs", -1, &a->XAddrs, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "d:MetadataVersion", -1, &a->MetadataVersion, ""))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct d__ProbeMatchType * SOAP_FMAC4 soap_in_d__ProbeMatchType(struct soap *soap, const char *tag, struct d__ProbeMatchType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	size_t soap_flag_XAddrs = 1;
	size_t soap_flag_MetadataVersion = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct d__ProbeMatchType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_d__ProbeMatchType, sizeof(struct d__ProbeMatchType), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_d__ProbeMatchType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	
					soap_flag_wsa__EndpointReference--;
					continue;
				}
				if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
					if (soap_in_d__QNameListType(soap, "d:Types", &a->Types, "d:QNameListType"))
					{	
						soap_flag_Types--;
						continue;
					}
					if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTod__ScopesType(soap, "d:Scopes", &a->Scopes, "d:ScopesType"))
						{	
							soap_flag_Scopes--;
							continue;
						}
						if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
							if (soap_in_d__UriListType(soap, "d:XAddrs", &a->XAddrs, "d:UriListType"))
							{	
								soap_flag_XAddrs--;
								continue;
							}
							if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
								if (soap_in_unsignedInt(soap, "d:MetadataVersion", &a->MetadataVersion, "xsd:unsignedInt"))
								{	
									soap_flag_MetadataVersion--;
									continue;
								}
								if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
								{	
									if (a->__any == NULL)
									{	
										if (soap_blist___any == NULL)
											soap_blist___any = soap_new_block(soap);
										a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
										if (a->__any == NULL)
											return NULL;
										*a->__any = NULL;
									}
									if (soap_inliteral(soap, "-any", a->__any))
									{	
										a->__size++;
										a->__any = NULL;
										continue;
									}
								}
								if (soap->error == SOAP_TAG_MISMATCH)
									soap->error = soap_ignore_element(soap);
								if (soap->error == SOAP_NO_TAG)
									break;
								if (soap->error)
									return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct d__ProbeMatchType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_d__ProbeMatchType, 0, sizeof(struct d__ProbeMatchType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0 || soap_flag_MetadataVersion > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_d__ProbeMatchType(struct soap *soap, const struct d__ProbeMatchType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_d__ProbeMatchType);
	if (soap_out_d__ProbeMatchType(soap, tag?tag:"d:ProbeMatchType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__ProbeMatchType * SOAP_FMAC4 soap_get_d__ProbeMatchType(struct soap *soap, struct d__ProbeMatchType *p, const char *tag, const char *type)
{
	if ((p = soap_in_d__ProbeMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTod__ProbeType(struct soap *soap, struct d__ProbeType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_d__ProbeType))
		soap_serialize_d__ProbeType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTod__ProbeType(struct soap *soap, const char *tag, int id, struct d__ProbeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_d__ProbeType);
	if (id < 0)
		return soap->error;
	return soap_out_d__ProbeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct d__ProbeType ** SOAP_FMAC4 soap_in_PointerTod__ProbeType(struct soap *soap, const char *tag, struct d__ProbeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct d__ProbeType **)soap_malloc(soap, sizeof(struct d__ProbeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_d__ProbeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct d__ProbeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_d__ProbeType, sizeof(struct d__ProbeType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTod__ProbeType(struct soap *soap, struct d__ProbeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTod__ProbeType);
	if (soap_out_PointerTod__ProbeType(soap, tag?tag:"d:ProbeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__ProbeType ** SOAP_FMAC4 soap_get_PointerTod__ProbeType(struct soap *soap, struct d__ProbeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTod__ProbeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTod__ProbeMatchesType(struct soap *soap, struct d__ProbeMatchesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_d__ProbeMatchesType))
		soap_serialize_d__ProbeMatchesType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTod__ProbeMatchesType(struct soap *soap, const char *tag, int id, struct d__ProbeMatchesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_d__ProbeMatchesType);
	if (id < 0)
		return soap->error;
	return soap_out_d__ProbeMatchesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct d__ProbeMatchesType ** SOAP_FMAC4 soap_in_PointerTod__ProbeMatchesType(struct soap *soap, const char *tag, struct d__ProbeMatchesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct d__ProbeMatchesType **)soap_malloc(soap, sizeof(struct d__ProbeMatchesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_d__ProbeMatchesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct d__ProbeMatchesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_d__ProbeMatchesType, sizeof(struct d__ProbeMatchesType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTod__ProbeMatchesType(struct soap *soap, struct d__ProbeMatchesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTod__ProbeMatchesType);
	if (soap_out_PointerTod__ProbeMatchesType(soap, tag?tag:"d:ProbeMatchesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__ProbeMatchesType ** SOAP_FMAC4 soap_get_PointerTod__ProbeMatchesType(struct soap *soap, struct d__ProbeMatchesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTod__ProbeMatchesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTod__ScopesType(struct soap *soap, struct d__ScopesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_d__ScopesType))
		soap_serialize_d__ScopesType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTod__ScopesType(struct soap *soap, const char *tag, int id, struct d__ScopesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_d__ScopesType);
	if (id < 0)
		return soap->error;
	return soap_out_d__ScopesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct d__ScopesType ** SOAP_FMAC4 soap_in_PointerTod__ScopesType(struct soap *soap, const char *tag, struct d__ScopesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct d__ScopesType **)soap_malloc(soap, sizeof(struct d__ScopesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_d__ScopesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct d__ScopesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_d__ScopesType, sizeof(struct d__ScopesType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTod__ScopesType(struct soap *soap, struct d__ScopesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTod__ScopesType);
	if (soap_out_PointerTod__ScopesType(soap, tag?tag:"d:ScopesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__ScopesType ** SOAP_FMAC4 soap_get_PointerTod__ScopesType(struct soap *soap, struct d__ScopesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTod__ScopesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ReferenceParametersType(struct soap *soap, const struct wsa__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa__ReferenceParametersType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__ReferenceParametersType), type))
		return soap->error;
	if (a->__any)
	{	int i;
	for (i = 0; i < a->__size; i++)
		soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa__ReferenceParametersType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__ReferenceParametersType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(struct wsa__ReferenceParametersType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__ReferenceParametersType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
		{	if (a->__any == NULL)
		{	if (soap_blist___any == NULL)
		soap_blist___any = soap_new_block(soap);
		a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
		if (a->__any == NULL)
			return NULL;
		*a->__any = NULL;
		}
		if (soap_inliteral(soap, "-any", a->__any))
		{	a->__size++;
		a->__any = NULL;
		continue;
		}
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
		if (soap_blist___any)
			soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__ReferenceParametersType, 0, sizeof(struct wsa__ReferenceParametersType), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ReferenceParametersType(struct soap *soap, const struct wsa__ReferenceParametersType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__ReferenceParametersType);
	if (soap_out_wsa__ReferenceParametersType(soap, tag?tag:"wsa:ReferenceParametersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ReferencePropertiesType(struct soap *soap, const struct wsa__ReferencePropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ReferencePropertiesType(struct soap *soap, const char *tag, int id, const struct wsa__ReferencePropertiesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__ReferencePropertiesType), type))
		return soap->error;
	if (a->__any)
	{	int i;
	for (i = 0; i < a->__size; i++)
		soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType * SOAP_FMAC4 soap_in_wsa__ReferencePropertiesType(struct soap *soap, const char *tag, struct wsa__ReferencePropertiesType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__ReferencePropertiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ReferencePropertiesType, sizeof(struct wsa__ReferencePropertiesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__ReferencePropertiesType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
		{	if (a->__any == NULL)
		{	if (soap_blist___any == NULL)
		soap_blist___any = soap_new_block(soap);
		a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
		if (a->__any == NULL)
			return NULL;
		*a->__any = NULL;
		}
		if (soap_inliteral(soap, "-any", a->__any))
		{	a->__size++;
		a->__any = NULL;
		continue;
		}
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
		if (soap_blist___any)
			soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferencePropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__ReferencePropertiesType, 0, sizeof(struct wsa__ReferencePropertiesType), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ReferencePropertiesType(struct soap *soap, const struct wsa__ReferencePropertiesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__ReferencePropertiesType);
	if (soap_out_wsa__ReferencePropertiesType(soap, tag?tag:"wsa:ReferencePropertiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType * SOAP_FMAC4 soap_get_wsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ReferencePropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	a->ReferenceProperties = NULL;
	a->ReferenceParameters = NULL;
	a->PortType = NULL;
	a->ServiceName = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__EndpointReferenceType(struct soap *soap, const struct wsa__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Address);
	soap_serialize_PointerTowsa__ReferencePropertiesType(soap, &a->ReferenceProperties);
	soap_serialize_PointerTowsa__ReferenceParametersType(soap, &a->ReferenceParameters);
	soap_serialize_PointerTo_QName(soap, &a->PortType);
	soap_serialize_PointerTowsa__ServiceNameType(soap, &a->ServiceName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa__EndpointReferenceType *a, const char *type)
{
	const char *soap_tmp_PortType = a->PortType ? soap_QName2s(soap, *a->PortType) : NULL;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__EndpointReferenceType), type))
		return soap->error;
	if (a->Address)
	{	
		if (soap_out_string(soap, "wsa:Address", -1, &a->Address, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "wsa:Address"))
		return soap->error;
	if (soap_out_PointerTowsa__ReferencePropertiesType(soap, "wsa:ReferenceProperties", -1, &a->ReferenceProperties, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", -1, &a->ReferenceParameters, ""))
		return soap->error;
	if (soap_out__QName(soap, "wsa:PortType", -1, (char*const*)&soap_tmp_PortType, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ServiceNameType(soap, "wsa:ServiceName", -1, &a->ServiceName, ""))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_ReferenceProperties = 1;
	size_t soap_flag_ReferenceParameters = 1;
	size_t soap_flag_PortType = 1;
	size_t soap_flag_ServiceName = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__EndpointReferenceType, sizeof(struct wsa__EndpointReferenceType), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_wsa__EndpointReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsa:Address", &a->Address, "xsd:string"))
				{	
					soap_flag_Address--;
					continue;
				}
				if (soap_flag_ReferenceProperties && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTowsa__ReferencePropertiesType(soap, "wsa:ReferenceProperties", &a->ReferenceProperties, "wsa:ReferencePropertiesType"))
					{	
						soap_flag_ReferenceProperties--;
						continue;
					}
					if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", &a->ReferenceParameters, "wsa:ReferenceParametersType"))
						{	
							soap_flag_ReferenceParameters--;
							continue;
						}
						if (soap_flag_PortType && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_PointerTo_QName(soap, "wsa:PortType", &a->PortType, ""))
							{	
								soap_flag_PortType--;
								continue;
							}
							if (soap_flag_ServiceName && soap->error == SOAP_TAG_MISMATCH)
								if (soap_in_PointerTowsa__ServiceNameType(soap, "wsa:ServiceName", &a->ServiceName, "wsa:ServiceNameType"))
								{	
									soap_flag_ServiceName--;
									continue;
								}
								if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
								{	
									if (a->__any == NULL)
									{	
										if (soap_blist___any == NULL)
											soap_blist___any = soap_new_block(soap);
										a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
										if (a->__any == NULL)
											return NULL;
										*a->__any = NULL;
									}
									if (soap_inliteral(soap, "-any", a->__any))
									{	
										a->__size++;
										a->__any = NULL;
										continue;
									}
								}
								if (soap->error == SOAP_TAG_MISMATCH)
									soap->error = soap_ignore_element(soap);
								if (soap->error == SOAP_NO_TAG)
									break;
								if (soap->error)
									return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct wsa__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__EndpointReferenceType, 0, sizeof(struct wsa__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__EndpointReferenceType(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__EndpointReferenceType);
	if (soap_out_wsa__EndpointReferenceType(soap, tag?tag:"wsa:EndpointReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}



SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__ReferenceParametersType))
		soap_serialize_wsa__ReferenceParametersType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__ReferenceParametersType(struct soap *soap, const char *tag, int id, struct wsa__ReferenceParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__ReferenceParametersType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa__ReferenceParametersType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTowsa__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa__ReferenceParametersType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct wsa__ReferenceParametersType **)soap_malloc(soap, sizeof(struct wsa__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_wsa__ReferenceParametersType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct wsa__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(struct wsa__ReferenceParametersType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa__ReferenceParametersType);
	if (soap_out_PointerTowsa__ReferenceParametersType(soap, tag?tag:"wsa:ReferenceParametersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTowsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__ReferencePropertiesType))
		soap_serialize_wsa__ReferencePropertiesType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__ReferencePropertiesType(struct soap *soap, const char *tag, int id, struct wsa__ReferencePropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__ReferencePropertiesType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa__ReferencePropertiesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType ** SOAP_FMAC4 soap_in_PointerTowsa__ReferencePropertiesType(struct soap *soap, const char *tag, struct wsa__ReferencePropertiesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct wsa__ReferencePropertiesType **)soap_malloc(soap, sizeof(struct wsa__ReferencePropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_wsa__ReferencePropertiesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct wsa__ReferencePropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__ReferencePropertiesType, sizeof(struct wsa__ReferencePropertiesType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa__ReferencePropertiesType);
	if (soap_out_PointerTowsa__ReferencePropertiesType(soap, tag?tag:"wsa:ReferencePropertiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType ** SOAP_FMAC4 soap_get_PointerTowsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__ReferencePropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTod__ProbeMatchType(struct soap *soap, struct d__ProbeMatchType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_d__ProbeMatchType))
		soap_serialize_d__ProbeMatchType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTod__ProbeMatchType(struct soap *soap, const char *tag, int id, struct d__ProbeMatchType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_d__ProbeMatchType);
	if (id < 0)
		return soap->error;
	return soap_out_d__ProbeMatchType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct d__ProbeMatchType ** SOAP_FMAC4 soap_in_PointerTod__ProbeMatchType(struct soap *soap, const char *tag, struct d__ProbeMatchType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct d__ProbeMatchType **)soap_malloc(soap, sizeof(struct d__ProbeMatchType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_d__ProbeMatchType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct d__ProbeMatchType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_d__ProbeMatchType, sizeof(struct d__ProbeMatchType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTod__ProbeMatchType(struct soap *soap, struct d__ProbeMatchType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTod__ProbeMatchType);
	if (soap_out_PointerTod__ProbeMatchType(soap, tag?tag:"d:ProbeMatchType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__ProbeMatchType ** SOAP_FMAC4 soap_get_PointerTod__ProbeMatchType(struct soap *soap, struct d__ProbeMatchType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTod__ProbeMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTod__SigType(struct soap *soap, struct d__SigType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_d__SigType))
		soap_serialize_d__SigType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTod__SigType(struct soap *soap, const char *tag, int id, struct d__SigType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_d__SigType);
	if (id < 0)
		return soap->error;
	return soap_out_d__SigType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct d__SigType ** SOAP_FMAC4 soap_in_PointerTod__SigType(struct soap *soap, const char *tag, struct d__SigType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct d__SigType **)soap_malloc(soap, sizeof(struct d__SigType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_d__SigType(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct d__SigType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_d__SigType, sizeof(struct d__SigType), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTod__SigType(struct soap *soap, struct d__SigType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTod__SigType);
	if (soap_out_PointerTod__SigType(soap, tag?tag:"d:SigType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__SigType ** SOAP_FMAC4 soap_get_PointerTod__SigType(struct soap *soap, struct d__SigType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTod__SigType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

//
SOAP_FMAC3 void SOAP_FMAC4 soap_default___dnrd__Bye(struct soap *soap, struct __dnrd__Bye *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->d__Bye = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___dnrd__Bye(struct soap *soap, const struct __dnrd__Bye *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTod__ByeType(soap, &a->d__Bye);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___dnrd__Bye(struct soap *soap, const char *tag, int id, const struct __dnrd__Bye *a, const char *type)
{
	if (soap_out_PointerTod__ByeType(soap, "d:Bye", -1, &a->d__Bye, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __dnrd__Bye * SOAP_FMAC4 soap_in___dnrd__Bye(struct soap *soap, const char *tag, struct __dnrd__Bye *a, const char *type)
{
	size_t soap_flag_d__Bye = 1;
	short soap_flag;
	a = (struct __dnrd__Bye *)soap_id_enter(soap, "", a, SOAP_TYPE___dnrd__Bye, sizeof(struct __dnrd__Bye), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___dnrd__Bye(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_d__Bye && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTod__ByeType(soap, "d:Bye", &a->d__Bye, "d:ByeType"))
			{	
				soap_flag_d__Bye--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___dnrd__Bye(struct soap *soap, const struct __dnrd__Bye *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___dnrd__Bye(soap, tag?tag:"-dnrd:Bye", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __dnrd__Bye * SOAP_FMAC4 soap_get___dnrd__Bye(struct soap *soap, struct __dnrd__Bye *p, const char *tag, const char *type)
{
	if ((p = soap_in___dnrd__Bye(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___dnrd__Hello(struct soap *soap, struct __dnrd__Hello *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->d__Hello = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___dnrd__Hello(struct soap *soap, const struct __dnrd__Hello *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTod__HelloType(soap, &a->d__Hello);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___dnrd__Hello(struct soap *soap, const char *tag, int id, const struct __dnrd__Hello *a, const char *type)
{
	if (soap_out_PointerTod__HelloType(soap, "d:Hello", -1, &a->d__Hello, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __dnrd__Hello * SOAP_FMAC4 soap_in___dnrd__Hello(struct soap *soap, const char *tag, struct __dnrd__Hello *a, const char *type)
{
	size_t soap_flag_d__Hello = 1;
	short soap_flag;
	a = (struct __dnrd__Hello *)soap_id_enter(soap, "", a, SOAP_TYPE___dnrd__Hello, sizeof(struct __dnrd__Hello), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___dnrd__Hello(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_d__Hello && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTod__HelloType(soap, "d:Hello", &a->d__Hello, "d:HelloType"))
			{	
				soap_flag_d__Hello--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___dnrd__Hello(struct soap *soap, const struct __dnrd__Hello *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___dnrd__Hello(soap, tag?tag:"-dnrd:Hello", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __dnrd__Hello * SOAP_FMAC4 soap_get___dnrd__Hello(struct soap *soap, struct __dnrd__Hello *p, const char *tag, const char *type)
{
	if ((p = soap_in___dnrd__Hello(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_default_d__ResolveMatchType(struct soap *soap, struct d__ResolveMatchType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_default_d__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	soap_default_d__UriListType(soap, &a->XAddrs);
	soap_default_unsignedInt(soap, &a->MetadataVersion);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_d__ResolveMatchType(struct soap *soap, const struct d__ResolveMatchType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_serialize_d__QNameListType(soap, &a->Types);
	soap_serialize_PointerTod__ScopesType(soap, &a->Scopes);
	soap_serialize_d__UriListType(soap, &a->XAddrs);
	soap_embedded(soap, &a->MetadataVersion, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_d__ResolveMatchType(struct soap *soap, const char *tag, int id, const struct d__ResolveMatchType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_d__ResolveMatchType), type))
		return soap->error;
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	if (soap_out_d__QNameListType(soap, "d:Types", -1, &a->Types, ""))
		return soap->error;
	if (soap_out_PointerTod__ScopesType(soap, "d:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (a->XAddrs)
	{	
		if (soap_out_d__UriListType(soap, "d:XAddrs", -1, &a->XAddrs, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "d:XAddrs"))
		return soap->error;
	if (soap_out_unsignedInt(soap, "d:MetadataVersion", -1, &a->MetadataVersion, ""))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct d__ResolveMatchType * SOAP_FMAC4 soap_in_d__ResolveMatchType(struct soap *soap, const char *tag, struct d__ResolveMatchType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	size_t soap_flag_XAddrs = 1;
	size_t soap_flag_MetadataVersion = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct d__ResolveMatchType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_d__ResolveMatchType, sizeof(struct d__ResolveMatchType), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_d__ResolveMatchType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	
					soap_flag_wsa__EndpointReference--;
					continue;
				}
				if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
					if (soap_in_d__QNameListType(soap, "d:Types", &a->Types, "d:QNameListType"))
					{	
						soap_flag_Types--;
						continue;
					}
					if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTod__ScopesType(soap, "d:Scopes", &a->Scopes, "d:ScopesType"))
						{	
							soap_flag_Scopes--;
							continue;
						}
						if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
							if (soap_in_d__UriListType(soap, "d:XAddrs", &a->XAddrs, "d:UriListType"))
							{	
								soap_flag_XAddrs--;
								continue;
							}
							if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
								if (soap_in_unsignedInt(soap, "d:MetadataVersion", &a->MetadataVersion, "xsd:unsignedInt"))
								{	
									soap_flag_MetadataVersion--;
									continue;
								}
								if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
								{	
									if (a->__any == NULL)
									{	
										if (soap_blist___any == NULL)
											soap_blist___any = soap_new_block(soap);
										a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
										if (a->__any == NULL)
											return NULL;
										*a->__any = NULL;
									}
									if (soap_inliteral(soap, "-any", a->__any))
									{	
										a->__size++;
										a->__any = NULL;
										continue;
									}
								}
								if (soap->error == SOAP_TAG_MISMATCH)
									soap->error = soap_ignore_element(soap);
								if (soap->error == SOAP_NO_TAG)
									break;
								if (soap->error)
									return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct d__ResolveMatchType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_d__ResolveMatchType, 0, sizeof(struct d__ResolveMatchType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0 || soap_flag_XAddrs > 0 || soap_flag_MetadataVersion > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_d__ResolveMatchType(struct soap *soap, const struct d__ResolveMatchType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_d__ResolveMatchType);
	if (soap_out_d__ResolveMatchType(soap, tag?tag:"d:ResolveMatchType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__ResolveMatchType * SOAP_FMAC4 soap_get_d__ResolveMatchType(struct soap *soap, struct d__ResolveMatchType *p, const char *tag, const char *type)
{
	if ((p = soap_in_d__ResolveMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_d__ResolveMatchesType(struct soap *soap, struct d__ResolveMatchesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ResolveMatch = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_d__ResolveMatchesType(struct soap *soap, const struct d__ResolveMatchesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTod__ResolveMatchType(soap, &a->ResolveMatch);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_d__ResolveMatchesType(struct soap *soap, const char *tag, int id, const struct d__ResolveMatchesType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_d__ResolveMatchesType), type))
		return soap->error;
	if (soap_out_PointerTod__ResolveMatchType(soap, "d:ResolveMatch", -1, &a->ResolveMatch, ""))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct d__ResolveMatchesType * SOAP_FMAC4 soap_in_d__ResolveMatchesType(struct soap *soap, const char *tag, struct d__ResolveMatchesType *a, const char *type)
{
	size_t soap_flag_ResolveMatch = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct d__ResolveMatchesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_d__ResolveMatchesType, sizeof(struct d__ResolveMatchesType), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_d__ResolveMatchesType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResolveMatch && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTod__ResolveMatchType(soap, "d:ResolveMatch", &a->ResolveMatch, "d:ResolveMatchType"))
				{	
					soap_flag_ResolveMatch--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
				{	
					if (a->__any == NULL)
					{	
						if (soap_blist___any == NULL)
							soap_blist___any = soap_new_block(soap);
						a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
						if (a->__any == NULL)
							return NULL;
						*a->__any = NULL;
					}
					if (soap_inliteral(soap, "-any", a->__any))
					{	
						a->__size++;
						a->__any = NULL;
						continue;
					}
				}
				if (soap->error == SOAP_TAG_MISMATCH)
					soap->error = soap_ignore_element(soap);
				if (soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct d__ResolveMatchesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_d__ResolveMatchesType, 0, sizeof(struct d__ResolveMatchesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_d__ResolveMatchesType(struct soap *soap, const struct d__ResolveMatchesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_d__ResolveMatchesType);
	if (soap_out_d__ResolveMatchesType(soap, tag?tag:"d:ResolveMatchesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__ResolveMatchesType * SOAP_FMAC4 soap_get_d__ResolveMatchesType(struct soap *soap, struct d__ResolveMatchesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_d__ResolveMatchesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_d__ResolveType(struct soap *soap, struct d__ResolveType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_d__ResolveType(struct soap *soap, const struct d__ResolveType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_d__ResolveType(struct soap *soap, const char *tag, int id, const struct d__ResolveType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_d__ResolveType), type))
		return soap->error;
	soap_element_result(soap, "wsa:EndpointReference");
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct d__ResolveType * SOAP_FMAC4 soap_in_d__ResolveType(struct soap *soap, const char *tag, struct d__ResolveType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct d__ResolveType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_d__ResolveType, sizeof(struct d__ResolveType), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_d__ResolveType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	
					soap_flag_wsa__EndpointReference--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
				{	
					if (a->__any == NULL)
					{	
						if (soap_blist___any == NULL)
							soap_blist___any = soap_new_block(soap);
						a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
						if (a->__any == NULL)
							return NULL;
						*a->__any = NULL;
					}
					if (soap_inliteral(soap, "-any", a->__any))
					{	
						a->__size++;
						a->__any = NULL;
						continue;
					}
				}
				soap_check_result(soap, "wsa:EndpointReference");
				if (soap->error == SOAP_TAG_MISMATCH)
					soap->error = soap_ignore_element(soap);
				if (soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct d__ResolveType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_d__ResolveType, 0, sizeof(struct d__ResolveType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_d__ResolveType(struct soap *soap, const struct d__ResolveType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_d__ResolveType);
	if (soap_out_d__ResolveType(soap, tag?tag:"d:ResolveType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__ResolveType * SOAP_FMAC4 soap_get_d__ResolveType(struct soap *soap, struct d__ResolveType *p, const char *tag, const char *type)
{
	if ((p = soap_in_d__ResolveType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_d__ByeType(struct soap *soap, struct d__ByeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_default_d__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	soap_default_d__UriListType(soap, &a->XAddrs);
	a->MetadataVersion = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_d__ByeType(struct soap *soap, const struct d__ByeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_serialize_d__QNameListType(soap, &a->Types);
	soap_serialize_PointerTod__ScopesType(soap, &a->Scopes);
	soap_serialize_d__UriListType(soap, &a->XAddrs);
	soap_serialize_PointerTounsignedInt(soap, &a->MetadataVersion);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_d__ByeType(struct soap *soap, const char *tag, int id, const struct d__ByeType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_d__ByeType), type))
		return soap->error;
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	if (soap_out_d__QNameListType(soap, "d:Types", -1, &a->Types, ""))
		return soap->error;
	if (soap_out_PointerTod__ScopesType(soap, "d:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (soap_out_d__UriListType(soap, "d:XAddrs", -1, &a->XAddrs, ""))
		return soap->error;
	if (soap_out_PointerTounsignedInt(soap, "d:MetadataVersion", -1, &a->MetadataVersion, ""))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct d__ByeType * SOAP_FMAC4 soap_in_d__ByeType(struct soap *soap, const char *tag, struct d__ByeType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	size_t soap_flag_XAddrs = 1;
	size_t soap_flag_MetadataVersion = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct d__ByeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_d__ByeType, sizeof(struct d__ByeType), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_d__ByeType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	
					soap_flag_wsa__EndpointReference--;
					continue;
				}
				if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
					if (soap_in_d__QNameListType(soap, "d:Types", &a->Types, "d:QNameListType"))
					{	
						soap_flag_Types--;
						continue;
					}
					if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTod__ScopesType(soap, "d:Scopes", &a->Scopes, "d:ScopesType"))
						{	
							soap_flag_Scopes--;
							continue;
						}
						if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
							if (soap_in_d__UriListType(soap, "d:XAddrs", &a->XAddrs, "d:UriListType"))
							{	
								soap_flag_XAddrs--;
								continue;
							}
							if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
								if (soap_in_PointerTounsignedInt(soap, "d:MetadataVersion", &a->MetadataVersion, "xsd:unsignedInt"))
								{	
									soap_flag_MetadataVersion--;
									continue;
								}
								if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
								{	
									if (a->__any == NULL)
									{	
										if (soap_blist___any == NULL)
											soap_blist___any = soap_new_block(soap);
										a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
										if (a->__any == NULL)
											return NULL;
										*a->__any = NULL;
									}
									if (soap_inliteral(soap, "-any", a->__any))
									{	
										a->__size++;
										a->__any = NULL;
										continue;
									}
								}
								if (soap->error == SOAP_TAG_MISMATCH)
									soap->error = soap_ignore_element(soap);
								if (soap->error == SOAP_NO_TAG)
									break;
								if (soap->error)
									return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct d__ByeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_d__ByeType, 0, sizeof(struct d__ByeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_d__ByeType(struct soap *soap, const struct d__ByeType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_d__ByeType);
	if (soap_out_d__ByeType(soap, tag?tag:"d:ByeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__ByeType * SOAP_FMAC4 soap_get_d__ByeType(struct soap *soap, struct d__ByeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_d__ByeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}



SOAP_FMAC3 void SOAP_FMAC4 soap_default_d__HelloType(struct soap *soap, struct d__HelloType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_default_d__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	soap_default_d__UriListType(soap, &a->XAddrs);
	soap_default_unsignedInt(soap, &a->MetadataVersion);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_d__HelloType(struct soap *soap, const struct d__HelloType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_serialize_d__QNameListType(soap, &a->Types);
	soap_serialize_PointerTod__ScopesType(soap, &a->Scopes);
	soap_serialize_d__UriListType(soap, &a->XAddrs);
	soap_embedded(soap, &a->MetadataVersion, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_d__HelloType(struct soap *soap, const char *tag, int id, const struct d__HelloType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_d__HelloType), type))
		return soap->error;
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	if (soap_out_d__QNameListType(soap, "d:Types", -1, &a->Types, ""))
		return soap->error;
	if (soap_out_PointerTod__ScopesType(soap, "d:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (soap_out_d__UriListType(soap, "d:XAddrs", -1, &a->XAddrs, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "d:MetadataVersion", -1, &a->MetadataVersion, ""))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct d__HelloType * SOAP_FMAC4 soap_in_d__HelloType(struct soap *soap, const char *tag, struct d__HelloType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	size_t soap_flag_XAddrs = 1;
	size_t soap_flag_MetadataVersion = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct d__HelloType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_d__HelloType, sizeof(struct d__HelloType), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_d__HelloType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	
					soap_flag_wsa__EndpointReference--;
					continue;
				}
				if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
					if (soap_in_d__QNameListType(soap, "d:Types", &a->Types, "d:QNameListType"))
					{	
						soap_flag_Types--;
						continue;
					}
					if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTod__ScopesType(soap, "d:Scopes", &a->Scopes, "d:ScopesType"))
						{	
							soap_flag_Scopes--;
							continue;
						}
						if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
							if (soap_in_d__UriListType(soap, "d:XAddrs", &a->XAddrs, "d:UriListType"))
							{	
								soap_flag_XAddrs--;
								continue;
							}
							if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
								if (soap_in_unsignedInt(soap, "d:MetadataVersion", &a->MetadataVersion, "xsd:unsignedInt"))
								{	
									soap_flag_MetadataVersion--;
									continue;
								}
								if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
								{	
									if (a->__any == NULL)
									{	
										if (soap_blist___any == NULL)
											soap_blist___any = soap_new_block(soap);
										a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
										if (a->__any == NULL)
											return NULL;
										*a->__any = NULL;
									}
									if (soap_inliteral(soap, "-any", a->__any))
									{	
										a->__size++;
										a->__any = NULL;
										continue;
									}
								}
								if (soap->error == SOAP_TAG_MISMATCH)
									soap->error = soap_ignore_element(soap);
								if (soap->error == SOAP_NO_TAG)
									break;
								if (soap->error)
									return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct d__HelloType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_d__HelloType, 0, sizeof(struct d__HelloType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0 || soap_flag_MetadataVersion > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_d__HelloType(struct soap *soap, const struct d__HelloType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_d__HelloType);
	if (soap_out_d__HelloType(soap, tag?tag:"d:HelloType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__HelloType * SOAP_FMAC4 soap_get_d__HelloType(struct soap *soap, struct d__HelloType *p, const char *tag, const char *type)
{
	if ((p = soap_in_d__HelloType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTod__ByeType(struct soap *soap, struct d__ByeType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_d__ByeType))
		soap_serialize_d__ByeType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTod__ByeType(struct soap *soap, const char *tag, int id, struct d__ByeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_d__ByeType);
	if (id < 0)
		return soap->error;
	return soap_out_d__ByeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct d__ByeType ** SOAP_FMAC4 soap_in_PointerTod__ByeType(struct soap *soap, const char *tag, struct d__ByeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct d__ByeType **)soap_malloc(soap, sizeof(struct d__ByeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_d__ByeType(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	
		a = (struct d__ByeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_d__ByeType, sizeof(struct d__ByeType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTod__ByeType(struct soap *soap, struct d__ByeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTod__ByeType);
	if (soap_out_PointerTod__ByeType(soap, tag?tag:"d:ByeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__ByeType ** SOAP_FMAC4 soap_get_PointerTod__ByeType(struct soap *soap, struct d__ByeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTod__ByeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTod__ResolveType(struct soap *soap, struct d__ResolveType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_d__ResolveType))
		soap_serialize_d__ResolveType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTod__ResolveType(struct soap *soap, const char *tag, int id, struct d__ResolveType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_d__ResolveType);
	if (id < 0)
		return soap->error;
	return soap_out_d__ResolveType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct d__ResolveType ** SOAP_FMAC4 soap_in_PointerTod__ResolveType(struct soap *soap, const char *tag, struct d__ResolveType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct d__ResolveType **)soap_malloc(soap, sizeof(struct d__ResolveType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_d__ResolveType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct d__ResolveType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_d__ResolveType, sizeof(struct d__ResolveType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTod__ResolveType(struct soap *soap, struct d__ResolveType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTod__ResolveType);
	if (soap_out_PointerTod__ResolveType(soap, tag?tag:"d:ResolveType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__ResolveType ** SOAP_FMAC4 soap_get_PointerTod__ResolveType(struct soap *soap, struct d__ResolveType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTod__ResolveType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTod__HelloType(struct soap *soap, struct d__HelloType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_d__HelloType))
		soap_serialize_d__HelloType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTod__HelloType(struct soap *soap, const char *tag, int id, struct d__HelloType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_d__HelloType);
	if (id < 0)
		return soap->error;
	return soap_out_d__HelloType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct d__HelloType ** SOAP_FMAC4 soap_in_PointerTod__HelloType(struct soap *soap, const char *tag, struct d__HelloType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct d__HelloType **)soap_malloc(soap, sizeof(struct d__HelloType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_d__HelloType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct d__HelloType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_d__HelloType, sizeof(struct d__HelloType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTod__HelloType(struct soap *soap, struct d__HelloType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTod__HelloType);
	if (soap_out_PointerTod__HelloType(soap, tag?tag:"d:HelloType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__HelloType ** SOAP_FMAC4 soap_get_PointerTod__HelloType(struct soap *soap, struct d__HelloType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTod__HelloType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTod__ResolveMatchType(struct soap *soap, struct d__ResolveMatchType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_d__ResolveMatchType))
		soap_serialize_d__ResolveMatchType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTod__ResolveMatchType(struct soap *soap, const char *tag, int id, struct d__ResolveMatchType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_d__ResolveMatchType);
	if (id < 0)
		return soap->error;
	return soap_out_d__ResolveMatchType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct d__ResolveMatchType ** SOAP_FMAC4 soap_in_PointerTod__ResolveMatchType(struct soap *soap, const char *tag, struct d__ResolveMatchType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct d__ResolveMatchType **)soap_malloc(soap, sizeof(struct d__ResolveMatchType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_d__ResolveMatchType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct d__ResolveMatchType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_d__ResolveMatchType, sizeof(struct d__ResolveMatchType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTod__ResolveMatchType(struct soap *soap, struct d__ResolveMatchType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTod__ResolveMatchType);
	if (soap_out_PointerTod__ResolveMatchType(soap, tag?tag:"d:ResolveMatchType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__ResolveMatchType ** SOAP_FMAC4 soap_get_PointerTod__ResolveMatchType(struct soap *soap, struct d__ResolveMatchType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTod__ResolveMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

//device system management
SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CapabilityCategory(struct soap *soap, enum tt__CapabilityCategory *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__CapabilityCategory
	*a = SOAP_DEFAULT_tt__CapabilityCategory;
#else
	*a = (enum tt__CapabilityCategory)0;
#endif
}

static const struct soap_code_map soap_codes_tt__CapabilityCategory[] =
{	
	{ (long)tt__CapabilityCategory__All, "All" },
	{ (long)tt__CapabilityCategory__Analytics, "Analytics" },
	{ (long)tt__CapabilityCategory__Device, "Device" },
	{ (long)tt__CapabilityCategory__Events, "Events" },
	{ (long)tt__CapabilityCategory__Imaging, "Imaging" },
	{ (long)tt__CapabilityCategory__Media, "Media" },
	{ (long)tt__CapabilityCategory__PTZ, "PTZ" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__CapabilityCategory2s(struct soap *soap, enum tt__CapabilityCategory n)
{	
	const char *s = soap_code_str(soap_codes_tt__CapabilityCategory, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CapabilityCategory(struct soap *soap, const char *tag, int id, const enum tt__CapabilityCategory *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CapabilityCategory), type) || soap_send(soap, soap_tt__CapabilityCategory2s(soap, *a)))
	return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__CapabilityCategory(struct soap *soap, const char *s, enum tt__CapabilityCategory *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__CapabilityCategory, s);
	if (map)
		*a = (enum tt__CapabilityCategory)map->code;
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__CapabilityCategory)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__CapabilityCategory * SOAP_FMAC4 soap_in_tt__CapabilityCategory(struct soap *soap, const char *tag, enum tt__CapabilityCategory *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	return NULL;
	a = (enum tt__CapabilityCategory *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CapabilityCategory, sizeof(enum tt__CapabilityCategory), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	
		if (!a || soap_s2tt__CapabilityCategory(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (enum tt__CapabilityCategory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CapabilityCategory, 0, sizeof(enum tt__CapabilityCategory), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CapabilityCategory(struct soap *soap, const enum tt__CapabilityCategory *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__CapabilityCategory);
	if (soap_out_tt__CapabilityCategory(soap, tag?tag:"tt:CapabilityCategory", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__CapabilityCategory * SOAP_FMAC4 soap_get_tt__CapabilityCategory(struct soap *soap, enum tt__CapabilityCategory *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CapabilityCategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, struct tt__DeviceCapabilitiesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DeviceCapabilitiesExtension))
		soap_serialize_tt__DeviceCapabilitiesExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct tt__DeviceCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DeviceCapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DeviceCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DeviceCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__DeviceCapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__DeviceCapabilitiesExtension **)soap_malloc(soap, sizeof(struct tt__DeviceCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__DeviceCapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__DeviceCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DeviceCapabilitiesExtension, sizeof(struct tt__DeviceCapabilitiesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, struct tt__DeviceCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__DeviceCapabilitiesExtension);
	if (soap_out_PointerTott__DeviceCapabilitiesExtension(soap, tag?tag:"tt:DeviceCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DeviceCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, struct tt__DeviceCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DeviceCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DeviceCapabilitiesExtension(struct soap *soap, struct tt__DeviceCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DeviceCapabilitiesExtension(struct soap *soap, const struct tt__DeviceCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct tt__DeviceCapabilitiesExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DeviceCapabilitiesExtension), type))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DeviceCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__DeviceCapabilitiesExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DeviceCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceCapabilitiesExtension, sizeof(struct tt__DeviceCapabilitiesExtension), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__DeviceCapabilitiesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__DeviceCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceCapabilitiesExtension, 0, sizeof(struct tt__DeviceCapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DeviceCapabilitiesExtension(struct soap *soap, const struct tt__DeviceCapabilitiesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__DeviceCapabilitiesExtension);
	if (soap_out_tt__DeviceCapabilitiesExtension(soap, tag?tag:"tt:DeviceCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DeviceCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__DeviceCapabilitiesExtension(struct soap *soap, struct tt__DeviceCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkCapabilitiesExtension2(struct soap *soap, struct tt__NetworkCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkCapabilitiesExtension2(struct soap *soap, const struct tt__NetworkCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkCapabilitiesExtension2(struct soap *soap, const char *tag, int id, const struct tt__NetworkCapabilitiesExtension2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension2), type))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__NetworkCapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__NetworkCapabilitiesExtension2 *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkCapabilitiesExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, sizeof(struct tt__NetworkCapabilitiesExtension2), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__NetworkCapabilitiesExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
			{	
				if (soap_blist___any == NULL)
					soap_blist___any = soap_new_block(soap);
				a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
				if (a->__any == NULL)
					return NULL;
				*a->__any = NULL;
			}
			if (soap_inliteral(soap, "-any", a->__any))
			{	
				a->__size++;
				a->__any = NULL;
				continue;
			}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__NetworkCapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, 0, sizeof(struct tt__NetworkCapabilitiesExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkCapabilitiesExtension2(struct soap *soap, const struct tt__NetworkCapabilitiesExtension2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkCapabilitiesExtension2);
	if (soap_out_tt__NetworkCapabilitiesExtension2(soap, tag?tag:"tt:NetworkCapabilitiesExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__NetworkCapabilitiesExtension2(struct soap *soap, struct tt__NetworkCapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkCapabilitiesExtension2(struct soap *soap, struct tt__NetworkCapabilitiesExtension2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkCapabilitiesExtension2))
		soap_serialize_tt__NetworkCapabilitiesExtension2(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkCapabilitiesExtension2(struct soap *soap, const char *tag, int id, struct tt__NetworkCapabilitiesExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkCapabilitiesExtension2);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkCapabilitiesExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension2 ** SOAP_FMAC4 soap_in_PointerTott__NetworkCapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__NetworkCapabilitiesExtension2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkCapabilitiesExtension2 **)soap_malloc(soap, sizeof(struct tt__NetworkCapabilitiesExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_tt__NetworkCapabilitiesExtension2(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct tt__NetworkCapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, sizeof(struct tt__NetworkCapabilitiesExtension2), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkCapabilitiesExtension2(struct soap *soap, struct tt__NetworkCapabilitiesExtension2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkCapabilitiesExtension2);
	if (soap_out_PointerTott__NetworkCapabilitiesExtension2(soap, tag?tag:"tt:NetworkCapabilitiesExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension2 ** SOAP_FMAC4 soap_get_PointerTott__NetworkCapabilitiesExtension2(struct soap *soap, struct tt__NetworkCapabilitiesExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, struct tt__NetworkCapabilitiesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkCapabilitiesExtension))
		soap_serialize_tt__NetworkCapabilitiesExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct tt__NetworkCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkCapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__NetworkCapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkCapabilitiesExtension **)soap_malloc(soap, sizeof(struct tt__NetworkCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_tt__NetworkCapabilitiesExtension(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct tt__NetworkCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkCapabilitiesExtension, sizeof(struct tt__NetworkCapabilitiesExtension), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, struct tt__NetworkCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkCapabilitiesExtension);
	if (soap_out_PointerTott__NetworkCapabilitiesExtension(soap, tag?tag:"tt:NetworkCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, struct tt__NetworkCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkCapabilitiesExtension(struct soap *soap, struct tt__NetworkCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->Dot11Configuration = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkCapabilitiesExtension(struct soap *soap, const struct tt__NetworkCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean_(soap, &a->Dot11Configuration);
	soap_serialize_PointerTott__NetworkCapabilitiesExtension2(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct tt__NetworkCapabilitiesExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension), type))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	if (soap_out_PointerToxsd__boolean_(soap, "tt:Dot11Configuration", -1, &a->Dot11Configuration, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkCapabilitiesExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__NetworkCapabilitiesExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_Dot11Configuration = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension, sizeof(struct tt__NetworkCapabilitiesExtension), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__NetworkCapabilitiesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap_flag_Dot11Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:Dot11Configuration", &a->Dot11Configuration, "xsd:boolean"))
				{	
					soap_flag_Dot11Configuration--;
					continue;
				}
				if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__NetworkCapabilitiesExtension2(soap, "tt:Extension", &a->Extension, "tt:NetworkCapabilitiesExtension2"))
					{	
						soap_flag_Extension--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH)
						soap->error = soap_ignore_element(soap);
					if (soap->error == SOAP_NO_TAG)
						break;
					if (soap->error)
						return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__NetworkCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkCapabilitiesExtension, 0, sizeof(struct tt__NetworkCapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkCapabilitiesExtension(struct soap *soap, const struct tt__NetworkCapabilitiesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkCapabilitiesExtension);
	if (soap_out_tt__NetworkCapabilitiesExtension(soap, tag?tag:"tt:NetworkCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__NetworkCapabilitiesExtension(struct soap *soap, struct tt__NetworkCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkCapabilities(struct soap *soap, struct tt__NetworkCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->IPFilter = NULL;
	a->ZeroConfiguration = NULL;
	a->IPVersion6 = NULL;
	a->DynDNS = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkCapabilities(struct soap *soap, const struct tt__NetworkCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean_(soap, &a->IPFilter);
	soap_serialize_PointerToxsd__boolean_(soap, &a->ZeroConfiguration);
	soap_serialize_PointerToxsd__boolean_(soap, &a->IPVersion6);
	soap_serialize_PointerToxsd__boolean_(soap, &a->DynDNS);
	soap_serialize_PointerTott__NetworkCapabilitiesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkCapabilities(struct soap *soap, const char *tag, int id, const struct tt__NetworkCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkCapabilities), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:IPFilter", -1, &a->IPFilter, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:ZeroConfiguration", -1, &a->ZeroConfiguration, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:IPVersion6", -1, &a->IPVersion6, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:DynDNS", -1, &a->DynDNS, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkCapabilitiesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkCapabilities * SOAP_FMAC4 soap_in_tt__NetworkCapabilities(struct soap *soap, const char *tag, struct tt__NetworkCapabilities *a, const char *type)
{
	size_t soap_flag_IPFilter = 1;
	size_t soap_flag_ZeroConfiguration = 1;
	size_t soap_flag_IPVersion6 = 1;
	size_t soap_flag_DynDNS = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkCapabilities, sizeof(struct tt__NetworkCapabilities), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__NetworkCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPFilter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:IPFilter", &a->IPFilter, "xsd:boolean"))
				{	
					soap_flag_IPFilter--;
					continue;
				}
				if (soap_flag_ZeroConfiguration && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerToxsd__boolean_(soap, "tt:ZeroConfiguration", &a->ZeroConfiguration, "xsd:boolean"))
					{	
						soap_flag_ZeroConfiguration--;
						continue;
					}
					if (soap_flag_IPVersion6 && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerToxsd__boolean_(soap, "tt:IPVersion6", &a->IPVersion6, "xsd:boolean"))
						{	
							soap_flag_IPVersion6--;
							continue;
						}
						if (soap_flag_DynDNS && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_PointerToxsd__boolean_(soap, "tt:DynDNS", &a->DynDNS, "xsd:boolean"))
							{	
								soap_flag_DynDNS--;
								continue;
							}
							if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
								if (soap_in_PointerTott__NetworkCapabilitiesExtension(soap, "tt:Extension", &a->Extension, "tt:NetworkCapabilitiesExtension"))
								{	
									soap_flag_Extension--;
									continue;
								}
								if (soap->error == SOAP_TAG_MISMATCH)
									soap->error = soap_ignore_element(soap);
								if (soap->error == SOAP_NO_TAG)
									break;
								if (soap->error)
									return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__NetworkCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkCapabilities, 0, sizeof(struct tt__NetworkCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkCapabilities(struct soap *soap, const struct tt__NetworkCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkCapabilities);
	if (soap_out_tt__NetworkCapabilities(soap, tag?tag:"tt:NetworkCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkCapabilities * SOAP_FMAC4 soap_get_tt__NetworkCapabilities(struct soap *soap, struct tt__NetworkCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkCapabilities(struct soap *soap, struct tt__NetworkCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkCapabilities))
		soap_serialize_tt__NetworkCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkCapabilities(struct soap *soap, const char *tag, int id, struct tt__NetworkCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkCapabilities ** SOAP_FMAC4 soap_in_PointerTott__NetworkCapabilities(struct soap *soap, const char *tag, struct tt__NetworkCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__NetworkCapabilities **)soap_malloc(soap, sizeof(struct tt__NetworkCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__NetworkCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkCapabilities, sizeof(struct tt__NetworkCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkCapabilities(struct soap *soap, struct tt__NetworkCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkCapabilities);
	if (soap_out_PointerTott__NetworkCapabilities(soap, tag?tag:"tt:NetworkCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkCapabilities ** SOAP_FMAC4 soap_get_PointerTott__NetworkCapabilities(struct soap *soap, struct tt__NetworkCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemCapabilitiesExtension2(struct soap *soap, struct tt__SystemCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemCapabilitiesExtension2(struct soap *soap, const struct tt__SystemCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemCapabilitiesExtension2(struct soap *soap, const char *tag, int id, const struct tt__SystemCapabilitiesExtension2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension2), type))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__SystemCapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__SystemCapabilitiesExtension2 *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SystemCapabilitiesExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension2, sizeof(struct tt__SystemCapabilitiesExtension2), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__SystemCapabilitiesExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__SystemCapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemCapabilitiesExtension2, 0, sizeof(struct tt__SystemCapabilitiesExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemCapabilitiesExtension2(struct soap *soap, const struct tt__SystemCapabilitiesExtension2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SystemCapabilitiesExtension2);
	if (soap_out_tt__SystemCapabilitiesExtension2(soap, tag?tag:"tt:SystemCapabilitiesExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__SystemCapabilitiesExtension2(struct soap *soap, struct tt__SystemCapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemCapabilitiesExtension2(struct soap *soap, struct tt__SystemCapabilitiesExtension2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemCapabilitiesExtension2))
		soap_serialize_tt__SystemCapabilitiesExtension2(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemCapabilitiesExtension2(struct soap *soap, const char *tag, int id, struct tt__SystemCapabilitiesExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemCapabilitiesExtension2);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SystemCapabilitiesExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension2 ** SOAP_FMAC4 soap_in_PointerTott__SystemCapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__SystemCapabilitiesExtension2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SystemCapabilitiesExtension2 **)soap_malloc(soap, sizeof(struct tt__SystemCapabilitiesExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_tt__SystemCapabilitiesExtension2(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct tt__SystemCapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemCapabilitiesExtension2, sizeof(struct tt__SystemCapabilitiesExtension2), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemCapabilitiesExtension2(struct soap *soap, struct tt__SystemCapabilitiesExtension2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SystemCapabilitiesExtension2);
	if (soap_out_PointerTott__SystemCapabilitiesExtension2(soap, tag?tag:"tt:SystemCapabilitiesExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension2 ** SOAP_FMAC4 soap_get_PointerTott__SystemCapabilitiesExtension2(struct soap *soap, struct tt__SystemCapabilitiesExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemCapabilitiesExtension(struct soap *soap, struct tt__SystemCapabilitiesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemCapabilitiesExtension))
		soap_serialize_tt__SystemCapabilitiesExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct tt__SystemCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemCapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SystemCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__SystemCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__SystemCapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__SystemCapabilitiesExtension **)soap_malloc(soap, sizeof(struct tt__SystemCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);	
		if (!(*a = soap_in_tt__SystemCapabilitiesExtension(soap, tag, *a, type)))	
			return NULL;
	}
	else
	{	
		a = (struct tt__SystemCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemCapabilitiesExtension, sizeof(struct tt__SystemCapabilitiesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemCapabilitiesExtension(struct soap *soap, struct tt__SystemCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SystemCapabilitiesExtension);
	if (soap_out_PointerTott__SystemCapabilitiesExtension(soap, tag?tag:"tt:SystemCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__SystemCapabilitiesExtension(struct soap *soap, struct tt__SystemCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemCapabilitiesExtension(struct soap *soap, struct tt__SystemCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->HttpFirmwareUpgrade = NULL;
	a->HttpSystemBackup = NULL;
	a->HttpSystemLogging = NULL;
	a->HttpSupportInformation = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemCapabilitiesExtension(struct soap *soap, const struct tt__SystemCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean_(soap, &a->HttpFirmwareUpgrade);
	soap_serialize_PointerToxsd__boolean_(soap, &a->HttpSystemBackup);
	soap_serialize_PointerToxsd__boolean_(soap, &a->HttpSystemLogging);
	soap_serialize_PointerToxsd__boolean_(soap, &a->HttpSupportInformation);
	soap_serialize_PointerTott__SystemCapabilitiesExtension2(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct tt__SystemCapabilitiesExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension), type))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	if (soap_out_PointerToxsd__boolean_(soap, "tt:HttpFirmwareUpgrade", -1, &a->HttpFirmwareUpgrade, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:HttpSystemBackup", -1, &a->HttpSystemBackup, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:HttpSystemLogging", -1, &a->HttpSystemLogging, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:HttpSupportInformation", -1, &a->HttpSupportInformation, ""))
		return soap->error;
	if (soap_out_PointerTott__SystemCapabilitiesExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__SystemCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__SystemCapabilitiesExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_HttpFirmwareUpgrade = 1;
	size_t soap_flag_HttpSystemBackup = 1;
	size_t soap_flag_HttpSystemLogging = 1;
	size_t soap_flag_HttpSupportInformation = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SystemCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension, sizeof(struct tt__SystemCapabilitiesExtension), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__SystemCapabilitiesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap_flag_HttpFirmwareUpgrade && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:HttpFirmwareUpgrade", &a->HttpFirmwareUpgrade, "xsd:boolean"))
				{	
					soap_flag_HttpFirmwareUpgrade--;
					continue;
				}
				if (soap_flag_HttpSystemBackup && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerToxsd__boolean_(soap, "tt:HttpSystemBackup", &a->HttpSystemBackup, "xsd:boolean"))
					{	
						soap_flag_HttpSystemBackup--;
						continue;
					}
					if (soap_flag_HttpSystemLogging && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerToxsd__boolean_(soap, "tt:HttpSystemLogging", &a->HttpSystemLogging, "xsd:boolean"))
						{	
							soap_flag_HttpSystemLogging--;
							continue;
						}
						if (soap_flag_HttpSupportInformation && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_PointerToxsd__boolean_(soap, "tt:HttpSupportInformation", &a->HttpSupportInformation, "xsd:boolean"))
							{	
								soap_flag_HttpSupportInformation--;
								continue;
							}
							if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
								if (soap_in_PointerTott__SystemCapabilitiesExtension2(soap, "tt:Extension", &a->Extension, "tt:SystemCapabilitiesExtension2"))
								{	
									soap_flag_Extension--;
									continue;
								}
								if (soap->error == SOAP_TAG_MISMATCH)
									soap->error = soap_ignore_element(soap);
								if (soap->error == SOAP_NO_TAG)
									break;
								if (soap->error)
									return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__SystemCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemCapabilitiesExtension, 0, sizeof(struct tt__SystemCapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemCapabilitiesExtension(struct soap *soap, const struct tt__SystemCapabilitiesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SystemCapabilitiesExtension);
	if (soap_out_tt__SystemCapabilitiesExtension(soap, tag?tag:"tt:SystemCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__SystemCapabilitiesExtension(struct soap *soap, struct tt__SystemCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OnvifVersion(struct soap *soap, struct tt__OnvifVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Major);
	soap_default_int(soap, &a->Minor);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OnvifVersion(struct soap *soap, const struct tt__OnvifVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Major, SOAP_TYPE_int);
	soap_embedded(soap, &a->Minor, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OnvifVersion(struct soap *soap, const char *tag, int id, const struct tt__OnvifVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OnvifVersion), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Major", -1, &a->Major, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Minor", -1, &a->Minor, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OnvifVersion * SOAP_FMAC4 soap_in_tt__OnvifVersion(struct soap *soap, const char *tag, struct tt__OnvifVersion *a, const char *type)
{
	size_t soap_flag_Major = 1;
	size_t soap_flag_Minor = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__OnvifVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OnvifVersion, sizeof(struct tt__OnvifVersion), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__OnvifVersion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Major && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Major", &a->Major, "xsd:int"))
				{	
					soap_flag_Major--;
					continue;
				}
				if (soap_flag_Minor && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_int(soap, "tt:Minor", &a->Minor, "xsd:int"))
					{	
						soap_flag_Minor--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH)
						soap->error = soap_ignore_element(soap);
					if (soap->error == SOAP_NO_TAG)
						break;
					if (soap->error)
						return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__OnvifVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OnvifVersion, 0, sizeof(struct tt__OnvifVersion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Major > 0 || soap_flag_Minor > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OnvifVersion(struct soap *soap, const struct tt__OnvifVersion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__OnvifVersion);
	if (soap_out_tt__OnvifVersion(soap, tag?tag:"tt:OnvifVersion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OnvifVersion * SOAP_FMAC4 soap_get_tt__OnvifVersion(struct soap *soap, struct tt__OnvifVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OnvifVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemCapabilities(struct soap *soap, struct tt__SystemCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->DiscoveryResolve);
	soap_default_xsd__boolean_(soap, &a->DiscoveryBye);
	soap_default_xsd__boolean_(soap, &a->RemoteDiscovery);
	soap_default_xsd__boolean_(soap, &a->SystemBackup);
	soap_default_xsd__boolean_(soap, &a->SystemLogging);
	soap_default_xsd__boolean_(soap, &a->FirmwareUpgrade);
	a->__sizeSupportedVersions = 0;
	a->SupportedVersions = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemCapabilities(struct soap *soap, const struct tt__SystemCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->DiscoveryResolve, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->DiscoveryBye, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->RemoteDiscovery, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->SystemBackup, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->SystemLogging, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->FirmwareUpgrade, SOAP_TYPE_xsd__boolean_);
	if (a->SupportedVersions)
	{	
		int i;
		for (i = 0; i < a->__sizeSupportedVersions; i++)
		{
			soap_embedded(soap, a->SupportedVersions + i, SOAP_TYPE_tt__OnvifVersion);
			soap_serialize_tt__OnvifVersion(soap, a->SupportedVersions + i);
		}
	}
	soap_serialize_PointerTott__SystemCapabilitiesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemCapabilities(struct soap *soap, const char *tag, int id, const struct tt__SystemCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemCapabilities), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:DiscoveryResolve", -1, &a->DiscoveryResolve, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:DiscoveryBye", -1, &a->DiscoveryBye, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:RemoteDiscovery", -1, &a->RemoteDiscovery, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:SystemBackup", -1, &a->SystemBackup, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:SystemLogging", -1, &a->SystemLogging, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:FirmwareUpgrade", -1, &a->FirmwareUpgrade, ""))
		return soap->error;
	if (a->SupportedVersions)
	{	
		int i;
		for (i = 0; i < a->__sizeSupportedVersions; i++)
			if (soap_out_tt__OnvifVersion(soap, "tt:SupportedVersions", -1, a->SupportedVersions + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__SystemCapabilitiesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemCapabilities * SOAP_FMAC4 soap_in_tt__SystemCapabilities(struct soap *soap, const char *tag, struct tt__SystemCapabilities *a, const char *type)
{
	size_t soap_flag_DiscoveryResolve = 1;
	size_t soap_flag_DiscoveryBye = 1;
	size_t soap_flag_RemoteDiscovery = 1;
	size_t soap_flag_SystemBackup = 1;
	size_t soap_flag_SystemLogging = 1;
	size_t soap_flag_FirmwareUpgrade = 1;
	struct soap_blist *soap_blist_SupportedVersions = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SystemCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemCapabilities, sizeof(struct tt__SystemCapabilities), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__SystemCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DiscoveryResolve && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:DiscoveryResolve", &a->DiscoveryResolve, "xsd:boolean"))
				{	
					soap_flag_DiscoveryResolve--;
					continue;
				}
				if (soap_flag_DiscoveryBye && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_xsd__boolean_(soap, "tt:DiscoveryBye", &a->DiscoveryBye, "xsd:boolean"))
					{	
						soap_flag_DiscoveryBye--;
						continue;
					}
					if (soap_flag_RemoteDiscovery && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_xsd__boolean_(soap, "tt:RemoteDiscovery", &a->RemoteDiscovery, "xsd:boolean"))
						{	
							soap_flag_RemoteDiscovery--;
							continue;
						}
						if (soap_flag_SystemBackup && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_xsd__boolean_(soap, "tt:SystemBackup", &a->SystemBackup, "xsd:boolean"))
							{	
								soap_flag_SystemBackup--;
								continue;
							}
							if (soap_flag_SystemLogging && soap->error == SOAP_TAG_MISMATCH)
								if (soap_in_xsd__boolean_(soap, "tt:SystemLogging", &a->SystemLogging, "xsd:boolean"))
								{	
									soap_flag_SystemLogging--;
									continue;
								}
								if (soap_flag_FirmwareUpgrade && soap->error == SOAP_TAG_MISMATCH)
									if (soap_in_xsd__boolean_(soap, "tt:FirmwareUpgrade", &a->FirmwareUpgrade, "xsd:boolean"))
									{	
										soap_flag_FirmwareUpgrade--;
										continue;
									}
									if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SupportedVersions", 1, NULL))
									{	
										if (a->SupportedVersions == NULL)
										{	
											if (soap_blist_SupportedVersions == NULL)
												soap_blist_SupportedVersions = soap_new_block(soap);
											a->SupportedVersions = (struct tt__OnvifVersion *)soap_push_block(soap, soap_blist_SupportedVersions, sizeof(struct tt__OnvifVersion));
											if (a->SupportedVersions == NULL)
												return NULL;
											soap_default_tt__OnvifVersion(soap, a->SupportedVersions);
										}
										soap_revert(soap);
										if (soap_in_tt__OnvifVersion(soap, "tt:SupportedVersions", a->SupportedVersions, "tt:OnvifVersion"))
										{	
											a->__sizeSupportedVersions++;
											a->SupportedVersions = NULL;
											continue;
										}
									}
									if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
										if (soap_in_PointerTott__SystemCapabilitiesExtension(soap, "tt:Extension", &a->Extension, "tt:SystemCapabilitiesExtension"))
										{	
											soap_flag_Extension--;
											continue;
										}
										if (soap->error == SOAP_TAG_MISMATCH)
											soap->error = soap_ignore_element(soap);
										if (soap->error == SOAP_NO_TAG)
											break;
										if (soap->error)
											return NULL;
		}
		if (a->SupportedVersions)
			soap_pop_block(soap, soap_blist_SupportedVersions);
		if (a->__sizeSupportedVersions)
			a->SupportedVersions = (struct tt__OnvifVersion *)soap_save_block(soap, soap_blist_SupportedVersions, NULL, 1);
		else
		{	
			a->SupportedVersions = NULL;
			if (soap_blist_SupportedVersions)
				soap_end_block(soap, soap_blist_SupportedVersions);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__SystemCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemCapabilities, 0, sizeof(struct tt__SystemCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DiscoveryResolve > 0 || soap_flag_DiscoveryBye > 0 || soap_flag_RemoteDiscovery > 0 || soap_flag_SystemBackup > 0 || soap_flag_SystemLogging > 0 || soap_flag_FirmwareUpgrade > 0 || a->__sizeSupportedVersions < 1))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemCapabilities(struct soap *soap, const struct tt__SystemCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SystemCapabilities);
	if (soap_out_tt__SystemCapabilities(soap, tag?tag:"tt:SystemCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemCapabilities * SOAP_FMAC4 soap_get_tt__SystemCapabilities(struct soap *soap, struct tt__SystemCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemCapabilities(struct soap *soap, struct tt__SystemCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemCapabilities))
		soap_serialize_tt__SystemCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemCapabilities(struct soap *soap, const char *tag, int id, struct tt__SystemCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SystemCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SystemCapabilities ** SOAP_FMAC4 soap_in_PointerTott__SystemCapabilities(struct soap *soap, const char *tag, struct tt__SystemCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__SystemCapabilities **)soap_malloc(soap, sizeof(struct tt__SystemCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__SystemCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__SystemCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemCapabilities, sizeof(struct tt__SystemCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemCapabilities(struct soap *soap, struct tt__SystemCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SystemCapabilities);
	if (soap_out_PointerTott__SystemCapabilities(soap, tag?tag:"tt:SystemCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemCapabilities ** SOAP_FMAC4 soap_get_PointerTott__SystemCapabilities(struct soap *soap, struct tt__SystemCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IOCapabilitiesExtension2(struct soap *soap, struct tt__IOCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IOCapabilitiesExtension2(struct soap *soap, const struct tt__IOCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IOCapabilitiesExtension2(struct soap *soap, const char *tag, int id, const struct tt__IOCapabilitiesExtension2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IOCapabilitiesExtension2), type))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IOCapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__IOCapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__IOCapabilitiesExtension2 *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IOCapabilitiesExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IOCapabilitiesExtension2, sizeof(struct tt__IOCapabilitiesExtension2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IOCapabilitiesExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__IOCapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IOCapabilitiesExtension2, 0, sizeof(struct tt__IOCapabilitiesExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IOCapabilitiesExtension2(struct soap *soap, const struct tt__IOCapabilitiesExtension2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IOCapabilitiesExtension2);
	if (soap_out_tt__IOCapabilitiesExtension2(soap, tag?tag:"tt:IOCapabilitiesExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IOCapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__IOCapabilitiesExtension2(struct soap *soap, struct tt__IOCapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IOCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IOCapabilitiesExtension2(struct soap *soap, struct tt__IOCapabilitiesExtension2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IOCapabilitiesExtension2))
		soap_serialize_tt__IOCapabilitiesExtension2(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IOCapabilitiesExtension2(struct soap *soap, const char *tag, int id, struct tt__IOCapabilitiesExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IOCapabilitiesExtension2);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IOCapabilitiesExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IOCapabilitiesExtension2 ** SOAP_FMAC4 soap_in_PointerTott__IOCapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__IOCapabilitiesExtension2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__IOCapabilitiesExtension2 **)soap_malloc(soap, sizeof(struct tt__IOCapabilitiesExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__IOCapabilitiesExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__IOCapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IOCapabilitiesExtension2, sizeof(struct tt__IOCapabilitiesExtension2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IOCapabilitiesExtension2(struct soap *soap, struct tt__IOCapabilitiesExtension2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IOCapabilitiesExtension2);
	if (soap_out_PointerTott__IOCapabilitiesExtension2(soap, tag?tag:"tt:IOCapabilitiesExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IOCapabilitiesExtension2 ** SOAP_FMAC4 soap_get_PointerTott__IOCapabilitiesExtension2(struct soap *soap, struct tt__IOCapabilitiesExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IOCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IOCapabilitiesExtension(struct soap *soap, struct tt__IOCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->Auxiliary = NULL;
	a->__sizeAuxiliaryCommands = 0;
	a->AuxiliaryCommands = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IOCapabilitiesExtension(struct soap *soap, const struct tt__IOCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean_(soap, &a->Auxiliary);
	if (a->AuxiliaryCommands)
	{	
		int i;
		for (i = 0; i < a->__sizeAuxiliaryCommands; i++)
		{
			soap_serialize_tt__AuxiliaryData(soap, a->AuxiliaryCommands + i);
		}
	}
	soap_serialize_PointerTott__IOCapabilitiesExtension2(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IOCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct tt__IOCapabilitiesExtension *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IOCapabilitiesExtension), type))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	if (soap_out_PointerToxsd__boolean_(soap, "tt:Auxiliary", -1, &a->Auxiliary, ""))
		return soap->error;
	if (a->AuxiliaryCommands)
	{	
		int i;
		for (i = 0; i < a->__sizeAuxiliaryCommands; i++)
			if (soap_out_tt__AuxiliaryData(soap, "tt:AuxiliaryCommands", -1, a->AuxiliaryCommands + i, ""))
				return soap->error;
	}
	if (a->Extension)
	{	
		if (soap_out_PointerTott__IOCapabilitiesExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Extension"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IOCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__IOCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__IOCapabilitiesExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_Auxiliary = 1;
	struct soap_blist *soap_blist_AuxiliaryCommands = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IOCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IOCapabilitiesExtension, sizeof(struct tt__IOCapabilitiesExtension), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__IOCapabilitiesExtension(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap_flag_Auxiliary && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:Auxiliary", &a->Auxiliary, "xsd:boolean"))
				{	
					soap_flag_Auxiliary--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AuxiliaryCommands", 1, NULL))
				{	
					if (a->AuxiliaryCommands == NULL)
					{	
						if (soap_blist_AuxiliaryCommands == NULL)
							soap_blist_AuxiliaryCommands = soap_new_block(soap);
						a->AuxiliaryCommands = (char **)soap_push_block(soap, soap_blist_AuxiliaryCommands, sizeof(char *));
						if (a->AuxiliaryCommands == NULL)
							return NULL;
						*a->AuxiliaryCommands = NULL;
					}
					soap_revert(soap);
					if (soap_in_tt__AuxiliaryData(soap, "tt:AuxiliaryCommands", a->AuxiliaryCommands, "tt:AuxiliaryData"))
					{	
						a->__sizeAuxiliaryCommands++;
						a->AuxiliaryCommands = NULL;
						continue;
					}
				}
				if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__IOCapabilitiesExtension2(soap, "tt:Extension", &a->Extension, "tt:IOCapabilitiesExtension2"))
					{	
						soap_flag_Extension--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH)
						soap->error = soap_ignore_element(soap);
					if (soap->error == SOAP_NO_TAG)
						break;
					if (soap->error)
						return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->AuxiliaryCommands)
			soap_pop_block(soap, soap_blist_AuxiliaryCommands);
		if (a->__sizeAuxiliaryCommands)
			a->AuxiliaryCommands = (char **)soap_save_block(soap, soap_blist_AuxiliaryCommands, NULL, 1);
		else
		{	
			a->AuxiliaryCommands = NULL;
			if (soap_blist_AuxiliaryCommands)
				soap_end_block(soap, soap_blist_AuxiliaryCommands);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__IOCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IOCapabilitiesExtension, 0, sizeof(struct tt__IOCapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Extension > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IOCapabilitiesExtension(struct soap *soap, const struct tt__IOCapabilitiesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IOCapabilitiesExtension);
	if (soap_out_tt__IOCapabilitiesExtension(soap, tag?tag:"tt:IOCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IOCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__IOCapabilitiesExtension(struct soap *soap, struct tt__IOCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IOCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IOCapabilitiesExtension(struct soap *soap, struct tt__IOCapabilitiesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IOCapabilitiesExtension))
		soap_serialize_tt__IOCapabilitiesExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IOCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct tt__IOCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IOCapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IOCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IOCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__IOCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__IOCapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__IOCapabilitiesExtension **)soap_malloc(soap, sizeof(struct tt__IOCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__IOCapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__IOCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IOCapabilitiesExtension, sizeof(struct tt__IOCapabilitiesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IOCapabilitiesExtension(struct soap *soap, struct tt__IOCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IOCapabilitiesExtension);
	if (soap_out_PointerTott__IOCapabilitiesExtension(soap, tag?tag:"tt:IOCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IOCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__IOCapabilitiesExtension(struct soap *soap, struct tt__IOCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IOCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IOCapabilities(struct soap *soap, struct tt__IOCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->InputConnectors = NULL;
	a->RelayOutputs = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IOCapabilities(struct soap *soap, const struct tt__IOCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->InputConnectors);
	soap_serialize_PointerToint(soap, &a->RelayOutputs);
	soap_serialize_PointerTott__IOCapabilitiesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IOCapabilities(struct soap *soap, const char *tag, int id, const struct tt__IOCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IOCapabilities), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:InputConnectors", -1, &a->InputConnectors, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:RelayOutputs", -1, &a->RelayOutputs, ""))
		return soap->error;
	if (soap_out_PointerTott__IOCapabilitiesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IOCapabilities * SOAP_FMAC4 soap_in_tt__IOCapabilities(struct soap *soap, const char *tag, struct tt__IOCapabilities *a, const char *type)
{
	size_t soap_flag_InputConnectors = 1;
	size_t soap_flag_RelayOutputs = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IOCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IOCapabilities, sizeof(struct tt__IOCapabilities), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__IOCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InputConnectors && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tt:InputConnectors", &a->InputConnectors, "xsd:int"))
				{	
					soap_flag_InputConnectors--;
					continue;
				}
				if (soap_flag_RelayOutputs && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerToint(soap, "tt:RelayOutputs", &a->RelayOutputs, "xsd:int"))
					{	
						soap_flag_RelayOutputs--;
						continue;
					}
					if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTott__IOCapabilitiesExtension(soap, "tt:Extension", &a->Extension, "tt:IOCapabilitiesExtension"))
						{	
							soap_flag_Extension--;
							continue;
						}
						if (soap->error == SOAP_TAG_MISMATCH)
							soap->error = soap_ignore_element(soap);
						if (soap->error == SOAP_NO_TAG)
							break;
						if (soap->error)
							return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__IOCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IOCapabilities, 0, sizeof(struct tt__IOCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IOCapabilities(struct soap *soap, const struct tt__IOCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IOCapabilities);
	if (soap_out_tt__IOCapabilities(soap, tag?tag:"tt:IOCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IOCapabilities * SOAP_FMAC4 soap_get_tt__IOCapabilities(struct soap *soap, struct tt__IOCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IOCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IOCapabilities(struct soap *soap, struct tt__IOCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IOCapabilities))
		soap_serialize_tt__IOCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IOCapabilities(struct soap *soap, const char *tag, int id, struct tt__IOCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IOCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IOCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IOCapabilities ** SOAP_FMAC4 soap_in_PointerTott__IOCapabilities(struct soap *soap, const char *tag, struct tt__IOCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__IOCapabilities **)soap_malloc(soap, sizeof(struct tt__IOCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__IOCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__IOCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IOCapabilities, sizeof(struct tt__IOCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IOCapabilities(struct soap *soap, struct tt__IOCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IOCapabilities);
	if (soap_out_PointerTott__IOCapabilities(soap, tag?tag:"tt:IOCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IOCapabilities ** SOAP_FMAC4 soap_get_PointerTott__IOCapabilities(struct soap *soap, struct tt__IOCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IOCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SecurityCapabilitiesExtension2(struct soap *soap, struct tt__SecurityCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->Dot1X);
	a->__sizeSupportedEAPMethod = 0;
	a->SupportedEAPMethod = NULL;
	soap_default_xsd__boolean_(soap, &a->RemoteUserHandling);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SecurityCapabilitiesExtension2(struct soap *soap, const struct tt__SecurityCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Dot1X, SOAP_TYPE_xsd__boolean_);
	if (a->SupportedEAPMethod)
	{	
		int i;
		for (i = 0; i < a->__sizeSupportedEAPMethod; i++)
		{
			soap_embedded(soap, a->SupportedEAPMethod + i, SOAP_TYPE_int);
		}
	}
	soap_embedded(soap, &a->RemoteUserHandling, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SecurityCapabilitiesExtension2(struct soap *soap, const char *tag, int id, const struct tt__SecurityCapabilitiesExtension2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension2), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:Dot1X", -1, &a->Dot1X, ""))
		return soap->error;
	if (a->SupportedEAPMethod)
	{	
		int i;
		for (i = 0; i < a->__sizeSupportedEAPMethod; i++)
			if (soap_out_int(soap, "tt:SupportedEAPMethod", -1, a->SupportedEAPMethod + i, ""))
				return soap->error;
	}
	if (soap_out_xsd__boolean_(soap, "tt:RemoteUserHandling", -1, &a->RemoteUserHandling, ""))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__SecurityCapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__SecurityCapabilitiesExtension2 *a, const char *type)
{
	size_t soap_flag_Dot1X = 1;
	struct soap_blist *soap_blist_SupportedEAPMethod = NULL;
	size_t soap_flag_RemoteUserHandling = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SecurityCapabilitiesExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, sizeof(struct tt__SecurityCapabilitiesExtension2), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__SecurityCapabilitiesExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1X && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:Dot1X", &a->Dot1X, "xsd:boolean"))
				{	
					soap_flag_Dot1X--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SupportedEAPMethod", 1, NULL))
				{	
					if (a->SupportedEAPMethod == NULL)
					{	
						if (soap_blist_SupportedEAPMethod == NULL)
							soap_blist_SupportedEAPMethod = soap_new_block(soap);
						a->SupportedEAPMethod = (int *)soap_push_block(soap, soap_blist_SupportedEAPMethod, sizeof(int));
						if (a->SupportedEAPMethod == NULL)
							return NULL;
						soap_default_int(soap, a->SupportedEAPMethod);
					}
					soap_revert(soap);
					if (soap_in_int(soap, "tt:SupportedEAPMethod", a->SupportedEAPMethod, "xsd:int"))
					{	
						a->__sizeSupportedEAPMethod++;
						a->SupportedEAPMethod = NULL;
						continue;
					}
				}
				if (soap_flag_RemoteUserHandling && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_xsd__boolean_(soap, "tt:RemoteUserHandling", &a->RemoteUserHandling, "xsd:boolean"))
					{	
						soap_flag_RemoteUserHandling--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
					{	
						if (a->__any == NULL)
						{	
							if (soap_blist___any == NULL)
								soap_blist___any = soap_new_block(soap);
							a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
							if (a->__any == NULL)
								return NULL;
							*a->__any = NULL;
						}
						if (soap_inliteral(soap, "-any", a->__any))
						{	
							a->__size++;
							a->__any = NULL;
							continue;
						}
					}
					if (soap->error == SOAP_TAG_MISMATCH)
						soap->error = soap_ignore_element(soap);
					if (soap->error == SOAP_NO_TAG)
						break;
					if (soap->error)
						return NULL;
		}
		if (a->SupportedEAPMethod)
			soap_pop_block(soap, soap_blist_SupportedEAPMethod);
		if (a->__sizeSupportedEAPMethod)
			a->SupportedEAPMethod = (int *)soap_save_block(soap, soap_blist_SupportedEAPMethod, NULL, 1);
		else
		{	
			a->SupportedEAPMethod = NULL;
			if (soap_blist_SupportedEAPMethod)
				soap_end_block(soap, soap_blist_SupportedEAPMethod);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__SecurityCapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, 0, sizeof(struct tt__SecurityCapabilitiesExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Dot1X > 0 || soap_flag_RemoteUserHandling > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SecurityCapabilitiesExtension2(struct soap *soap, const struct tt__SecurityCapabilitiesExtension2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SecurityCapabilitiesExtension2);
	if (soap_out_tt__SecurityCapabilitiesExtension2(soap, tag?tag:"tt:SecurityCapabilitiesExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__SecurityCapabilitiesExtension2(struct soap *soap, struct tt__SecurityCapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SecurityCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SecurityCapabilitiesExtension(struct soap *soap, struct tt__SecurityCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->TLS1_x002e0);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SecurityCapabilitiesExtension(struct soap *soap, const struct tt__SecurityCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->TLS1_x002e0, SOAP_TYPE_xsd__boolean_);
	soap_serialize_PointerTott__SecurityCapabilitiesExtension2(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct tt__SecurityCapabilitiesExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:TLS1.0", -1, &a->TLS1_x002e0, ""))
		return soap->error;
	if (soap_out_PointerTott__SecurityCapabilitiesExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__SecurityCapabilitiesExtension *a, const char *type)
{
	size_t soap_flag_TLS1_x002e0 = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SecurityCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension, sizeof(struct tt__SecurityCapabilitiesExtension), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__SecurityCapabilitiesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TLS1_x002e0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:TLS1.0", &a->TLS1_x002e0, "xsd:boolean"))
				{	
					soap_flag_TLS1_x002e0--;
					continue;
				}
				if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__SecurityCapabilitiesExtension2(soap, "tt:Extension", &a->Extension, "tt:SecurityCapabilitiesExtension2"))
					{	soap_flag_Extension--;
				continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH)
					soap->error = soap_ignore_element(soap);
				if (soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__SecurityCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SecurityCapabilitiesExtension, 0, sizeof(struct tt__SecurityCapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TLS1_x002e0 > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SecurityCapabilitiesExtension(struct soap *soap, const struct tt__SecurityCapabilitiesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SecurityCapabilitiesExtension);
	if (soap_out_tt__SecurityCapabilitiesExtension(soap, tag?tag:"tt:SecurityCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__SecurityCapabilitiesExtension(struct soap *soap, struct tt__SecurityCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SecurityCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SecurityCapabilitiesExtension2(struct soap *soap, struct tt__SecurityCapabilitiesExtension2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SecurityCapabilitiesExtension2))
		soap_serialize_tt__SecurityCapabilitiesExtension2(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SecurityCapabilitiesExtension2(struct soap *soap, const char *tag, int id, struct tt__SecurityCapabilitiesExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SecurityCapabilitiesExtension2);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SecurityCapabilitiesExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension2 ** SOAP_FMAC4 soap_in_PointerTott__SecurityCapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__SecurityCapabilitiesExtension2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__SecurityCapabilitiesExtension2 **)soap_malloc(soap, sizeof(struct tt__SecurityCapabilitiesExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__SecurityCapabilitiesExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__SecurityCapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, sizeof(struct tt__SecurityCapabilitiesExtension2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SecurityCapabilitiesExtension2(struct soap *soap, struct tt__SecurityCapabilitiesExtension2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SecurityCapabilitiesExtension2);
	if (soap_out_PointerTott__SecurityCapabilitiesExtension2(soap, tag?tag:"tt:SecurityCapabilitiesExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension2 ** SOAP_FMAC4 soap_get_PointerTott__SecurityCapabilitiesExtension2(struct soap *soap, struct tt__SecurityCapabilitiesExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SecurityCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, struct tt__SecurityCapabilitiesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SecurityCapabilitiesExtension))
		soap_serialize_tt__SecurityCapabilitiesExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct tt__SecurityCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SecurityCapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SecurityCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__SecurityCapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__SecurityCapabilitiesExtension **)soap_malloc(soap, sizeof(struct tt__SecurityCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__SecurityCapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__SecurityCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SecurityCapabilitiesExtension, sizeof(struct tt__SecurityCapabilitiesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, struct tt__SecurityCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SecurityCapabilitiesExtension);
	if (soap_out_PointerTott__SecurityCapabilitiesExtension(soap, tag?tag:"tt:SecurityCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, struct tt__SecurityCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SecurityCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SecurityCapabilities(struct soap *soap, struct tt__SecurityCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->TLS1_x002e1);
	soap_default_xsd__boolean_(soap, &a->TLS1_x002e2);
	soap_default_xsd__boolean_(soap, &a->OnboardKeyGeneration);
	soap_default_xsd__boolean_(soap, &a->AccessPolicyConfig);
	soap_default_xsd__boolean_(soap, &a->X_x002e509Token);
	soap_default_xsd__boolean_(soap, &a->SAMLToken);
	soap_default_xsd__boolean_(soap, &a->KerberosToken);
	soap_default_xsd__boolean_(soap, &a->RELToken);
	a->__size = 0;
	a->__any = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SecurityCapabilities(struct soap *soap, const struct tt__SecurityCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->TLS1_x002e1, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->TLS1_x002e2, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->OnboardKeyGeneration, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->AccessPolicyConfig, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->X_x002e509Token, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->SAMLToken, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->KerberosToken, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->RELToken, SOAP_TYPE_xsd__boolean_);
	soap_serialize_PointerTott__SecurityCapabilitiesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SecurityCapabilities(struct soap *soap, const char *tag, int id, const struct tt__SecurityCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SecurityCapabilities), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:TLS1.1", -1, &a->TLS1_x002e1, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:TLS1.2", -1, &a->TLS1_x002e2, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:OnboardKeyGeneration", -1, &a->OnboardKeyGeneration, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:AccessPolicyConfig", -1, &a->AccessPolicyConfig, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:X.509Token", -1, &a->X_x002e509Token, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:SAMLToken", -1, &a->SAMLToken, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:KerberosToken", -1, &a->KerberosToken, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:RELToken", -1, &a->RELToken, ""))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	if (soap_out_PointerTott__SecurityCapabilitiesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SecurityCapabilities * SOAP_FMAC4 soap_in_tt__SecurityCapabilities(struct soap *soap, const char *tag, struct tt__SecurityCapabilities *a, const char *type)
{
	size_t soap_flag_TLS1_x002e1 = 1;
	size_t soap_flag_TLS1_x002e2 = 1;
	size_t soap_flag_OnboardKeyGeneration = 1;
	size_t soap_flag_AccessPolicyConfig = 1;
	size_t soap_flag_X_x002e509Token = 1;
	size_t soap_flag_SAMLToken = 1;
	size_t soap_flag_KerberosToken = 1;
	size_t soap_flag_RELToken = 1;
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SecurityCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SecurityCapabilities, sizeof(struct tt__SecurityCapabilities), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__SecurityCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TLS1_x002e1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:TLS1.1", &a->TLS1_x002e1, "xsd:boolean"))
				{	
					soap_flag_TLS1_x002e1--;
					continue;
				}
				if (soap_flag_TLS1_x002e2 && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_xsd__boolean_(soap, "tt:TLS1.2", &a->TLS1_x002e2, "xsd:boolean"))
					{	
						soap_flag_TLS1_x002e2--;
						continue;
					}
					if (soap_flag_OnboardKeyGeneration && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_xsd__boolean_(soap, "tt:OnboardKeyGeneration", &a->OnboardKeyGeneration, "xsd:boolean"))
						{	
							soap_flag_OnboardKeyGeneration--;
							continue;
						}
						if (soap_flag_AccessPolicyConfig && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_xsd__boolean_(soap, "tt:AccessPolicyConfig", &a->AccessPolicyConfig, "xsd:boolean"))
							{	
								soap_flag_AccessPolicyConfig--;
								continue;
							}
							if (soap_flag_X_x002e509Token && soap->error == SOAP_TAG_MISMATCH)
								if (soap_in_xsd__boolean_(soap, "tt:X.509Token", &a->X_x002e509Token, "xsd:boolean"))
								{	
									soap_flag_X_x002e509Token--;
									continue;
								}
								if (soap_flag_SAMLToken && soap->error == SOAP_TAG_MISMATCH)
									if (soap_in_xsd__boolean_(soap, "tt:SAMLToken", &a->SAMLToken, "xsd:boolean"))
									{	
										soap_flag_SAMLToken--;
										continue;
									}
									if (soap_flag_KerberosToken && soap->error == SOAP_TAG_MISMATCH)
										if (soap_in_xsd__boolean_(soap, "tt:KerberosToken", &a->KerberosToken, "xsd:boolean"))
										{	
											soap_flag_KerberosToken--;
											continue;
										}
										if (soap_flag_RELToken && soap->error == SOAP_TAG_MISMATCH)
											if (soap_in_xsd__boolean_(soap, "tt:RELToken", &a->RELToken, "xsd:boolean"))
											{	
												soap_flag_RELToken--;
												continue;
											}
											if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
											{	
												if (a->__any == NULL)
												{	
													if (soap_blist___any == NULL)
														soap_blist___any = soap_new_block(soap);
													a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
													if (a->__any == NULL)
														return NULL;
													*a->__any = NULL;
												}
												if (soap_inliteral(soap, "-any", a->__any))
												{	
													a->__size++;
													a->__any = NULL;
													continue;
												}
											}
											if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
												if (soap_in_PointerTott__SecurityCapabilitiesExtension(soap, "tt:Extension", &a->Extension, "tt:SecurityCapabilitiesExtension"))
												{	
													soap_flag_Extension--;
													continue;
												}
												if (soap->error == SOAP_TAG_MISMATCH)
													soap->error = soap_ignore_element(soap);
												if (soap->error == SOAP_NO_TAG)
													break;
												if (soap->error)
													return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__SecurityCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SecurityCapabilities, 0, sizeof(struct tt__SecurityCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TLS1_x002e1 > 0 || soap_flag_TLS1_x002e2 > 0 || soap_flag_OnboardKeyGeneration > 0 || soap_flag_AccessPolicyConfig > 0 || soap_flag_X_x002e509Token > 0 || soap_flag_SAMLToken > 0 || soap_flag_KerberosToken > 0 || soap_flag_RELToken > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SecurityCapabilities(struct soap *soap, const struct tt__SecurityCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SecurityCapabilities);
	if (soap_out_tt__SecurityCapabilities(soap, tag?tag:"tt:SecurityCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SecurityCapabilities * SOAP_FMAC4 soap_get_tt__SecurityCapabilities(struct soap *soap, struct tt__SecurityCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SecurityCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SecurityCapabilities(struct soap *soap, struct tt__SecurityCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SecurityCapabilities))
		soap_serialize_tt__SecurityCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SecurityCapabilities(struct soap *soap, const char *tag, int id, struct tt__SecurityCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SecurityCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SecurityCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SecurityCapabilities ** SOAP_FMAC4 soap_in_PointerTott__SecurityCapabilities(struct soap *soap, const char *tag, struct tt__SecurityCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__SecurityCapabilities **)soap_malloc(soap, sizeof(struct tt__SecurityCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__SecurityCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__SecurityCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SecurityCapabilities, sizeof(struct tt__SecurityCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SecurityCapabilities(struct soap *soap, struct tt__SecurityCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SecurityCapabilities);
	if (soap_out_PointerTott__SecurityCapabilities(soap, tag?tag:"tt:SecurityCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SecurityCapabilities ** SOAP_FMAC4 soap_get_PointerTott__SecurityCapabilities(struct soap *soap, struct tt__SecurityCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SecurityCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DeviceCapabilities(struct soap *soap, struct tt__DeviceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->XAddr);
	a->Network = NULL;
	a->System = NULL;
	a->IO = NULL;
	a->Security = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DeviceCapabilities(struct soap *soap, const struct tt__DeviceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->XAddr);
	soap_serialize_PointerTott__NetworkCapabilities(soap, &a->Network);
	soap_serialize_PointerTott__SystemCapabilities(soap, &a->System);
	soap_serialize_PointerTott__IOCapabilities(soap, &a->IO);
	soap_serialize_PointerTott__SecurityCapabilities(soap, &a->Security);
	soap_serialize_PointerTott__DeviceCapabilitiesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceCapabilities(struct soap *soap, const char *tag, int id, const struct tt__DeviceCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DeviceCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	if (soap_out_string(soap, "tt:XAddr", -1, &a->XAddr, ""))
	return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XAddr"))
		return soap->error;
	if (soap_out_PointerTott__NetworkCapabilities(soap, "tt:Network", -1, &a->Network, ""))
		return soap->error;
	if (soap_out_PointerTott__SystemCapabilities(soap, "tt:System", -1, &a->System, ""))
		return soap->error;
	if (soap_out_PointerTott__IOCapabilities(soap, "tt:IO", -1, &a->IO, ""))
		return soap->error;
	if (soap_out_PointerTott__SecurityCapabilities(soap, "tt:Security", -1, &a->Security, ""))
		return soap->error;
	if (soap_out_PointerTott__DeviceCapabilitiesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DeviceCapabilities * SOAP_FMAC4 soap_in_tt__DeviceCapabilities(struct soap *soap, const char *tag, struct tt__DeviceCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_Network = 1;
	size_t soap_flag_System = 1;
	size_t soap_flag_IO = 1;
	size_t soap_flag_Security = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DeviceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceCapabilities, sizeof(struct tt__DeviceCapabilities), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__DeviceCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:XAddr", &a->XAddr, "xsd:string"))
				{	
					soap_flag_XAddr--;
					continue;
				}
				if (soap_flag_Network && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__NetworkCapabilities(soap, "tt:Network", &a->Network, "tt:NetworkCapabilities"))
					{	
						soap_flag_Network--;
						continue;
					}
					if (soap_flag_System && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTott__SystemCapabilities(soap, "tt:System", &a->System, "tt:SystemCapabilities"))
						{	
							soap_flag_System--;
							continue;
						}
						if (soap_flag_IO && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_PointerTott__IOCapabilities(soap, "tt:IO", &a->IO, "tt:IOCapabilities"))
							{	
								soap_flag_IO--;
								continue;
							}
							if (soap_flag_Security && soap->error == SOAP_TAG_MISMATCH)
								if (soap_in_PointerTott__SecurityCapabilities(soap, "tt:Security", &a->Security, "tt:SecurityCapabilities"))
								{	
									soap_flag_Security--;
									continue;
								}
								if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
									if (soap_in_PointerTott__DeviceCapabilitiesExtension(soap, "tt:Extension", &a->Extension, "tt:DeviceCapabilitiesExtension"))
									{	
										soap_flag_Extension--;
										continue;
									}
									if (soap->error == SOAP_TAG_MISMATCH)
										soap->error = soap_ignore_element(soap);
									if (soap->error == SOAP_NO_TAG)
										break;
									if (soap->error)
										return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__DeviceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceCapabilities, 0, sizeof(struct tt__DeviceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DeviceCapabilities(struct soap *soap, const struct tt__DeviceCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__DeviceCapabilities);
	if (soap_out_tt__DeviceCapabilities(soap, tag?tag:"tt:DeviceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DeviceCapabilities * SOAP_FMAC4 soap_get_tt__DeviceCapabilities(struct soap *soap, struct tt__DeviceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DeviceCapabilities(struct soap *soap, struct tt__DeviceCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DeviceCapabilities))
		soap_serialize_tt__DeviceCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DeviceCapabilities(struct soap *soap, const char *tag, int id, struct tt__DeviceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DeviceCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DeviceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DeviceCapabilities ** SOAP_FMAC4 soap_in_PointerTott__DeviceCapabilities(struct soap *soap, const char *tag, struct tt__DeviceCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__DeviceCapabilities **)soap_malloc(soap, sizeof(struct tt__DeviceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__DeviceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__DeviceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DeviceCapabilities, sizeof(struct tt__DeviceCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DeviceCapabilities(struct soap *soap, struct tt__DeviceCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__DeviceCapabilities);
	if (soap_out_PointerTott__DeviceCapabilities(soap, tag?tag:"tt:DeviceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DeviceCapabilities ** SOAP_FMAC4 soap_get_PointerTott__DeviceCapabilities(struct soap *soap, struct tt__DeviceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DeviceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EventCapabilities(struct soap *soap, struct tt__EventCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->XAddr);
	soap_default_xsd__boolean_(soap, &a->WSSubscriptionPolicySupport);
	soap_default_xsd__boolean_(soap, &a->WSPullPointSupport);
	soap_default_xsd__boolean_(soap, &a->WSPausableSubscriptionManagerInterfaceSupport);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EventCapabilities(struct soap *soap, const struct tt__EventCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->XAddr);
	soap_embedded(soap, &a->WSSubscriptionPolicySupport, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->WSPullPointSupport, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->WSPausableSubscriptionManagerInterfaceSupport, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EventCapabilities(struct soap *soap, const char *tag, int id, const struct tt__EventCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EventCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	
		if (soap_out_string(soap, "tt:XAddr", -1, &a->XAddr, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XAddr"))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:WSSubscriptionPolicySupport", -1, &a->WSSubscriptionPolicySupport, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:WSPullPointSupport", -1, &a->WSPullPointSupport, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:WSPausableSubscriptionManagerInterfaceSupport", -1, &a->WSPausableSubscriptionManagerInterfaceSupport, ""))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EventCapabilities * SOAP_FMAC4 soap_in_tt__EventCapabilities(struct soap *soap, const char *tag, struct tt__EventCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_WSSubscriptionPolicySupport = 1;
	size_t soap_flag_WSPullPointSupport = 1;
	size_t soap_flag_WSPausableSubscriptionManagerInterfaceSupport = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__EventCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventCapabilities, sizeof(struct tt__EventCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EventCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:XAddr", &a->XAddr, "xsd:string"))
				{	
					soap_flag_XAddr--;
					continue;
				}
				if (soap_flag_WSSubscriptionPolicySupport && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_xsd__boolean_(soap, "tt:WSSubscriptionPolicySupport", &a->WSSubscriptionPolicySupport, "xsd:boolean"))
					{	
						soap_flag_WSSubscriptionPolicySupport--;
						continue;
					}
					if (soap_flag_WSPullPointSupport && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_xsd__boolean_(soap, "tt:WSPullPointSupport", &a->WSPullPointSupport, "xsd:boolean"))
						{	
							soap_flag_WSPullPointSupport--;
							continue;
						}
						if (soap_flag_WSPausableSubscriptionManagerInterfaceSupport && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_xsd__boolean_(soap, "tt:WSPausableSubscriptionManagerInterfaceSupport", &a->WSPausableSubscriptionManagerInterfaceSupport, "xsd:boolean"))
							{	
								soap_flag_WSPausableSubscriptionManagerInterfaceSupport--;
								continue;
							}
							if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
							{	
								if (a->__any == NULL)
								{	
									if (soap_blist___any == NULL)
										soap_blist___any = soap_new_block(soap);
									a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
									if (a->__any == NULL)
										return NULL;
									*a->__any = NULL;
								}
								if (soap_inliteral(soap, "-any", a->__any))
								{	
									a->__size++;
									a->__any = NULL;
									continue;
								}
							}
							if (soap->error == SOAP_TAG_MISMATCH)
								soap->error = soap_ignore_element(soap);
							if (soap->error == SOAP_NO_TAG)
								break;
							if (soap->error)
								return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__EventCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventCapabilities, 0, sizeof(struct tt__EventCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0 || soap_flag_WSSubscriptionPolicySupport > 0 || soap_flag_WSPullPointSupport > 0 || soap_flag_WSPausableSubscriptionManagerInterfaceSupport > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EventCapabilities(struct soap *soap, const struct tt__EventCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__EventCapabilities);
	if (soap_out_tt__EventCapabilities(soap, tag?tag:"tt:EventCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EventCapabilities * SOAP_FMAC4 soap_get_tt__EventCapabilities(struct soap *soap, struct tt__EventCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EventCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EventCapabilities(struct soap *soap, struct tt__EventCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EventCapabilities))
		soap_serialize_tt__EventCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EventCapabilities(struct soap *soap, const char *tag, int id, struct tt__EventCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EventCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__EventCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__EventCapabilities ** SOAP_FMAC4 soap_in_PointerTott__EventCapabilities(struct soap *soap, const char *tag, struct tt__EventCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__EventCapabilities **)soap_malloc(soap, sizeof(struct tt__EventCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__EventCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__EventCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EventCapabilities, sizeof(struct tt__EventCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EventCapabilities(struct soap *soap, struct tt__EventCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__EventCapabilities);
	if (soap_out_PointerTott__EventCapabilities(soap, tag?tag:"tt:EventCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EventCapabilities ** SOAP_FMAC4 soap_get_PointerTott__EventCapabilities(struct soap *soap, struct tt__EventCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EventCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingCapabilities(struct soap *soap, struct tt__ImagingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->XAddr);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingCapabilities(struct soap *soap, const struct tt__ImagingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->XAddr);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingCapabilities(struct soap *soap, const char *tag, int id, const struct tt__ImagingCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	if (soap_out_string(soap, "tt:XAddr", -1, &a->XAddr, ""))
	return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XAddr"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingCapabilities * SOAP_FMAC4 soap_in_tt__ImagingCapabilities(struct soap *soap, const char *tag, struct tt__ImagingCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ImagingCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingCapabilities, sizeof(struct tt__ImagingCapabilities), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__ImagingCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:XAddr", &a->XAddr, "xsd:string"))
				{	
					soap_flag_XAddr--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH)
					soap->error = soap_ignore_element(soap);
				if (soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__ImagingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingCapabilities, 0, sizeof(struct tt__ImagingCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingCapabilities(struct soap *soap, const struct tt__ImagingCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ImagingCapabilities);
	if (soap_out_tt__ImagingCapabilities(soap, tag?tag:"tt:ImagingCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingCapabilities * SOAP_FMAC4 soap_get_tt__ImagingCapabilities(struct soap *soap, struct tt__ImagingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingCapabilities(struct soap *soap, struct tt__ImagingCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingCapabilities))
		soap_serialize_tt__ImagingCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingCapabilities(struct soap *soap, const char *tag, int id, struct tt__ImagingCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingCapabilities ** SOAP_FMAC4 soap_in_PointerTott__ImagingCapabilities(struct soap *soap, const char *tag, struct tt__ImagingCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__ImagingCapabilities **)soap_malloc(soap, sizeof(struct tt__ImagingCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__ImagingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingCapabilities, sizeof(struct tt__ImagingCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingCapabilities(struct soap *soap, struct tt__ImagingCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ImagingCapabilities);
	if (soap_out_PointerTott__ImagingCapabilities(soap, tag?tag:"tt:ImagingCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingCapabilities ** SOAP_FMAC4 soap_get_PointerTott__ImagingCapabilities(struct soap *soap, struct tt__ImagingCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, struct tt__RealTimeStreamingCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const struct tt__RealTimeStreamingCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct tt__RealTimeStreamingCapabilitiesExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension), type))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__RealTimeStreamingCapabilitiesExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RealTimeStreamingCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, sizeof(struct tt__RealTimeStreamingCapabilitiesExtension), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__RealTimeStreamingCapabilitiesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__RealTimeStreamingCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, 0, sizeof(struct tt__RealTimeStreamingCapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const struct tt__RealTimeStreamingCapabilitiesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension);
	if (soap_out_tt__RealTimeStreamingCapabilitiesExtension(soap, tag?tag:"tt:RealTimeStreamingCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, struct tt__RealTimeStreamingCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RealTimeStreamingCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RealTimeStreamingCapabilities(struct soap *soap, struct tt__RealTimeStreamingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RTPMulticast = NULL;
	a->RTP_USCORETCP = NULL;
	a->RTP_USCORERTSP_USCORETCP = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RealTimeStreamingCapabilities(struct soap *soap, const struct tt__RealTimeStreamingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean_(soap, &a->RTPMulticast);
	soap_serialize_PointerToxsd__boolean_(soap, &a->RTP_USCORETCP);
	soap_serialize_PointerToxsd__boolean_(soap, &a->RTP_USCORERTSP_USCORETCP);
	soap_serialize_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, int id, const struct tt__RealTimeStreamingCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilities), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:RTPMulticast", -1, &a->RTPMulticast, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:RTP_TCP", -1, &a->RTP_USCORETCP, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:RTP_RTSP_TCP", -1, &a->RTP_USCORERTSP_USCORETCP, ""))
		return soap->error;
	if (soap_out_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilities * SOAP_FMAC4 soap_in_tt__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, struct tt__RealTimeStreamingCapabilities *a, const char *type)
{
	size_t soap_flag_RTPMulticast = 1;
	size_t soap_flag_RTP_USCORETCP = 1;
	size_t soap_flag_RTP_USCORERTSP_USCORETCP = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RealTimeStreamingCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilities, sizeof(struct tt__RealTimeStreamingCapabilities), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__RealTimeStreamingCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RTPMulticast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:RTPMulticast", &a->RTPMulticast, "xsd:boolean"))
				{	
					soap_flag_RTPMulticast--;
					continue;
				}
				if (soap_flag_RTP_USCORETCP && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerToxsd__boolean_(soap, "tt:RTP_TCP", &a->RTP_USCORETCP, "xsd:boolean"))
					{	
						soap_flag_RTP_USCORETCP--;
						continue;
					}
					if (soap_flag_RTP_USCORERTSP_USCORETCP && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerToxsd__boolean_(soap, "tt:RTP_RTSP_TCP", &a->RTP_USCORERTSP_USCORETCP, "xsd:boolean"))
						{	
							soap_flag_RTP_USCORERTSP_USCORETCP--;
							continue;
						}
						if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, "tt:Extension", &a->Extension, "tt:RealTimeStreamingCapabilitiesExtension"))
							{	
								soap_flag_Extension--;
								continue;
							}
							if (soap->error == SOAP_TAG_MISMATCH)
								soap->error = soap_ignore_element(soap);
							if (soap->error == SOAP_NO_TAG)
								break;
							if (soap->error)
								return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__RealTimeStreamingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RealTimeStreamingCapabilities, 0, sizeof(struct tt__RealTimeStreamingCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RealTimeStreamingCapabilities(struct soap *soap, const struct tt__RealTimeStreamingCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RealTimeStreamingCapabilities);
	if (soap_out_tt__RealTimeStreamingCapabilities(soap, tag?tag:"tt:RealTimeStreamingCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilities * SOAP_FMAC4 soap_get_tt__RealTimeStreamingCapabilities(struct soap *soap, struct tt__RealTimeStreamingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RealTimeStreamingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, struct tt__RealTimeStreamingCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RealTimeStreamingCapabilities))
		soap_serialize_tt__RealTimeStreamingCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, int id, struct tt__RealTimeStreamingCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RealTimeStreamingCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RealTimeStreamingCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilities ** SOAP_FMAC4 soap_in_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, struct tt__RealTimeStreamingCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__RealTimeStreamingCapabilities **)soap_malloc(soap, sizeof(struct tt__RealTimeStreamingCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__RealTimeStreamingCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__RealTimeStreamingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RealTimeStreamingCapabilities, sizeof(struct tt__RealTimeStreamingCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, struct tt__RealTimeStreamingCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RealTimeStreamingCapabilities);
	if (soap_out_PointerTott__RealTimeStreamingCapabilities(soap, tag?tag:"tt:RealTimeStreamingCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilities ** SOAP_FMAC4 soap_get_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, struct tt__RealTimeStreamingCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RealTimeStreamingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, struct tt__RealTimeStreamingCapabilitiesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension))
		soap_serialize_tt__RealTimeStreamingCapabilitiesExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct tt__RealTimeStreamingCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RealTimeStreamingCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__RealTimeStreamingCapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__RealTimeStreamingCapabilitiesExtension **)soap_malloc(soap, sizeof(struct tt__RealTimeStreamingCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__RealTimeStreamingCapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__RealTimeStreamingCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, sizeof(struct tt__RealTimeStreamingCapabilitiesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, struct tt__RealTimeStreamingCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RealTimeStreamingCapabilitiesExtension);
	if (soap_out_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, tag?tag:"tt:RealTimeStreamingCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, struct tt__RealTimeStreamingCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ProfileCapabilities(struct soap *soap, struct tt__ProfileCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->MaximumNumberOfProfiles);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ProfileCapabilities(struct soap *soap, const struct tt__ProfileCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->MaximumNumberOfProfiles, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ProfileCapabilities(struct soap *soap, const char *tag, int id, const struct tt__ProfileCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ProfileCapabilities), type))
		return soap->error;
	if (soap_out_int(soap, "tt:MaximumNumberOfProfiles", -1, &a->MaximumNumberOfProfiles, ""))
		return soap->error;
	if (a->__any)
	{	int i;
	for (i = 0; i < a->__size; i++)
		soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ProfileCapabilities * SOAP_FMAC4 soap_in_tt__ProfileCapabilities(struct soap *soap, const char *tag, struct tt__ProfileCapabilities *a, const char *type)
{
	size_t soap_flag_MaximumNumberOfProfiles = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ProfileCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileCapabilities, sizeof(struct tt__ProfileCapabilities), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__ProfileCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaximumNumberOfProfiles && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:MaximumNumberOfProfiles", &a->MaximumNumberOfProfiles, "xsd:int"))
				{	
					soap_flag_MaximumNumberOfProfiles--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
				{	
					if (a->__any == NULL)
					{	
						if (soap_blist___any == NULL)
							soap_blist___any = soap_new_block(soap);
						a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
						if (a->__any == NULL)
							return NULL;
						*a->__any = NULL;
					}
					if (soap_inliteral(soap, "-any", a->__any))
					{	
						a->__size++;
						a->__any = NULL;
						continue;
					}
				}
				if (soap->error == SOAP_TAG_MISMATCH)
					soap->error = soap_ignore_element(soap);
				if (soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__ProfileCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileCapabilities, 0, sizeof(struct tt__ProfileCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MaximumNumberOfProfiles > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ProfileCapabilities(struct soap *soap, const struct tt__ProfileCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ProfileCapabilities);
	if (soap_out_tt__ProfileCapabilities(soap, tag?tag:"tt:ProfileCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileCapabilities * SOAP_FMAC4 soap_get_tt__ProfileCapabilities(struct soap *soap, struct tt__ProfileCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ProfileCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ProfileCapabilities(struct soap *soap, struct tt__ProfileCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ProfileCapabilities))
		soap_serialize_tt__ProfileCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ProfileCapabilities(struct soap *soap, const char *tag, int id, struct tt__ProfileCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ProfileCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ProfileCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ProfileCapabilities ** SOAP_FMAC4 soap_in_PointerTott__ProfileCapabilities(struct soap *soap, const char *tag, struct tt__ProfileCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ProfileCapabilities **)soap_malloc(soap, sizeof(struct tt__ProfileCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_tt__ProfileCapabilities(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct tt__ProfileCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ProfileCapabilities, sizeof(struct tt__ProfileCapabilities), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ProfileCapabilities(struct soap *soap, struct tt__ProfileCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ProfileCapabilities);
	if (soap_out_PointerTott__ProfileCapabilities(soap, tag?tag:"tt:ProfileCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileCapabilities ** SOAP_FMAC4 soap_get_PointerTott__ProfileCapabilities(struct soap *soap, struct tt__ProfileCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ProfileCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MediaCapabilitiesExtension(struct soap *soap, struct tt__MediaCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ProfileCapabilities = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MediaCapabilitiesExtension(struct soap *soap, const struct tt__MediaCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ProfileCapabilities(soap, &a->ProfileCapabilities);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MediaCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct tt__MediaCapabilitiesExtension *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MediaCapabilitiesExtension), type))
		return soap->error;
	if (a->ProfileCapabilities)
	{	
		if (soap_out_PointerTott__ProfileCapabilities(soap, "tt:ProfileCapabilities", -1, &a->ProfileCapabilities, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:ProfileCapabilities"))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MediaCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__MediaCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__MediaCapabilitiesExtension *a, const char *type)
{
	size_t soap_flag_ProfileCapabilities = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MediaCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaCapabilitiesExtension, sizeof(struct tt__MediaCapabilitiesExtension), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__MediaCapabilitiesExtension(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ProfileCapabilities(soap, "tt:ProfileCapabilities", &a->ProfileCapabilities, "tt:ProfileCapabilities"))
				{	
					soap_flag_ProfileCapabilities--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
				{	
					if (a->__any == NULL)
					{	
						if (soap_blist___any == NULL)
							soap_blist___any = soap_new_block(soap);
						a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
						if (a->__any == NULL)
							return NULL;
						*a->__any = NULL;
					}
					if (soap_inliteral(soap, "-any", a->__any))
					{	
						a->__size++;
						a->__any = NULL;
						continue;
					}
				}
				if (soap->error == SOAP_TAG_MISMATCH)
					soap->error = soap_ignore_element(soap);
				if (soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__MediaCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaCapabilitiesExtension, 0, sizeof(struct tt__MediaCapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileCapabilities > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MediaCapabilitiesExtension(struct soap *soap, const struct tt__MediaCapabilitiesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__MediaCapabilitiesExtension);
	if (soap_out_tt__MediaCapabilitiesExtension(soap, tag?tag:"tt:MediaCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__MediaCapabilitiesExtension(struct soap *soap, struct tt__MediaCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MediaCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MediaCapabilitiesExtension(struct soap *soap, struct tt__MediaCapabilitiesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MediaCapabilitiesExtension))
		soap_serialize_tt__MediaCapabilitiesExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MediaCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct tt__MediaCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MediaCapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MediaCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MediaCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__MediaCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__MediaCapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MediaCapabilitiesExtension **)soap_malloc(soap, sizeof(struct tt__MediaCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_tt__MediaCapabilitiesExtension(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct tt__MediaCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MediaCapabilitiesExtension, sizeof(struct tt__MediaCapabilitiesExtension), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MediaCapabilitiesExtension(struct soap *soap, struct tt__MediaCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MediaCapabilitiesExtension);
	if (soap_out_PointerTott__MediaCapabilitiesExtension(soap, tag?tag:"tt:MediaCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__MediaCapabilitiesExtension(struct soap *soap, struct tt__MediaCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MediaCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MediaCapabilities(struct soap *soap, struct tt__MediaCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->XAddr);
	a->StreamingCapabilities = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MediaCapabilities(struct soap *soap, const struct tt__MediaCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->XAddr);
	soap_serialize_PointerTott__RealTimeStreamingCapabilities(soap, &a->StreamingCapabilities);
	soap_serialize_PointerTott__MediaCapabilitiesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MediaCapabilities(struct soap *soap, const char *tag, int id, const struct tt__MediaCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MediaCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	
		if (soap_out_string(soap, "tt:XAddr", -1, &a->XAddr, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XAddr"))
		return soap->error;
	if (a->StreamingCapabilities)
	{	
		if (soap_out_PointerTott__RealTimeStreamingCapabilities(soap, "tt:StreamingCapabilities", -1, &a->StreamingCapabilities, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:StreamingCapabilities"))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	if (soap_out_PointerTott__MediaCapabilitiesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MediaCapabilities * SOAP_FMAC4 soap_in_tt__MediaCapabilities(struct soap *soap, const char *tag, struct tt__MediaCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_StreamingCapabilities = 1;
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MediaCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaCapabilities, sizeof(struct tt__MediaCapabilities), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__MediaCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:XAddr", &a->XAddr, "xsd:string"))
				{	
					soap_flag_XAddr--;
					continue;
				}
				if (soap_flag_StreamingCapabilities && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__RealTimeStreamingCapabilities(soap, "tt:StreamingCapabilities", &a->StreamingCapabilities, "tt:RealTimeStreamingCapabilities"))
					{	
						soap_flag_StreamingCapabilities--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
					{	
						if (a->__any == NULL)
						{	
							if (soap_blist___any == NULL)
								soap_blist___any = soap_new_block(soap);
							a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
							if (a->__any == NULL)
								return NULL;
							*a->__any = NULL;
						}
						if (soap_inliteral(soap, "-any", a->__any))
						{	
							a->__size++;
							a->__any = NULL;
							continue;
						}
					}
					if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTott__MediaCapabilitiesExtension(soap, "tt:Extension", &a->Extension, "tt:MediaCapabilitiesExtension"))
						{	
							soap_flag_Extension--;
							continue;
						}
						if (soap->error == SOAP_TAG_MISMATCH)
							soap->error = soap_ignore_element(soap);
						if (soap->error == SOAP_NO_TAG)
							break;
						if (soap->error)
							return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__MediaCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaCapabilities, 0, sizeof(struct tt__MediaCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0 || soap_flag_StreamingCapabilities > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MediaCapabilities(struct soap *soap, const struct tt__MediaCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__MediaCapabilities);
	if (soap_out_tt__MediaCapabilities(soap, tag?tag:"tt:MediaCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaCapabilities * SOAP_FMAC4 soap_get_tt__MediaCapabilities(struct soap *soap, struct tt__MediaCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MediaCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MediaCapabilities(struct soap *soap, struct tt__MediaCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MediaCapabilities))
		soap_serialize_tt__MediaCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MediaCapabilities(struct soap *soap, const char *tag, int id, struct tt__MediaCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MediaCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MediaCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MediaCapabilities ** SOAP_FMAC4 soap_in_PointerTott__MediaCapabilities(struct soap *soap, const char *tag, struct tt__MediaCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__MediaCapabilities **)soap_malloc(soap, sizeof(struct tt__MediaCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__MediaCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__MediaCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MediaCapabilities, sizeof(struct tt__MediaCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MediaCapabilities(struct soap *soap, struct tt__MediaCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MediaCapabilities);
	if (soap_out_PointerTott__MediaCapabilities(soap, tag?tag:"tt:MediaCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaCapabilities ** SOAP_FMAC4 soap_get_PointerTott__MediaCapabilities(struct soap *soap, struct tt__MediaCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MediaCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZCapabilities(struct soap *soap, struct tt__PTZCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->XAddr);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZCapabilities(struct soap *soap, const struct tt__PTZCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->XAddr);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZCapabilities(struct soap *soap, const char *tag, int id, const struct tt__PTZCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	
		if (soap_out_string(soap, "tt:XAddr", -1, &a->XAddr, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XAddr"))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZCapabilities * SOAP_FMAC4 soap_in_tt__PTZCapabilities(struct soap *soap, const char *tag, struct tt__PTZCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZCapabilities, sizeof(struct tt__PTZCapabilities), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__PTZCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:XAddr", &a->XAddr, "xsd:string"))
				{	
					soap_flag_XAddr--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
				{	
					if (a->__any == NULL)
					{	
						if (soap_blist___any == NULL)
							soap_blist___any = soap_new_block(soap);
						a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
						if (a->__any == NULL)
							return NULL;
						*a->__any = NULL;
					}
					if (soap_inliteral(soap, "-any", a->__any))
					{	
						a->__size++;
						a->__any = NULL;
						continue;
					}
				}
				if (soap->error == SOAP_TAG_MISMATCH)
					soap->error = soap_ignore_element(soap);
				if (soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__PTZCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZCapabilities, 0, sizeof(struct tt__PTZCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZCapabilities(struct soap *soap, const struct tt__PTZCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PTZCapabilities);
	if (soap_out_tt__PTZCapabilities(soap, tag?tag:"tt:PTZCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZCapabilities * SOAP_FMAC4 soap_get_tt__PTZCapabilities(struct soap *soap, struct tt__PTZCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZCapabilities(struct soap *soap, struct tt__PTZCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZCapabilities))
		soap_serialize_tt__PTZCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZCapabilities(struct soap *soap, const char *tag, int id, struct tt__PTZCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZCapabilities ** SOAP_FMAC4 soap_in_PointerTott__PTZCapabilities(struct soap *soap, const char *tag, struct tt__PTZCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__PTZCapabilities **)soap_malloc(soap, sizeof(struct tt__PTZCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__PTZCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__PTZCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZCapabilities, sizeof(struct tt__PTZCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZCapabilities(struct soap *soap, struct tt__PTZCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZCapabilities);
	if (soap_out_PointerTott__PTZCapabilities(soap, tag?tag:"tt:PTZCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZCapabilities ** SOAP_FMAC4 soap_get_PointerTott__PTZCapabilities(struct soap *soap, struct tt__PTZCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CapabilitiesExtension2(struct soap *soap, struct tt__CapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CapabilitiesExtension2(struct soap *soap, const struct tt__CapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CapabilitiesExtension2(struct soap *soap, const char *tag, int id, const struct tt__CapabilitiesExtension2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CapabilitiesExtension2), type))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__CapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__CapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__CapabilitiesExtension2 *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__CapabilitiesExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CapabilitiesExtension2, sizeof(struct tt__CapabilitiesExtension2), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__CapabilitiesExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__CapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CapabilitiesExtension2, 0, sizeof(struct tt__CapabilitiesExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CapabilitiesExtension2(struct soap *soap, const struct tt__CapabilitiesExtension2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__CapabilitiesExtension2);
	if (soap_out_tt__CapabilitiesExtension2(soap, tag?tag:"tt:CapabilitiesExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__CapabilitiesExtension2(struct soap *soap, struct tt__CapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DeviceIOCapabilities(struct soap *soap, struct tt__DeviceIOCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->XAddr);
	soap_default_int(soap, &a->VideoSources);
	soap_default_int(soap, &a->VideoOutputs);
	soap_default_int(soap, &a->AudioSources);
	soap_default_int(soap, &a->AudioOutputs);
	soap_default_int(soap, &a->RelayOutputs);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DeviceIOCapabilities(struct soap *soap, const struct tt__DeviceIOCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->XAddr);
	soap_embedded(soap, &a->VideoSources, SOAP_TYPE_int);
	soap_embedded(soap, &a->VideoOutputs, SOAP_TYPE_int);
	soap_embedded(soap, &a->AudioSources, SOAP_TYPE_int);
	soap_embedded(soap, &a->AudioOutputs, SOAP_TYPE_int);
	soap_embedded(soap, &a->RelayOutputs, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceIOCapabilities(struct soap *soap, const char *tag, int id, const struct tt__DeviceIOCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DeviceIOCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	
		if (soap_out_string(soap, "tt:XAddr", -1, &a->XAddr, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XAddr"))
		return soap->error;
	if (soap_out_int(soap, "tt:VideoSources", -1, &a->VideoSources, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:VideoOutputs", -1, &a->VideoOutputs, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:AudioSources", -1, &a->AudioSources, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:AudioOutputs", -1, &a->AudioOutputs, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:RelayOutputs", -1, &a->RelayOutputs, ""))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DeviceIOCapabilities * SOAP_FMAC4 soap_in_tt__DeviceIOCapabilities(struct soap *soap, const char *tag, struct tt__DeviceIOCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_VideoSources = 1;
	size_t soap_flag_VideoOutputs = 1;
	size_t soap_flag_AudioSources = 1;
	size_t soap_flag_AudioOutputs = 1;
	size_t soap_flag_RelayOutputs = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DeviceIOCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceIOCapabilities, sizeof(struct tt__DeviceIOCapabilities), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__DeviceIOCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:XAddr", &a->XAddr, "xsd:string"))
				{	
					soap_flag_XAddr--;
					continue;
				}
				if (soap_flag_VideoSources && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_int(soap, "tt:VideoSources", &a->VideoSources, "xsd:int"))
					{	
						soap_flag_VideoSources--;
						continue;
					}
					if (soap_flag_VideoOutputs && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_int(soap, "tt:VideoOutputs", &a->VideoOutputs, "xsd:int"))
						{	
							soap_flag_VideoOutputs--;
							continue;
						}
						if (soap_flag_AudioSources && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_int(soap, "tt:AudioSources", &a->AudioSources, "xsd:int"))
							{	
								soap_flag_AudioSources--;
								continue;
							}
							if (soap_flag_AudioOutputs && soap->error == SOAP_TAG_MISMATCH)
								if (soap_in_int(soap, "tt:AudioOutputs", &a->AudioOutputs, "xsd:int"))
								{	
									soap_flag_AudioOutputs--;
									continue;
								}
								if (soap_flag_RelayOutputs && soap->error == SOAP_TAG_MISMATCH)
									if (soap_in_int(soap, "tt:RelayOutputs", &a->RelayOutputs, "xsd:int"))
									{	
										soap_flag_RelayOutputs--;
										continue;
									}
									if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
									{	
										if (a->__any == NULL)
										{	
											if (soap_blist___any == NULL)
												soap_blist___any = soap_new_block(soap);
											a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
											if (a->__any == NULL)
												return NULL;
											*a->__any = NULL;
										}
										if (soap_inliteral(soap, "-any", a->__any))
										{	
											a->__size++;
											a->__any = NULL;
											continue;
										}
									}
									if (soap->error == SOAP_TAG_MISMATCH)
										soap->error = soap_ignore_element(soap);
									if (soap->error == SOAP_NO_TAG)
										break;
									if (soap->error)
										return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__DeviceIOCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceIOCapabilities, 0, sizeof(struct tt__DeviceIOCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0 || soap_flag_VideoSources > 0 || soap_flag_VideoOutputs > 0 || soap_flag_AudioSources > 0 || soap_flag_AudioOutputs > 0 || soap_flag_RelayOutputs > 0))
	{
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DeviceIOCapabilities(struct soap *soap, const struct tt__DeviceIOCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__DeviceIOCapabilities);
	if (soap_out_tt__DeviceIOCapabilities(soap, tag?tag:"tt:DeviceIOCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DeviceIOCapabilities * SOAP_FMAC4 soap_get_tt__DeviceIOCapabilities(struct soap *soap, struct tt__DeviceIOCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceIOCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DeviceIOCapabilities(struct soap *soap, struct tt__DeviceIOCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DeviceIOCapabilities))
		soap_serialize_tt__DeviceIOCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DeviceIOCapabilities(struct soap *soap, const char *tag, int id, struct tt__DeviceIOCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DeviceIOCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DeviceIOCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DeviceIOCapabilities ** SOAP_FMAC4 soap_in_PointerTott__DeviceIOCapabilities(struct soap *soap, const char *tag, struct tt__DeviceIOCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__DeviceIOCapabilities **)soap_malloc(soap, sizeof(struct tt__DeviceIOCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__DeviceIOCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__DeviceIOCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DeviceIOCapabilities, sizeof(struct tt__DeviceIOCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DeviceIOCapabilities(struct soap *soap, struct tt__DeviceIOCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__DeviceIOCapabilities);
	if (soap_out_PointerTott__DeviceIOCapabilities(soap, tag?tag:"tt:DeviceIOCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DeviceIOCapabilities ** SOAP_FMAC4 soap_get_PointerTott__DeviceIOCapabilities(struct soap *soap, struct tt__DeviceIOCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DeviceIOCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DisplayCapabilities(struct soap *soap, struct tt__DisplayCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->XAddr);
	soap_default_xsd__boolean_(soap, &a->FixedLayout);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DisplayCapabilities(struct soap *soap, const struct tt__DisplayCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->XAddr);
	soap_embedded(soap, &a->FixedLayout, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DisplayCapabilities(struct soap *soap, const char *tag, int id, const struct tt__DisplayCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DisplayCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	if (soap_out_string(soap, "tt:XAddr", -1, &a->XAddr, ""))
	return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XAddr"))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:FixedLayout", -1, &a->FixedLayout, ""))
		return soap->error;
	if (a->__any)
	{	int i;
	for (i = 0; i < a->__size; i++)
		soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DisplayCapabilities * SOAP_FMAC4 soap_in_tt__DisplayCapabilities(struct soap *soap, const char *tag, struct tt__DisplayCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_FixedLayout = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DisplayCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DisplayCapabilities, sizeof(struct tt__DisplayCapabilities), 0, NULL, NULL, NULL);
	if (a== NULL)
		return NULL;
	soap_default_tt__DisplayCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:XAddr", &a->XAddr, "xsd:string"))
				{	
					soap_flag_XAddr--;
					continue;
				}
				if (soap_flag_FixedLayout && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_xsd__boolean_(soap, "tt:FixedLayout", &a->FixedLayout, "xsd:boolean"))
					{	
						soap_flag_FixedLayout--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
					{	
						if (a->__any == NULL)
						{	
							if (soap_blist___any == NULL)
								soap_blist___any = soap_new_block(soap);
							a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
							if (a->__any == NULL)
								return NULL;
							*a->__any = NULL;
						}
						if (soap_inliteral(soap, "-any", a->__any))
						{	
							a->__size++;
							a->__any = NULL;
							continue;
						}
					}
					if (soap->error == SOAP_TAG_MISMATCH)
						soap->error = soap_ignore_element(soap);
					if (soap->error == SOAP_NO_TAG)
						break;
					if (soap->error)
						return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__DisplayCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DisplayCapabilities, 0, sizeof(struct tt__DisplayCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0 || soap_flag_FixedLayout > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DisplayCapabilities(struct soap *soap, const struct tt__DisplayCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__DisplayCapabilities);
	if (soap_out_tt__DisplayCapabilities(soap, tag?tag:"tt:DisplayCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DisplayCapabilities * SOAP_FMAC4 soap_get_tt__DisplayCapabilities(struct soap *soap, struct tt__DisplayCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DisplayCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DisplayCapabilities(struct soap *soap, struct tt__DisplayCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DisplayCapabilities))
		soap_serialize_tt__DisplayCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DisplayCapabilities(struct soap *soap, const char *tag, int id, struct tt__DisplayCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DisplayCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DisplayCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DisplayCapabilities ** SOAP_FMAC4 soap_in_PointerTott__DisplayCapabilities(struct soap *soap, const char *tag, struct tt__DisplayCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__DisplayCapabilities **)soap_malloc(soap, sizeof(struct tt__DisplayCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__DisplayCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__DisplayCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DisplayCapabilities, sizeof(struct tt__DisplayCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DisplayCapabilities(struct soap *soap, struct tt__DisplayCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__DisplayCapabilities);
	if (soap_out_PointerTott__DisplayCapabilities(soap, tag?tag:"tt:DisplayCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DisplayCapabilities ** SOAP_FMAC4 soap_get_PointerTott__DisplayCapabilities(struct soap *soap, struct tt__DisplayCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DisplayCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingCapabilities(struct soap *soap, struct tt__RecordingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->XAddr);
	soap_default_xsd__boolean_(soap, &a->ReceiverSource);
	soap_default_xsd__boolean_(soap, &a->MediaProfileSource);
	soap_default_xsd__boolean_(soap, &a->DynamicRecordings);
	soap_default_xsd__boolean_(soap, &a->DynamicTracks);
	soap_default_int(soap, &a->MaxStringLength);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingCapabilities(struct soap *soap, const struct tt__RecordingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->XAddr);
	soap_embedded(soap, &a->ReceiverSource, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->MediaProfileSource, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->DynamicRecordings, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->DynamicTracks, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->MaxStringLength, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingCapabilities(struct soap *soap, const char *tag, int id, const struct tt__RecordingCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	if (soap_out_string(soap, "tt:XAddr", -1, &a->XAddr, ""))
	return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XAddr"))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:ReceiverSource", -1, &a->ReceiverSource, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:MediaProfileSource", -1, &a->MediaProfileSource, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:DynamicRecordings", -1, &a->DynamicRecordings, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:DynamicTracks", -1, &a->DynamicTracks, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:MaxStringLength", -1, &a->MaxStringLength, ""))
		return soap->error;
	if (a->__any)
	{	int i;
	for (i = 0; i < a->__size; i++)
		soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingCapabilities * SOAP_FMAC4 soap_in_tt__RecordingCapabilities(struct soap *soap, const char *tag, struct tt__RecordingCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_ReceiverSource = 1;
	size_t soap_flag_MediaProfileSource = 1;
	size_t soap_flag_DynamicRecordings = 1;
	size_t soap_flag_DynamicTracks = 1;
	size_t soap_flag_MaxStringLength = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingCapabilities, sizeof(struct tt__RecordingCapabilities), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__RecordingCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:XAddr", &a->XAddr, "xsd:string"))
				{	
					soap_flag_XAddr--;
					continue;
				}
				if (soap_flag_ReceiverSource && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_xsd__boolean_(soap, "tt:ReceiverSource", &a->ReceiverSource, "xsd:boolean"))
					{	
						soap_flag_ReceiverSource--;
						continue;
					}
					if (soap_flag_MediaProfileSource && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_xsd__boolean_(soap, "tt:MediaProfileSource", &a->MediaProfileSource, "xsd:boolean"))
						{	
							soap_flag_MediaProfileSource--;
							continue;
						}
						if (soap_flag_DynamicRecordings && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_xsd__boolean_(soap, "tt:DynamicRecordings", &a->DynamicRecordings, "xsd:boolean"))
							{	
								soap_flag_DynamicRecordings--;
								continue;
							}
							if (soap_flag_DynamicTracks && soap->error == SOAP_TAG_MISMATCH)
								if (soap_in_xsd__boolean_(soap, "tt:DynamicTracks", &a->DynamicTracks, "xsd:boolean"))
								{	
									soap_flag_DynamicTracks--;
									continue;
								}
								if (soap_flag_MaxStringLength && soap->error == SOAP_TAG_MISMATCH)
									if (soap_in_int(soap, "tt:MaxStringLength", &a->MaxStringLength, "xsd:int"))
									{	
										soap_flag_MaxStringLength--;
										continue;
									}
									if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
									{	
										if (a->__any == NULL)
										{	
											if (soap_blist___any == NULL)
												soap_blist___any = soap_new_block(soap);
											a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
											if (a->__any == NULL)
												return NULL;
											*a->__any = NULL;
										}
										if (soap_inliteral(soap, "-any", a->__any))
										{	
											a->__size++;
											a->__any = NULL;
											continue;
										}
									}
									if (soap->error == SOAP_TAG_MISMATCH)
										soap->error = soap_ignore_element(soap);
									if (soap->error == SOAP_NO_TAG)
										break;
									if (soap->error)
										return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__RecordingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingCapabilities, 0, sizeof(struct tt__RecordingCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0 || soap_flag_ReceiverSource > 0 || soap_flag_MediaProfileSource > 0 || soap_flag_DynamicRecordings > 0 || soap_flag_DynamicTracks > 0 || soap_flag_MaxStringLength > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingCapabilities(struct soap *soap, const struct tt__RecordingCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RecordingCapabilities);
	if (soap_out_tt__RecordingCapabilities(soap, tag?tag:"tt:RecordingCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingCapabilities * SOAP_FMAC4 soap_get_tt__RecordingCapabilities(struct soap *soap, struct tt__RecordingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingCapabilities(struct soap *soap, struct tt__RecordingCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingCapabilities))
		soap_serialize_tt__RecordingCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingCapabilities(struct soap *soap, const char *tag, int id, struct tt__RecordingCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingCapabilities ** SOAP_FMAC4 soap_in_PointerTott__RecordingCapabilities(struct soap *soap, const char *tag, struct tt__RecordingCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__RecordingCapabilities **)soap_malloc(soap, sizeof(struct tt__RecordingCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__RecordingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingCapabilities, sizeof(struct tt__RecordingCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingCapabilities(struct soap *soap, struct tt__RecordingCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingCapabilities);
	if (soap_out_PointerTott__RecordingCapabilities(soap, tag?tag:"tt:RecordingCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingCapabilities ** SOAP_FMAC4 soap_get_PointerTott__RecordingCapabilities(struct soap *soap, struct tt__RecordingCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SearchCapabilities(struct soap *soap, struct tt__SearchCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->XAddr);
	soap_default_xsd__boolean_(soap, &a->MetadataSearch);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SearchCapabilities(struct soap *soap, const struct tt__SearchCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->XAddr);
	soap_embedded(soap, &a->MetadataSearch, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SearchCapabilities(struct soap *soap, const char *tag, int id, const struct tt__SearchCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SearchCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	if (soap_out_string(soap, "tt:XAddr", -1, &a->XAddr, ""))
	return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XAddr"))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:MetadataSearch", -1, &a->MetadataSearch, ""))
		return soap->error;
	if (a->__any)
	{	int i;
	for (i = 0; i < a->__size; i++)
		soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SearchCapabilities * SOAP_FMAC4 soap_in_tt__SearchCapabilities(struct soap *soap, const char *tag, struct tt__SearchCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_MetadataSearch = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SearchCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SearchCapabilities, sizeof(struct tt__SearchCapabilities), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__SearchCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:XAddr", &a->XAddr, "xsd:string"))
				{	
					soap_flag_XAddr--;
					continue;
				}
				if (soap_flag_MetadataSearch && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_xsd__boolean_(soap, "tt:MetadataSearch", &a->MetadataSearch, "xsd:boolean"))
					{	
						soap_flag_MetadataSearch--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
					{	
						if (a->__any == NULL)
						{	
							if (soap_blist___any == NULL)
								soap_blist___any = soap_new_block(soap);
							a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
							if (a->__any == NULL)
								return NULL;
							*a->__any = NULL;
						}
						if (soap_inliteral(soap, "-any", a->__any))
						{	
							a->__size++;
							a->__any = NULL;
							continue;
						}
					}
					if (soap->error == SOAP_TAG_MISMATCH)
						soap->error = soap_ignore_element(soap);
					if (soap->error == SOAP_NO_TAG)
						break;
					if (soap->error)
						return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__SearchCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SearchCapabilities, 0, sizeof(struct tt__SearchCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0 || soap_flag_MetadataSearch > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SearchCapabilities(struct soap *soap, const struct tt__SearchCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SearchCapabilities);
	if (soap_out_tt__SearchCapabilities(soap, tag?tag:"tt:SearchCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SearchCapabilities * SOAP_FMAC4 soap_get_tt__SearchCapabilities(struct soap *soap, struct tt__SearchCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SearchCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SearchCapabilities(struct soap *soap, struct tt__SearchCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SearchCapabilities))
		soap_serialize_tt__SearchCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SearchCapabilities(struct soap *soap, const char *tag, int id, struct tt__SearchCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SearchCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SearchCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SearchCapabilities ** SOAP_FMAC4 soap_in_PointerTott__SearchCapabilities(struct soap *soap, const char *tag, struct tt__SearchCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__SearchCapabilities **)soap_malloc(soap, sizeof(struct tt__SearchCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__SearchCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__SearchCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SearchCapabilities, sizeof(struct tt__SearchCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SearchCapabilities(struct soap *soap, struct tt__SearchCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SearchCapabilities);
	if (soap_out_PointerTott__SearchCapabilities(soap, tag?tag:"tt:SearchCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SearchCapabilities ** SOAP_FMAC4 soap_get_PointerTott__SearchCapabilities(struct soap *soap, struct tt__SearchCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SearchCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ReplayCapabilities(struct soap *soap, struct tt__ReplayCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->XAddr);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReplayCapabilities(struct soap *soap, const struct tt__ReplayCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->XAddr);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReplayCapabilities(struct soap *soap, const char *tag, int id, const struct tt__ReplayCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReplayCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	
		if (soap_out_string(soap, "tt:XAddr", -1, &a->XAddr, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XAddr"))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ReplayCapabilities * SOAP_FMAC4 soap_in_tt__ReplayCapabilities(struct soap *soap, const char *tag, struct tt__ReplayCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ReplayCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReplayCapabilities, sizeof(struct tt__ReplayCapabilities), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__ReplayCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:XAddr", &a->XAddr, "xsd:string"))
				{	
					soap_flag_XAddr--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
				{	
					if (a->__any == NULL)
					{	
						if (soap_blist___any == NULL)
							soap_blist___any = soap_new_block(soap);
						a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
						if (a->__any == NULL)
							return NULL;
						*a->__any = NULL;
					}
					if (soap_inliteral(soap, "-any", a->__any))
					{	
						a->__size++;
						a->__any = NULL;
						continue;
					}
				}
				if (soap->error == SOAP_TAG_MISMATCH)
					soap->error = soap_ignore_element(soap);
				if (soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__ReplayCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReplayCapabilities, 0, sizeof(struct tt__ReplayCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReplayCapabilities(struct soap *soap, const struct tt__ReplayCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ReplayCapabilities);
	if (soap_out_tt__ReplayCapabilities(soap, tag?tag:"tt:ReplayCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReplayCapabilities * SOAP_FMAC4 soap_get_tt__ReplayCapabilities(struct soap *soap, struct tt__ReplayCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReplayCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReplayCapabilities(struct soap *soap, struct tt__ReplayCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReplayCapabilities))
		soap_serialize_tt__ReplayCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReplayCapabilities(struct soap *soap, const char *tag, int id, struct tt__ReplayCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReplayCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ReplayCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ReplayCapabilities ** SOAP_FMAC4 soap_in_PointerTott__ReplayCapabilities(struct soap *soap, const char *tag, struct tt__ReplayCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__ReplayCapabilities **)soap_malloc(soap, sizeof(struct tt__ReplayCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_tt__ReplayCapabilities(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	
		a = (struct tt__ReplayCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReplayCapabilities, sizeof(struct tt__ReplayCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReplayCapabilities(struct soap *soap, struct tt__ReplayCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ReplayCapabilities);
	if (soap_out_PointerTott__ReplayCapabilities(soap, tag?tag:"tt:ReplayCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReplayCapabilities ** SOAP_FMAC4 soap_get_PointerTott__ReplayCapabilities(struct soap *soap, struct tt__ReplayCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReplayCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ReceiverCapabilities(struct soap *soap, struct tt__ReceiverCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->XAddr);
	soap_default_xsd__boolean_(soap, &a->RTP_USCOREMulticast);
	soap_default_xsd__boolean_(soap, &a->RTP_USCORETCP);
	soap_default_xsd__boolean_(soap, &a->RTP_USCORERTSP_USCORETCP);
	soap_default_int(soap, &a->SupportedReceivers);
	soap_default_int(soap, &a->MaximumRTSPURILength);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReceiverCapabilities(struct soap *soap, const struct tt__ReceiverCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->XAddr);
	soap_embedded(soap, &a->RTP_USCOREMulticast, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->RTP_USCORETCP, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->RTP_USCORERTSP_USCORETCP, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->SupportedReceivers, SOAP_TYPE_int);
	soap_embedded(soap, &a->MaximumRTSPURILength, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReceiverCapabilities(struct soap *soap, const char *tag, int id, const struct tt__ReceiverCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReceiverCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	if (soap_out_string(soap, "tt:XAddr", -1, &a->XAddr, ""))
	return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XAddr"))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:RTP_Multicast", -1, &a->RTP_USCOREMulticast, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:RTP_TCP", -1, &a->RTP_USCORETCP, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:RTP_RTSP_TCP", -1, &a->RTP_USCORERTSP_USCORETCP, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:SupportedReceivers", -1, &a->SupportedReceivers, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:MaximumRTSPURILength", -1, &a->MaximumRTSPURILength, ""))
		return soap->error;
	if (a->__any)
	{	int i;
	for (i = 0; i < a->__size; i++)
		soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ReceiverCapabilities * SOAP_FMAC4 soap_in_tt__ReceiverCapabilities(struct soap *soap, const char *tag, struct tt__ReceiverCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_RTP_USCOREMulticast = 1;
	size_t soap_flag_RTP_USCORETCP = 1;
	size_t soap_flag_RTP_USCORERTSP_USCORETCP = 1;
	size_t soap_flag_SupportedReceivers = 1;
	size_t soap_flag_MaximumRTSPURILength = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ReceiverCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReceiverCapabilities, sizeof(struct tt__ReceiverCapabilities), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__ReceiverCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:XAddr", &a->XAddr, "xsd:string"))
				{	
					soap_flag_XAddr--;
					continue;
				}
				if (soap_flag_RTP_USCOREMulticast && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_xsd__boolean_(soap, "tt:RTP_Multicast", &a->RTP_USCOREMulticast, "xsd:boolean"))
					{	
						soap_flag_RTP_USCOREMulticast--;
						continue;
					}
					if (soap_flag_RTP_USCORETCP && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_xsd__boolean_(soap, "tt:RTP_TCP", &a->RTP_USCORETCP, "xsd:boolean"))
						{	
							soap_flag_RTP_USCORETCP--;
							continue;
						}
						if (soap_flag_RTP_USCORERTSP_USCORETCP && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_xsd__boolean_(soap, "tt:RTP_RTSP_TCP", &a->RTP_USCORERTSP_USCORETCP, "xsd:boolean"))
							{	
								soap_flag_RTP_USCORERTSP_USCORETCP--;
								continue;
							}
							if (soap_flag_SupportedReceivers && soap->error == SOAP_TAG_MISMATCH)
								if (soap_in_int(soap, "tt:SupportedReceivers", &a->SupportedReceivers, "xsd:int"))
								{	
									soap_flag_SupportedReceivers--;
									continue;
								}
								if (soap_flag_MaximumRTSPURILength && soap->error == SOAP_TAG_MISMATCH)
									if (soap_in_int(soap, "tt:MaximumRTSPURILength", &a->MaximumRTSPURILength, "xsd:int"))
									{	
										soap_flag_MaximumRTSPURILength--;
										continue;
									}
									if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
									{	
										if (a->__any == NULL)
										{	
											if (soap_blist___any == NULL)
												soap_blist___any = soap_new_block(soap);
											a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
											if (a->__any == NULL)
												return NULL;
											*a->__any = NULL;
										}
										if (soap_inliteral(soap, "-any", a->__any))
										{	
											a->__size++;
											a->__any = NULL;
											continue;
										}
									}
									if (soap->error == SOAP_TAG_MISMATCH)
										soap->error = soap_ignore_element(soap);
									if (soap->error == SOAP_NO_TAG)
										break;
									if (soap->error)
										return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__ReceiverCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReceiverCapabilities, 0, sizeof(struct tt__ReceiverCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0 || soap_flag_RTP_USCOREMulticast > 0 || soap_flag_RTP_USCORETCP > 0 || soap_flag_RTP_USCORERTSP_USCORETCP > 0 || soap_flag_SupportedReceivers > 0 || soap_flag_MaximumRTSPURILength > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReceiverCapabilities(struct soap *soap, const struct tt__ReceiverCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ReceiverCapabilities);
	if (soap_out_tt__ReceiverCapabilities(soap, tag?tag:"tt:ReceiverCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReceiverCapabilities * SOAP_FMAC4 soap_get_tt__ReceiverCapabilities(struct soap *soap, struct tt__ReceiverCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReceiverCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReceiverCapabilities(struct soap *soap, struct tt__ReceiverCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReceiverCapabilities))
		soap_serialize_tt__ReceiverCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReceiverCapabilities(struct soap *soap, const char *tag, int id, struct tt__ReceiverCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReceiverCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ReceiverCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ReceiverCapabilities ** SOAP_FMAC4 soap_in_PointerTott__ReceiverCapabilities(struct soap *soap, const char *tag, struct tt__ReceiverCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a== NULL)
		if (!(a = (struct tt__ReceiverCapabilities **)soap_malloc(soap, sizeof(struct tt__ReceiverCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__ReceiverCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__ReceiverCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReceiverCapabilities, sizeof(struct tt__ReceiverCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReceiverCapabilities(struct soap *soap, struct tt__ReceiverCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ReceiverCapabilities);
	if (soap_out_PointerTott__ReceiverCapabilities(soap, tag?tag:"tt:ReceiverCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReceiverCapabilities ** SOAP_FMAC4 soap_get_PointerTott__ReceiverCapabilities(struct soap *soap, struct tt__ReceiverCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReceiverCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CapabilitiesExtension2(struct soap *soap, struct tt__CapabilitiesExtension2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CapabilitiesExtension2))
		soap_serialize_tt__CapabilitiesExtension2(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CapabilitiesExtension2(struct soap *soap, const char *tag, int id, struct tt__CapabilitiesExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CapabilitiesExtension2);
	if (id < 0)
		return soap->error;
	return soap_out_tt__CapabilitiesExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__CapabilitiesExtension2 ** SOAP_FMAC4 soap_in_PointerTott__CapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__CapabilitiesExtension2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__CapabilitiesExtension2 **)soap_malloc(soap, sizeof(struct tt__CapabilitiesExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__CapabilitiesExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__CapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CapabilitiesExtension2, sizeof(struct tt__CapabilitiesExtension2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CapabilitiesExtension2(struct soap *soap, struct tt__CapabilitiesExtension2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__CapabilitiesExtension2);
	if (soap_out_PointerTott__CapabilitiesExtension2(soap, tag?tag:"tt:CapabilitiesExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CapabilitiesExtension2 ** SOAP_FMAC4 soap_get_PointerTott__CapabilitiesExtension2(struct soap *soap, struct tt__CapabilitiesExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CapabilitiesExtension(struct soap *soap, struct tt__CapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->DeviceIO = NULL;
	a->Display = NULL;
	a->Recording = NULL;
	a->Search = NULL;
	a->Replay = NULL;
	a->Receiver = NULL;
	a->AnalyticsDevice = NULL;
	a->Extensions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CapabilitiesExtension(struct soap *soap, const struct tt__CapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__DeviceIOCapabilities(soap, &a->DeviceIO);
	soap_serialize_PointerTott__DisplayCapabilities(soap, &a->Display);
	soap_serialize_PointerTott__RecordingCapabilities(soap, &a->Recording);
	soap_serialize_PointerTott__SearchCapabilities(soap, &a->Search);
	soap_serialize_PointerTott__ReplayCapabilities(soap, &a->Replay);
	soap_serialize_PointerTott__ReceiverCapabilities(soap, &a->Receiver);
	//soap_serialize_PointerTott__AnalyticsDeviceCapabilities(soap, &a->AnalyticsDevice);
	soap_serialize_PointerTott__CapabilitiesExtension2(soap, &a->Extensions);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct tt__CapabilitiesExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CapabilitiesExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
	for (i = 0; i < a->__size; i++)
		soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	if (soap_out_PointerTott__DeviceIOCapabilities(soap, "tt:DeviceIO", -1, &a->DeviceIO, ""))
		return soap->error;
	if (soap_out_PointerTott__DisplayCapabilities(soap, "tt:Display", -1, &a->Display, ""))
		return soap->error;
	if (soap_out_PointerTott__RecordingCapabilities(soap, "tt:Recording", -1, &a->Recording, ""))
		return soap->error;
	if (soap_out_PointerTott__SearchCapabilities(soap, "tt:Search", -1, &a->Search, ""))
		return soap->error;
	if (soap_out_PointerTott__ReplayCapabilities(soap, "tt:Replay", -1, &a->Replay, ""))
		return soap->error;
	if (soap_out_PointerTott__ReceiverCapabilities(soap, "tt:Receiver", -1, &a->Receiver, ""))
		return soap->error;
	//if (soap_out_PointerTott__AnalyticsDeviceCapabilities(soap, "tt:AnalyticsDevice", -1, &a->AnalyticsDevice, ""))
	//	return soap->error;
	if (soap_out_PointerTott__CapabilitiesExtension2(soap, "tt:Extensions", -1, &a->Extensions, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__CapabilitiesExtension * SOAP_FMAC4 soap_in_tt__CapabilitiesExtension(struct soap *soap, const char *tag, struct tt__CapabilitiesExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_DeviceIO = 1;
	size_t soap_flag_Display = 1;
	size_t soap_flag_Recording = 1;
	size_t soap_flag_Search = 1;
	size_t soap_flag_Replay = 1;
	size_t soap_flag_Receiver = 1;
	size_t soap_flag_AnalyticsDevice = 1;
	size_t soap_flag_Extensions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__CapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CapabilitiesExtension, sizeof(struct tt__CapabilitiesExtension), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__CapabilitiesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap_flag_DeviceIO && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DeviceIOCapabilities(soap, "tt:DeviceIO", &a->DeviceIO, "tt:DeviceIOCapabilities"))
				{	
					soap_flag_DeviceIO--;
					continue;
				}
				if (soap_flag_Display && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__DisplayCapabilities(soap, "tt:Display", &a->Display, "tt:DisplayCapabilities"))
					{	
						soap_flag_Display--;
						continue;
					}
					if (soap_flag_Recording && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTott__RecordingCapabilities(soap, "tt:Recording", &a->Recording, "tt:RecordingCapabilities"))
						{	
							soap_flag_Recording--;
							continue;
						}
						if (soap_flag_Search && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_PointerTott__SearchCapabilities(soap, "tt:Search", &a->Search, "tt:SearchCapabilities"))
							{	
								soap_flag_Search--;
								continue;
							}
							if (soap_flag_Replay && soap->error == SOAP_TAG_MISMATCH)
								if (soap_in_PointerTott__ReplayCapabilities(soap, "tt:Replay", &a->Replay, "tt:ReplayCapabilities"))
								{	
									soap_flag_Replay--;
									continue;
								}
								if (soap_flag_Receiver && soap->error == SOAP_TAG_MISMATCH)
									if (soap_in_PointerTott__ReceiverCapabilities(soap, "tt:Receiver", &a->Receiver, "tt:ReceiverCapabilities"))
									{	
										soap_flag_Receiver--;
										continue;
									}
									//if (soap_flag_AnalyticsDevice && soap->error == SOAP_TAG_MISMATCH)
									//	if (soap_in_PointerTott__AnalyticsDeviceCapabilities(soap, "tt:AnalyticsDevice", &a->AnalyticsDevice, "tt:AnalyticsDeviceCapabilities"))
									//	{	soap_flag_AnalyticsDevice--;
									////		continue;
									//	}
									if (soap_flag_Extensions && soap->error == SOAP_TAG_MISMATCH)
										if (soap_in_PointerTott__CapabilitiesExtension2(soap, "tt:Extensions", &a->Extensions, "tt:CapabilitiesExtension2"))
										{	
											soap_flag_Extensions--;
											continue;
										}
										if (soap->error == SOAP_TAG_MISMATCH)
											soap->error = soap_ignore_element(soap);
										if (soap->error == SOAP_NO_TAG)
											break;
										if (soap->error)
											return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__CapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CapabilitiesExtension, 0, sizeof(struct tt__CapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CapabilitiesExtension(struct soap *soap, const struct tt__CapabilitiesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__CapabilitiesExtension);
	if (soap_out_tt__CapabilitiesExtension(soap, tag?tag:"tt:CapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CapabilitiesExtension * SOAP_FMAC4 soap_get_tt__CapabilitiesExtension(struct soap *soap, struct tt__CapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CapabilitiesExtension(struct soap *soap, struct tt__CapabilitiesExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CapabilitiesExtension))
		soap_serialize_tt__CapabilitiesExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CapabilitiesExtension(struct soap *soap, const char *tag, int id, struct tt__CapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__CapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__CapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__CapabilitiesExtension(struct soap *soap, const char *tag, struct tt__CapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__CapabilitiesExtension **)soap_malloc(soap, sizeof(struct tt__CapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__CapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__CapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CapabilitiesExtension, sizeof(struct tt__CapabilitiesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CapabilitiesExtension(struct soap *soap, struct tt__CapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__CapabilitiesExtension);
	if (soap_out_PointerTott__CapabilitiesExtension(soap, tag?tag:"tt:CapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__CapabilitiesExtension(struct soap *soap, struct tt__CapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Capabilities(struct soap *soap, struct tt__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Analytics = NULL;
	a->Device = NULL;
	a->Events = NULL;
	a->Imaging = NULL;
	a->Media = NULL;
	a->PTZ = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Capabilities(struct soap *soap, const struct tt__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	//soap_serialize_PointerTott__AnalyticsCapabilities(soap, &a->Analytics);
	soap_serialize_PointerTott__DeviceCapabilities(soap, &a->Device);
	soap_serialize_PointerTott__EventCapabilities(soap, &a->Events);
	soap_serialize_PointerTott__ImagingCapabilities(soap, &a->Imaging);
	soap_serialize_PointerTott__MediaCapabilities(soap, &a->Media);
	soap_serialize_PointerTott__PTZCapabilities(soap, &a->PTZ);
	soap_serialize_PointerTott__CapabilitiesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Capabilities(struct soap *soap, const char *tag, int id, const struct tt__Capabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Capabilities), type))
		return soap->error;
	//if (soap_out_PointerTott__AnalyticsCapabilities(soap, "tt:Analytics", -1, &a->Analytics, ""))
	//	return soap->error;
	if (soap_out_PointerTott__DeviceCapabilities(soap, "tt:Device", -1, &a->Device, ""))
		return soap->error;
	if (soap_out_PointerTott__EventCapabilities(soap, "tt:Events", -1, &a->Events, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingCapabilities(soap, "tt:Imaging", -1, &a->Imaging, ""))
		return soap->error;
	if (soap_out_PointerTott__MediaCapabilities(soap, "tt:Media", -1, &a->Media, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZCapabilities(soap, "tt:PTZ", -1, &a->PTZ, ""))
		return soap->error;
	if (soap_out_PointerTott__CapabilitiesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Capabilities * SOAP_FMAC4 soap_in_tt__Capabilities(struct soap *soap, const char *tag, struct tt__Capabilities *a, const char *type)
{
	size_t soap_flag_Analytics = 1;
	size_t soap_flag_Device = 1;
	size_t soap_flag_Events = 1;
	size_t soap_flag_Imaging = 1;
	size_t soap_flag_Media = 1;
	size_t soap_flag_PTZ = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Capabilities, sizeof(struct tt__Capabilities), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__Capabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			//if (soap_flag_Analytics && soap->error == SOAP_TAG_MISMATCH)
			//	if (soap_in_PointerTott__AnalyticsCapabilities(soap, "tt:Analytics", &a->Analytics, "tt:AnalyticsCapabilities"))
			//	{	soap_flag_Analytics--;
			//		continue;
			//	}
			if (soap_flag_Device && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DeviceCapabilities(soap, "tt:Device", &a->Device, "tt:DeviceCapabilities"))
				{	
					soap_flag_Device--;
					continue;
				}
				if (soap_flag_Events && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__EventCapabilities(soap, "tt:Events", &a->Events, "tt:EventCapabilities"))
					{	
						soap_flag_Events--;
						continue;
					}
					if (soap_flag_Imaging && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTott__ImagingCapabilities(soap, "tt:Imaging", &a->Imaging, "tt:ImagingCapabilities"))
						{	
							soap_flag_Imaging--;
							continue;
						}
						if (soap_flag_Media && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_PointerTott__MediaCapabilities(soap, "tt:Media", &a->Media, "tt:MediaCapabilities"))
							{	
								soap_flag_Media--;
								continue;
							}
							if (soap_flag_PTZ && soap->error == SOAP_TAG_MISMATCH)
								if (soap_in_PointerTott__PTZCapabilities(soap, "tt:PTZ", &a->PTZ, "tt:PTZCapabilities"))
								{	
									soap_flag_PTZ--;
									continue;
								}
								if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
									if (soap_in_PointerTott__CapabilitiesExtension(soap, "tt:Extension", &a->Extension, "tt:CapabilitiesExtension"))
									{	
										soap_flag_Extension--;
										continue;
									}
									if (soap->error == SOAP_TAG_MISMATCH)
										soap->error = soap_ignore_element(soap);
									if (soap->error == SOAP_NO_TAG)
										break;
									if (soap->error)
										return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Capabilities, 0, sizeof(struct tt__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Capabilities(struct soap *soap, const struct tt__Capabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Capabilities);
	if (soap_out_tt__Capabilities(soap, tag?tag:"tt:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Capabilities * SOAP_FMAC4 soap_get_tt__Capabilities(struct soap *soap, struct tt__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Capabilities(struct soap *soap, struct tt__Capabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Capabilities))
		soap_serialize_tt__Capabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Capabilities(struct soap *soap, const char *tag, int id, struct tt__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Capabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Capabilities ** SOAP_FMAC4 soap_in_PointerTott__Capabilities(struct soap *soap, const char *tag, struct tt__Capabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Capabilities **)soap_malloc(soap, sizeof(struct tt__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_tt__Capabilities(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct tt__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Capabilities, sizeof(struct tt__Capabilities), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Capabilities(struct soap *soap, struct tt__Capabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Capabilities);
	if (soap_out_PointerTott__Capabilities(soap, tag?tag:"tt:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Capabilities ** SOAP_FMAC4 soap_get_PointerTott__Capabilities(struct soap *soap, struct tt__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCapabilitiesResponse(struct soap *soap, struct _tds__GetCapabilitiesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCapabilitiesResponse))
		soap_serialize__tds__GetCapabilitiesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _tds__GetCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, struct _tds__GetCapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__GetCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _tds__GetCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__GetCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCapabilitiesResponse, sizeof(struct _tds__GetCapabilitiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCapabilitiesResponse(struct soap *soap, struct _tds__GetCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCapabilitiesResponse);
	if (soap_out_PointerTo_tds__GetCapabilitiesResponse(soap, tag?tag:"tds:GetCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCapabilitiesResponse(struct soap *soap, struct _tds__GetCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCapabilities(struct soap *soap, struct _tds__GetCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCapabilities))
		soap_serialize__tds__GetCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCapabilities(struct soap *soap, const char *tag, int id, struct _tds__GetCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCapabilities(struct soap *soap, const char *tag, struct _tds__GetCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetCapabilities **)soap_malloc(soap, sizeof(struct _tds__GetCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in__tds__GetCapabilities(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct _tds__GetCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCapabilities, sizeof(struct _tds__GetCapabilities), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCapabilities(struct soap *soap, struct _tds__GetCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCapabilities);
	if (soap_out_PointerTo_tds__GetCapabilities(soap, tag?tag:"tds:GetCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCapabilities(struct soap *soap, struct _tds__GetCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetCapabilities(struct soap *soap, struct __tds__GetCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetCapabilities(struct soap *soap, const struct __tds__GetCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetCapabilities(soap, &a->tds__GetCapabilities);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetCapabilities(struct soap *soap, const char *tag, int id, const struct __tds__GetCapabilities *a, const char *type)
{
	if (soap_out_PointerTo_tds__GetCapabilities(soap, "tds:GetCapabilities", -1, &a->tds__GetCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCapabilities * SOAP_FMAC4 soap_in___tds__GetCapabilities(struct soap *soap, const char *tag, struct __tds__GetCapabilities *a, const char *type)
{
	size_t soap_flag_tds__GetCapabilities = 1;
	short soap_flag;
	a = (struct __tds__GetCapabilities *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetCapabilities, sizeof(struct __tds__GetCapabilities), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___tds__GetCapabilities(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__GetCapabilities && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__GetCapabilities(soap, "tds:GetCapabilities", &a->tds__GetCapabilities, ""))
			{	
				soap_flag_tds__GetCapabilities--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetCapabilities(struct soap *soap, const struct __tds__GetCapabilities *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetCapabilities(soap, tag?tag:"-tds:GetCapabilities", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCapabilities * SOAP_FMAC4 soap_get___tds__GetCapabilities(struct soap *soap, struct __tds__GetCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCapabilities(struct soap *soap, struct _tds__GetCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeCategory = 0;
	a->Category = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCapabilities(struct soap *soap, const struct _tds__GetCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Category)
	{	
		int i;
		for (i = 0; i < a->__sizeCategory; i++)
		{
			soap_embedded(soap, a->Category + i, SOAP_TYPE_tt__CapabilityCategory);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCapabilities(struct soap *soap, const char *tag, int id, const struct _tds__GetCapabilities *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCapabilities), type))
		return soap->error;
	if (a->Category)
	{	
		int i;
		for (i = 0; i < a->__sizeCategory; i++)
			if (soap_out_tt__CapabilityCategory(soap, "tds:Category", -1, a->Category + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCapabilities * SOAP_FMAC4 soap_in__tds__GetCapabilities(struct soap *soap, const char *tag, struct _tds__GetCapabilities *a, const char *type)
{
	struct soap_blist *soap_blist_Category = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCapabilities, sizeof(struct _tds__GetCapabilities), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__GetCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Category", 1, NULL))
			{	
				if (a->Category == NULL)
				{	
					if (soap_blist_Category == NULL)
						soap_blist_Category = soap_new_block(soap);
					a->Category = (enum tt__CapabilityCategory *)soap_push_block(soap, soap_blist_Category, sizeof(enum tt__CapabilityCategory));
					if (a->Category == NULL)
						return NULL;
					soap_default_tt__CapabilityCategory(soap, a->Category);
				}
				soap_revert(soap);
				if (soap_in_tt__CapabilityCategory(soap, "tds:Category", a->Category, "tt:CapabilityCategory"))
				{	
					a->__sizeCategory++;
					a->Category = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Category)
			soap_pop_block(soap, soap_blist_Category);
		if (a->__sizeCategory)
			a->Category = (enum tt__CapabilityCategory *)soap_save_block(soap, soap_blist_Category, NULL, 1);
		else
		{	
			a->Category = NULL;
			if (soap_blist_Category)
				soap_end_block(soap, soap_blist_Category);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCapabilities, 0, sizeof(struct _tds__GetCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCapabilities(struct soap *soap, const struct _tds__GetCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetCapabilities);
	if (soap_out__tds__GetCapabilities(soap, tag?tag:"tds:GetCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCapabilities * SOAP_FMAC4 soap_get__tds__GetCapabilities(struct soap *soap, struct _tds__GetCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCapabilitiesResponse(struct soap *soap, struct _tds__GetCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCapabilitiesResponse(struct soap *soap, const struct _tds__GetCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Capabilities(soap, &a->Capabilities);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetCapabilitiesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tds:Capabilities");
	if (a->Capabilities)
	{	
		if (soap_out_PointerTott__Capabilities(soap, "tds:Capabilities", -1, &a->Capabilities, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Capabilities"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCapabilitiesResponse * SOAP_FMAC4 soap_in__tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, struct _tds__GetCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCapabilitiesResponse, sizeof(struct _tds__GetCapabilitiesResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__GetCapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Capabilities(soap, "tds:Capabilities", &a->Capabilities, "tt:Capabilities"))
				{	
					soap_flag_Capabilities--;
					continue;
				}
				soap_check_result(soap, "tds:Capabilities");
				if (soap->error == SOAP_TAG_MISMATCH)
					soap->error = soap_ignore_element(soap);
				if (soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCapabilitiesResponse, 0, sizeof(struct _tds__GetCapabilitiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCapabilitiesResponse(struct soap *soap, const struct _tds__GetCapabilitiesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetCapabilitiesResponse);
	if (soap_out__tds__GetCapabilitiesResponse(soap, tag?tag:"tds:GetCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCapabilitiesResponse * SOAP_FMAC4 soap_get__tds__GetCapabilitiesResponse(struct soap *soap, struct _tds__GetCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

//system management
SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDeviceInformation(struct soap *aSoap, struct __tds__GetDeviceInformation *a)
{
	(void)aSoap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDeviceInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDeviceInformation(struct soap *aSoap, const struct __tds__GetDeviceInformation *a)
{
	(void)aSoap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetDeviceInformation(aSoap, &a->tds__GetDeviceInformation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDeviceInformation(struct soap *aSoap, const char *tag, int id, const struct __tds__GetDeviceInformation *a, const char *type)
{
	if (soap_out_PointerTo_tds__GetDeviceInformation(aSoap, "tds:GetDeviceInformation", -1, &a->tds__GetDeviceInformation, ""))
		return aSoap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDeviceInformation * SOAP_FMAC4 soap_in___tds__GetDeviceInformation(struct soap *aSoap, const char *tag, struct __tds__GetDeviceInformation *a, const char *type)
{
	size_t soap_flag_tds__GetDeviceInformation = 1;
	short soap_flag;
	a = (struct __tds__GetDeviceInformation *)soap_id_enter(aSoap, "", a, SOAP_TYPE___tds__GetDeviceInformation, sizeof(struct __tds__GetDeviceInformation), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___tds__GetDeviceInformation(aSoap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		aSoap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__GetDeviceInformation && aSoap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__GetDeviceInformation(aSoap, "tds:GetDeviceInformation", &a->tds__GetDeviceInformation, ""))
			{	
				soap_flag_tds__GetDeviceInformation--;
				continue;
			}
			if (aSoap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					aSoap->error = SOAP_OK;
					break;
				}
				if (soap_flag && aSoap->error == SOAP_NO_TAG)
					break;
				if (aSoap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDeviceInformation(struct soap *aSoap, const struct __tds__GetDeviceInformation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetDeviceInformation(aSoap, tag?tag:"-tds:GetDeviceInformation", id, a, type))
		return aSoap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDeviceInformation * SOAP_FMAC4 soap_get___tds__GetDeviceInformation(struct soap *aSoap, struct __tds__GetDeviceInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDeviceInformation(aSoap, tag, p, type)))
		if (soap_getindependent(aSoap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDeviceInformationResponse(struct soap *soap, struct _tds__GetDeviceInformationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDeviceInformationResponse))
		soap_serialize__tds__GetDeviceInformationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDeviceInformationResponse(struct soap *soap, const char *tag, int id, struct _tds__GetDeviceInformationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDeviceInformationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDeviceInformationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDeviceInformationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDeviceInformationResponse(struct soap *aSoap, const char *tag, struct _tds__GetDeviceInformationResponse **a, const char *type)
{
	if (soap_element_begin_in(aSoap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__GetDeviceInformationResponse **)soap_malloc(aSoap, sizeof(struct _tds__GetDeviceInformationResponse *))))
			return NULL;
	*a = NULL;
	if (!aSoap->null && *aSoap->href != '#')
	{	
		soap_revert(aSoap);
		if (!(*a = soap_in__tds__GetDeviceInformationResponse(aSoap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetDeviceInformationResponse **)soap_id_lookup(aSoap, aSoap->href, (void**)a, SOAP_TYPE__tds__GetDeviceInformationResponse, sizeof(struct _tds__GetDeviceInformationResponse), 0);
		if (aSoap->body && soap_element_end_in(aSoap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDeviceInformationResponse(struct soap *aSoap, struct _tds__GetDeviceInformationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(aSoap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDeviceInformationResponse);
	if (soap_out_PointerTo_tds__GetDeviceInformationResponse(aSoap, tag?tag:"tds:GetDeviceInformationResponse", id, a, type))
		return aSoap->error;
	return soap_putindependent(aSoap);
}

SOAP_FMAC3 struct _tds__GetDeviceInformationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDeviceInformationResponse(struct soap *aSoap, struct _tds__GetDeviceInformationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDeviceInformationResponse(aSoap, tag, p, type)))
		if (soap_getindependent(aSoap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDeviceInformation(struct soap *aSoap, struct _tds__GetDeviceInformation *const*a)
{
	if (!soap_reference(aSoap, *a, SOAP_TYPE__tds__GetDeviceInformation))
		soap_serialize__tds__GetDeviceInformation(aSoap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDeviceInformation(struct soap *aSoap, const char *tag, int id, struct _tds__GetDeviceInformation *const*a, const char *type)
{
	id = soap_element_id(aSoap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDeviceInformation);
	if (id < 0)
		return aSoap->error;
	return soap_out__tds__GetDeviceInformation(aSoap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDeviceInformation ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDeviceInformation(struct soap *aSoap, const char *tag, struct _tds__GetDeviceInformation **a, const char *type)
{
	if (soap_element_begin_in(aSoap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__GetDeviceInformation **)soap_malloc(aSoap, sizeof(struct _tds__GetDeviceInformation *))))
			return NULL;
	*a = NULL;
	if (!aSoap->null && *aSoap->href != '#')
	{	
		soap_revert(aSoap);
		if (!(*a = soap_in__tds__GetDeviceInformation(aSoap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetDeviceInformation **)soap_id_lookup(aSoap, aSoap->href, (void**)a, SOAP_TYPE__tds__GetDeviceInformation, sizeof(struct _tds__GetDeviceInformation), 0);
		if (aSoap->body && soap_element_end_in(aSoap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDeviceInformation(struct soap *aSoap, struct _tds__GetDeviceInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(aSoap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDeviceInformation);
	if (soap_out_PointerTo_tds__GetDeviceInformation(aSoap, tag?tag:"tds:GetDeviceInformation", id, a, type))
		return aSoap->error;
	return soap_putindependent(aSoap);
}

SOAP_FMAC3 struct _tds__GetDeviceInformation ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDeviceInformation(struct soap *aSoap, struct _tds__GetDeviceInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDeviceInformation(aSoap, tag, p, type)))
		if (soap_getindependent(aSoap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDeviceInformationResponse(struct soap *soap, struct _tds__GetDeviceInformationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Manufacturer);
	soap_default_string(soap, &a->Model);
	soap_default_string(soap, &a->FirmwareVersion);
	soap_default_string(soap, &a->SerialNumber);
	soap_default_string(soap, &a->HardwareId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDeviceInformationResponse(struct soap *soap, const struct _tds__GetDeviceInformationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Manufacturer);
	soap_serialize_string(soap, &a->Model);
	soap_serialize_string(soap, &a->FirmwareVersion);
	soap_serialize_string(soap, &a->SerialNumber);
	soap_serialize_string(soap, &a->HardwareId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDeviceInformationResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDeviceInformationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDeviceInformationResponse), type))
		return soap->error;
	if (a->Manufacturer)
		soap_element_result(soap, "tds:Manufacturer");
	if (a->Manufacturer)
	{	
		if (soap_out_string(soap, "tds:Manufacturer", -1, &a->Manufacturer, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Manufacturer"))
		return soap->error;
	if (a->Model)
	{	
		if (soap_out_string(soap, "tds:Model", -1, &a->Model, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Model"))
		return soap->error;
	if (a->FirmwareVersion)
	{	
		if (soap_out_string(soap, "tds:FirmwareVersion", -1, &a->FirmwareVersion, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:FirmwareVersion"))
		return soap->error;
	if (a->SerialNumber)
	{	
		if (soap_out_string(soap, "tds:SerialNumber", -1, &a->SerialNumber, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:SerialNumber"))
		return soap->error;
	if (a->HardwareId)
	{	
		if (soap_out_string(soap, "tds:HardwareId", -1, &a->HardwareId, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:HardwareId"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDeviceInformationResponse * SOAP_FMAC4 soap_in__tds__GetDeviceInformationResponse(struct soap *soap, const char *tag, struct _tds__GetDeviceInformationResponse *a, const char *type)
{
	size_t soap_flag_Manufacturer = 1;
	size_t soap_flag_Model = 1;
	size_t soap_flag_FirmwareVersion = 1;
	size_t soap_flag_SerialNumber = 1;
	size_t soap_flag_HardwareId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDeviceInformationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDeviceInformationResponse, sizeof(struct _tds__GetDeviceInformationResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__GetDeviceInformationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Manufacturer && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:Manufacturer", &a->Manufacturer, "xsd:string"))
				{	
					soap_flag_Manufacturer--;
					continue;
				}
				if (soap_flag_Model && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
					if (soap_in_string(soap, "tds:Model", &a->Model, "xsd:string"))
					{	
						soap_flag_Model--;
						continue;
					}
					if (soap_flag_FirmwareVersion && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
						if (soap_in_string(soap, "tds:FirmwareVersion", &a->FirmwareVersion, "xsd:string"))
						{	
							soap_flag_FirmwareVersion--;
							continue;
						}
						if (soap_flag_SerialNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
							if (soap_in_string(soap, "tds:SerialNumber", &a->SerialNumber, "xsd:string"))
							{	
								soap_flag_SerialNumber--;
								continue;
							}
							if (soap_flag_HardwareId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
								if (soap_in_string(soap, "tds:HardwareId", &a->HardwareId, "xsd:string"))
								{	
									soap_flag_HardwareId--;
									continue;
								}
								soap_check_result(soap, "tds:Manufacturer");
								if (soap->error == SOAP_TAG_MISMATCH)
									soap->error = soap_ignore_element(soap);
								if (soap->error == SOAP_NO_TAG)
									break;
								if (soap->error)
									return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetDeviceInformationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDeviceInformationResponse, 0, sizeof(struct _tds__GetDeviceInformationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Manufacturer > 0 || soap_flag_Model > 0 || soap_flag_FirmwareVersion > 0 || soap_flag_SerialNumber > 0 || soap_flag_HardwareId > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDeviceInformationResponse(struct soap *soap, const struct _tds__GetDeviceInformationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDeviceInformationResponse);
	if (soap_out__tds__GetDeviceInformationResponse(soap, tag?tag:"tds:GetDeviceInformationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDeviceInformationResponse * SOAP_FMAC4 soap_get__tds__GetDeviceInformationResponse(struct soap *soap, struct _tds__GetDeviceInformationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDeviceInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDeviceInformation(struct soap *soap, struct _tds__GetDeviceInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDeviceInformation(struct soap *soap, const struct _tds__GetDeviceInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDeviceInformation(struct soap *soap, const char *tag, int id, const struct _tds__GetDeviceInformation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDeviceInformation), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDeviceInformation * SOAP_FMAC4 soap_in__tds__GetDeviceInformation(struct soap *soap, const char *tag, struct _tds__GetDeviceInformation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDeviceInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDeviceInformation, sizeof(struct _tds__GetDeviceInformation), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__GetDeviceInformation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetDeviceInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDeviceInformation, 0, sizeof(struct _tds__GetDeviceInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDeviceInformation(struct soap *soap, const struct _tds__GetDeviceInformation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDeviceInformation);
	if (soap_out__tds__GetDeviceInformation(soap, tag?tag:"tds:GetDeviceInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDeviceInformation * SOAP_FMAC4 soap_get__tds__GetDeviceInformation(struct soap *soap, struct _tds__GetDeviceInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDeviceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetSystemDateAndTime(struct soap *soap, struct __tds__GetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetSystemDateAndTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetSystemDateAndTime(struct soap *soap, const struct __tds__GetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetSystemDateAndTime(soap, &a->tds__GetSystemDateAndTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetSystemDateAndTime(struct soap *soap, const char *tag, int id, const struct __tds__GetSystemDateAndTime *a, const char *type)
{
	if (soap_out_PointerTo_tds__GetSystemDateAndTime(soap, "tds:GetSystemDateAndTime", -1, &a->tds__GetSystemDateAndTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemDateAndTime * SOAP_FMAC4 soap_in___tds__GetSystemDateAndTime(struct soap *soap, const char *tag, struct __tds__GetSystemDateAndTime *a, const char *type)
{
	size_t soap_flag_tds__GetSystemDateAndTime = 1;
	short soap_flag;
	a = (struct __tds__GetSystemDateAndTime *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetSystemDateAndTime, sizeof(struct __tds__GetSystemDateAndTime), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___tds__GetSystemDateAndTime(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__GetSystemDateAndTime && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__GetSystemDateAndTime(soap, "tds:GetSystemDateAndTime", &a->tds__GetSystemDateAndTime, ""))
			{	
				soap_flag_tds__GetSystemDateAndTime--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetSystemDateAndTime(struct soap *soap, const struct __tds__GetSystemDateAndTime *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetSystemDateAndTime(soap, tag?tag:"-tds:GetSystemDateAndTime", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemDateAndTime * SOAP_FMAC4 soap_get___tds__GetSystemDateAndTime(struct soap *soap, struct __tds__GetSystemDateAndTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemDateAndTimeResponse(struct soap *soap, struct _tds__GetSystemDateAndTimeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemDateAndTimeResponse))
		soap_serialize__tds__GetSystemDateAndTimeResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemDateAndTimeResponse(struct soap *soap, const char *tag, int id, struct _tds__GetSystemDateAndTimeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemDateAndTimeResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemDateAndTimeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTimeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemDateAndTimeResponse(struct soap *soap, const char *tag, struct _tds__GetSystemDateAndTimeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__GetSystemDateAndTimeResponse **)soap_malloc(soap, sizeof(struct _tds__GetSystemDateAndTimeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemDateAndTimeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetSystemDateAndTimeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemDateAndTimeResponse, sizeof(struct _tds__GetSystemDateAndTimeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemDateAndTimeResponse(struct soap *soap, struct _tds__GetSystemDateAndTimeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemDateAndTimeResponse);
	if (soap_out_PointerTo_tds__GetSystemDateAndTimeResponse(soap, tag?tag:"tds:GetSystemDateAndTimeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTimeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemDateAndTimeResponse(struct soap *soap, struct _tds__GetSystemDateAndTimeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemDateAndTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, struct _tds__GetSystemDateAndTime *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemDateAndTime))
		soap_serialize__tds__GetSystemDateAndTime(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, const char *tag, int id, struct _tds__GetSystemDateAndTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemDateAndTime);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemDateAndTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTime ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, const char *tag, struct _tds__GetSystemDateAndTime **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__GetSystemDateAndTime **)soap_malloc(soap, sizeof(struct _tds__GetSystemDateAndTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemDateAndTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetSystemDateAndTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemDateAndTime, sizeof(struct _tds__GetSystemDateAndTime), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, struct _tds__GetSystemDateAndTime *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemDateAndTime);
	if (soap_out_PointerTo_tds__GetSystemDateAndTime(soap, tag?tag:"tds:GetSystemDateAndTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTime ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, struct _tds__GetSystemDateAndTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemDateAndTimeResponse(struct soap *soap, struct _tds__GetSystemDateAndTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SystemDateAndTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemDateAndTimeResponse(struct soap *soap, const struct _tds__GetSystemDateAndTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__SystemDateTime(soap, &a->SystemDateAndTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemDateAndTimeResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemDateAndTimeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemDateAndTimeResponse), type))
		return soap->error;
	if (a->SystemDateAndTime)
		soap_element_result(soap, "tds:SystemDateAndTime");
	if (a->SystemDateAndTime)
	{	
		if (soap_out_PointerTott__SystemDateTime(soap, "tds:SystemDateAndTime", -1, &a->SystemDateAndTime, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:SystemDateAndTime"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTimeResponse * SOAP_FMAC4 soap_in__tds__GetSystemDateAndTimeResponse(struct soap *soap, const char *tag, struct _tds__GetSystemDateAndTimeResponse *a, const char *type)
{
	size_t soap_flag_SystemDateAndTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetSystemDateAndTimeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemDateAndTimeResponse, sizeof(struct _tds__GetSystemDateAndTimeResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__GetSystemDateAndTimeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SystemDateAndTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SystemDateTime(soap, "tds:SystemDateAndTime", &a->SystemDateAndTime, "tt:SystemDateTime"))
				{	
					soap_flag_SystemDateAndTime--;
					continue;
				}
				soap_check_result(soap, "tds:SystemDateAndTime");
				if (soap->error == SOAP_TAG_MISMATCH)
					soap->error = soap_ignore_element(soap);
				if (soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetSystemDateAndTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemDateAndTimeResponse, 0, sizeof(struct _tds__GetSystemDateAndTimeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SystemDateAndTime > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemDateAndTimeResponse(struct soap *soap, const struct _tds__GetSystemDateAndTimeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetSystemDateAndTimeResponse);
	if (soap_out__tds__GetSystemDateAndTimeResponse(soap, tag?tag:"tds:GetSystemDateAndTimeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTimeResponse * SOAP_FMAC4 soap_get__tds__GetSystemDateAndTimeResponse(struct soap *soap, struct _tds__GetSystemDateAndTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemDateAndTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemDateAndTime(struct soap *soap, struct _tds__GetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemDateAndTime(struct soap *soap, const struct _tds__GetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemDateAndTime(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemDateAndTime *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemDateAndTime), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTime * SOAP_FMAC4 soap_in__tds__GetSystemDateAndTime(struct soap *soap, const char *tag, struct _tds__GetSystemDateAndTime *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetSystemDateAndTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemDateAndTime, sizeof(struct _tds__GetSystemDateAndTime), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__GetSystemDateAndTime(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetSystemDateAndTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemDateAndTime, 0, sizeof(struct _tds__GetSystemDateAndTime), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemDateAndTime(struct soap *soap, const struct _tds__GetSystemDateAndTime *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetSystemDateAndTime);
	if (soap_out__tds__GetSystemDateAndTime(soap, tag?tag:"tds:GetSystemDateAndTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTime * SOAP_FMAC4 soap_get__tds__GetSystemDateAndTime(struct soap *soap, struct _tds__GetSystemDateAndTime *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemDateTime(struct soap *soap, struct tt__SystemDateTime *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemDateTime))
		soap_serialize_tt__SystemDateTime(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemDateTime(struct soap *soap, const char *tag, int id, struct tt__SystemDateTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemDateTime);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SystemDateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SystemDateTime ** SOAP_FMAC4 soap_in_PointerTott__SystemDateTime(struct soap *soap, const char *tag, struct tt__SystemDateTime **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__SystemDateTime **)soap_malloc(soap, sizeof(struct tt__SystemDateTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__SystemDateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__SystemDateTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemDateTime, sizeof(struct tt__SystemDateTime), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemDateTime(struct soap *soap, struct tt__SystemDateTime *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SystemDateTime);
	if (soap_out_PointerTott__SystemDateTime(soap, tag?tag:"tt:SystemDateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemDateTime ** SOAP_FMAC4 soap_get_PointerTott__SystemDateTime(struct soap *soap, struct tt__SystemDateTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemDateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DateTime(struct soap *soap, struct tt__DateTime *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DateTime))
		soap_serialize_tt__DateTime(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DateTime(struct soap *soap, const char *tag, int id, struct tt__DateTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DateTime);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DateTime ** SOAP_FMAC4 soap_in_PointerTott__DateTime(struct soap *soap, const char *tag, struct tt__DateTime **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__DateTime **)soap_malloc(soap, sizeof(struct tt__DateTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__DateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__DateTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DateTime, sizeof(struct tt__DateTime), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DateTime(struct soap *soap, struct tt__DateTime *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__DateTime);
	if (soap_out_PointerTott__DateTime(soap, tag?tag:"tt:DateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DateTime ** SOAP_FMAC4 soap_get_PointerTott__DateTime(struct soap *soap, struct tt__DateTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TimeZone(struct soap *soap, struct tt__TimeZone *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TimeZone))
		soap_serialize_tt__TimeZone(soap, *a);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TimeZone(struct soap *soap, const char *tag, int id, struct tt__TimeZone *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TimeZone);
	if (id < 0)
		return soap->error;
	return soap_out_tt__TimeZone(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__TimeZone ** SOAP_FMAC4 soap_in_PointerTott__TimeZone(struct soap *soap, const char *tag, struct tt__TimeZone **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__TimeZone **)soap_malloc(soap, sizeof(struct tt__TimeZone *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__TimeZone(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__TimeZone **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TimeZone, sizeof(struct tt__TimeZone), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TimeZone(struct soap *soap, struct tt__TimeZone *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__TimeZone);
	if (soap_out_PointerTott__TimeZone(soap, tag?tag:"tt:TimeZone", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TimeZone ** SOAP_FMAC4 soap_get_PointerTott__TimeZone(struct soap *soap, struct tt__TimeZone **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TimeZone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemDateTimeExtension(struct soap *soap, struct tt__SystemDateTimeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemDateTimeExtension(struct soap *soap, const struct tt__SystemDateTimeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemDateTimeExtension(struct soap *soap, const char *tag, int id, const struct tt__SystemDateTimeExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemDateTimeExtension), type))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemDateTimeExtension * SOAP_FMAC4 soap_in_tt__SystemDateTimeExtension(struct soap *soap, const char *tag, struct tt__SystemDateTimeExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SystemDateTimeExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemDateTimeExtension, sizeof(struct tt__SystemDateTimeExtension), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__SystemDateTimeExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
				soap_blist___any = soap_new_block(soap);
				a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
				if (a->__any == NULL)
					return NULL;
				*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__SystemDateTimeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemDateTimeExtension, 0, sizeof(struct tt__SystemDateTimeExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemDateTimeExtension(struct soap *soap, const struct tt__SystemDateTimeExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SystemDateTimeExtension);
	if (soap_out_tt__SystemDateTimeExtension(soap, tag?tag:"tt:SystemDateTimeExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemDateTimeExtension * SOAP_FMAC4 soap_get_tt__SystemDateTimeExtension(struct soap *soap, struct tt__SystemDateTimeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemDateTimeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SetDateTimeType(struct soap *soap, enum tt__SetDateTimeType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__SetDateTimeType
	*a = SOAP_DEFAULT_tt__SetDateTimeType;
#else
	*a = (enum tt__SetDateTimeType)0;
#endif
}

static const struct soap_code_map soap_codes_tt__SetDateTimeType[] =
{	
	{ (long)tt__SetDateTimeType__Manual, "Manual" },
	{ (long)tt__SetDateTimeType__NTP, "NTP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__SetDateTimeType2s(struct soap *soap, enum tt__SetDateTimeType n)
{	
	const char *s = soap_code_str(soap_codes_tt__SetDateTimeType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SetDateTimeType(struct soap *soap, const char *tag, int id, const enum tt__SetDateTimeType *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SetDateTimeType), type) || soap_send(soap, soap_tt__SetDateTimeType2s(soap, *a)))
	return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__SetDateTimeType(struct soap *soap, const char *s, enum tt__SetDateTimeType *a)
{
	const struct soap_code_map *map;
	if (s == NULL)
		return soap->error;
	map = soap_code(soap_codes_tt__SetDateTimeType, s);
	if (map)
		*a = (enum tt__SetDateTimeType)map->code;
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__SetDateTimeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__SetDateTimeType * SOAP_FMAC4 soap_in_tt__SetDateTimeType(struct soap *soap, const char *tag, enum tt__SetDateTimeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	return NULL;
	a = (enum tt__SetDateTimeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SetDateTimeType, sizeof(enum tt__SetDateTimeType), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	if (soap->body && !*soap->href)
	{	
		if (!a || soap_s2tt__SetDateTimeType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (enum tt__SetDateTimeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SetDateTimeType, 0, sizeof(enum tt__SetDateTimeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SetDateTimeType(struct soap *soap, const enum tt__SetDateTimeType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SetDateTimeType);
	if (soap_out_tt__SetDateTimeType(soap, tag?tag:"tt:SetDateTimeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__SetDateTimeType * SOAP_FMAC4 soap_get_tt__SetDateTimeType(struct soap *soap, enum tt__SetDateTimeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SetDateTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemDateTime(struct soap *soap, struct tt__SystemDateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SetDateTimeType(soap, &a->DateTimeType);
	soap_default_xsd__boolean_(soap, &a->DaylightSavings);
	a->TimeZone = NULL;
	a->UTCDateTime = NULL;
	a->LocalDateTime = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemDateTime(struct soap *soap, const struct tt__SystemDateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->DaylightSavings, SOAP_TYPE_xsd__boolean_);
	soap_serialize_PointerTott__TimeZone(soap, &a->TimeZone);
	soap_serialize_PointerTott__DateTime(soap, &a->UTCDateTime);
	soap_serialize_PointerTott__DateTime(soap, &a->LocalDateTime);
	soap_serialize_PointerTott__SystemDateTimeExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemDateTime(struct soap *soap, const char *tag, int id, const struct tt__SystemDateTime *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemDateTime), type))
		return soap->error;
	if (soap_out_tt__SetDateTimeType(soap, "tt:DateTimeType", -1, &a->DateTimeType, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:DaylightSavings", -1, &a->DaylightSavings, ""))
		return soap->error;
	if (soap_out_PointerTott__TimeZone(soap, "tt:TimeZone", -1, &a->TimeZone, ""))
		return soap->error;
	if (soap_out_PointerTott__DateTime(soap, "tt:UTCDateTime", -1, &a->UTCDateTime, ""))
		return soap->error;
	if (soap_out_PointerTott__DateTime(soap, "tt:LocalDateTime", -1, &a->LocalDateTime, ""))
		return soap->error;
	if (soap_out_PointerTott__SystemDateTimeExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemDateTime * SOAP_FMAC4 soap_in_tt__SystemDateTime(struct soap *soap, const char *tag, struct tt__SystemDateTime *a, const char *type)
{
	size_t soap_flag_DateTimeType = 1;
	size_t soap_flag_DaylightSavings = 1;
	size_t soap_flag_TimeZone = 1;
	size_t soap_flag_UTCDateTime = 1;
	size_t soap_flag_LocalDateTime = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SystemDateTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemDateTime, sizeof(struct tt__SystemDateTime), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__SystemDateTime(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DateTimeType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__SetDateTimeType(soap, "tt:DateTimeType", &a->DateTimeType, "tt:SetDateTimeType"))
				{	
					soap_flag_DateTimeType--;
					continue;
				}
				if (soap_flag_DaylightSavings && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_xsd__boolean_(soap, "tt:DaylightSavings", &a->DaylightSavings, "xsd:boolean"))
					{	
						soap_flag_DaylightSavings--;
						continue;
					}
					if (soap_flag_TimeZone && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTott__TimeZone(soap, "tt:TimeZone", &a->TimeZone, "tt:TimeZone"))
						{	
							soap_flag_TimeZone--;
							continue;
						}
						if (soap_flag_UTCDateTime && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_PointerTott__DateTime(soap, "tt:UTCDateTime", &a->UTCDateTime, "tt:DateTime"))
							{	
								soap_flag_UTCDateTime--;
								continue;
							}
							if (soap_flag_LocalDateTime && soap->error == SOAP_TAG_MISMATCH)
								if (soap_in_PointerTott__DateTime(soap, "tt:LocalDateTime", &a->LocalDateTime, "tt:DateTime"))
								{	
									soap_flag_LocalDateTime--;
									continue;
								}
								if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
									if (soap_in_PointerTott__SystemDateTimeExtension(soap, "tt:Extension", &a->Extension, "tt:SystemDateTimeExtension"))
									{	
										soap_flag_Extension--;
										continue;
									}
									if (soap->error == SOAP_TAG_MISMATCH)
										soap->error = soap_ignore_element(soap);
									if (soap->error == SOAP_NO_TAG)
										break;
									if (soap->error)
										return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__SystemDateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemDateTime, 0, sizeof(struct tt__SystemDateTime), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DateTimeType > 0 || soap_flag_DaylightSavings > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemDateTime(struct soap *soap, const struct tt__SystemDateTime *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SystemDateTime);
	if (soap_out_tt__SystemDateTime(soap, tag?tag:"tt:SystemDateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemDateTime * SOAP_FMAC4 soap_get_tt__SystemDateTime(struct soap *soap, struct tt__SystemDateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemDateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemDateTimeExtension(struct soap *soap, struct tt__SystemDateTimeExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemDateTimeExtension))
		soap_serialize_tt__SystemDateTimeExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemDateTimeExtension(struct soap *soap, const char *tag, int id, struct tt__SystemDateTimeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemDateTimeExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SystemDateTimeExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SystemDateTimeExtension ** SOAP_FMAC4 soap_in_PointerTott__SystemDateTimeExtension(struct soap *soap, const char *tag, struct tt__SystemDateTimeExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__SystemDateTimeExtension **)soap_malloc(soap, sizeof(struct tt__SystemDateTimeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__SystemDateTimeExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__SystemDateTimeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemDateTimeExtension, sizeof(struct tt__SystemDateTimeExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemDateTimeExtension(struct soap *soap, struct tt__SystemDateTimeExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SystemDateTimeExtension);
	if (soap_out_PointerTott__SystemDateTimeExtension(soap, tag?tag:"tt:SystemDateTimeExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemDateTimeExtension ** SOAP_FMAC4 soap_get_PointerTott__SystemDateTimeExtension(struct soap *soap, struct tt__SystemDateTimeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemDateTimeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DateTime(struct soap *soap, struct tt__DateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Time = NULL;
	a->Date = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DateTime(struct soap *soap, const struct tt__DateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Time(soap, &a->Time);
	soap_serialize_PointerTott__Date(soap, &a->Date);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DateTime(struct soap *soap, const char *tag, int id, const struct tt__DateTime *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DateTime), type))
		return soap->error;
	if (a->Time)
	{	
		if (soap_out_PointerTott__Time(soap, "tt:Time", -1, &a->Time, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Time"))
		return soap->error;
	if (a->Date)
	{	
		if (soap_out_PointerTott__Date(soap, "tt:Date", -1, &a->Date, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Date"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DateTime * SOAP_FMAC4 soap_in_tt__DateTime(struct soap *soap, const char *tag, struct tt__DateTime *a, const char *type)
{
	size_t soap_flag_Time = 1;
	size_t soap_flag_Date = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DateTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DateTime, sizeof(struct tt__DateTime), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__DateTime(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Time(soap, "tt:Time", &a->Time, "tt:Time"))
				{	
					soap_flag_Time--;
					continue;
				}
				if (soap_flag_Date && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__Date(soap, "tt:Date", &a->Date, "tt:Date"))
					{	
						soap_flag_Date--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH)
						soap->error = soap_ignore_element(soap);
					if (soap->error == SOAP_NO_TAG)
						break;
					if (soap->error)
						return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__DateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DateTime, 0, sizeof(struct tt__DateTime), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Time > 0 || soap_flag_Date > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DateTime(struct soap *soap, const struct tt__DateTime *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__DateTime);
	if (soap_out_tt__DateTime(soap, tag?tag:"tt:DateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DateTime * SOAP_FMAC4 soap_get_tt__DateTime(struct soap *soap, struct tt__DateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__TimeZone(struct soap *soap, struct tt__TimeZone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->TZ);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__TimeZone(struct soap *soap, const struct tt__TimeZone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__token(soap, &a->TZ);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TimeZone(struct soap *soap, const char *tag, int id, const struct tt__TimeZone *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TimeZone), type))
		return soap->error;
	if (a->TZ)
	{	
		if (soap_out_xsd__token(soap, "tt:TZ", -1, &a->TZ, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:TZ"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__TimeZone * SOAP_FMAC4 soap_in_tt__TimeZone(struct soap *soap, const char *tag, struct tt__TimeZone *a, const char *type)
{
	size_t soap_flag_TZ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__TimeZone *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TimeZone, sizeof(struct tt__TimeZone), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__TimeZone(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TZ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tt:TZ", &a->TZ, "xsd:token"))
				{	
					soap_flag_TZ--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH)
					soap->error = soap_ignore_element(soap);
				if (soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__TimeZone *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TimeZone, 0, sizeof(struct tt__TimeZone), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TZ > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TimeZone(struct soap *soap, const struct tt__TimeZone *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__TimeZone);
	if (soap_out_tt__TimeZone(soap, tag?tag:"tt:TimeZone", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TimeZone * SOAP_FMAC4 soap_get_tt__TimeZone(struct soap *soap, struct tt__TimeZone *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TimeZone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Date(struct soap *soap, struct tt__Date *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Date))
		soap_serialize_tt__Date(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Date(struct soap *soap, const char *tag, int id, struct tt__Date *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Date);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Date(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Date ** SOAP_FMAC4 soap_in_PointerTott__Date(struct soap *soap, const char *tag, struct tt__Date **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__Date **)soap_malloc(soap, sizeof(struct tt__Date *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__Date(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__Date **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Date, sizeof(struct tt__Date), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Date(struct soap *soap, struct tt__Date *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Date);
	if (soap_out_PointerTott__Date(soap, tag?tag:"tt:Date", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Date ** SOAP_FMAC4 soap_get_PointerTott__Date(struct soap *soap, struct tt__Date **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Time(struct soap *soap, struct tt__Time *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Time))
		soap_serialize_tt__Time(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Time(struct soap *soap, const char *tag, int id, struct tt__Time *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Time);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Time(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Time ** SOAP_FMAC4 soap_in_PointerTott__Time(struct soap *soap, const char *tag, struct tt__Time **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__Time **)soap_malloc(soap, sizeof(struct tt__Time *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__Time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__Time **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Time, sizeof(struct tt__Time), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Time(struct soap *soap, struct tt__Time *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Time);
	if (soap_out_PointerTott__Time(soap, tag?tag:"tt:Time", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Time ** SOAP_FMAC4 soap_get_PointerTott__Time(struct soap *soap, struct tt__Time **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetSystemDateAndTime(struct soap *soap, struct __tds__SetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetSystemDateAndTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetSystemDateAndTime(struct soap *soap, const struct __tds__SetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetSystemDateAndTime(soap, &a->tds__SetSystemDateAndTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetSystemDateAndTime(struct soap *soap, const char *tag, int id, const struct __tds__SetSystemDateAndTime *a, const char *type)
{
	if (soap_out_PointerTo_tds__SetSystemDateAndTime(soap, "tds:SetSystemDateAndTime", -1, &a->tds__SetSystemDateAndTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetSystemDateAndTime * SOAP_FMAC4 soap_in___tds__SetSystemDateAndTime(struct soap *soap, const char *tag, struct __tds__SetSystemDateAndTime *a, const char *type)
{
	size_t soap_flag_tds__SetSystemDateAndTime = 1;
	short soap_flag;
	a = (struct __tds__SetSystemDateAndTime *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetSystemDateAndTime, sizeof(struct __tds__SetSystemDateAndTime), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___tds__SetSystemDateAndTime(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__SetSystemDateAndTime && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__SetSystemDateAndTime(soap, "tds:SetSystemDateAndTime", &a->tds__SetSystemDateAndTime, ""))
			{	
				soap_flag_tds__SetSystemDateAndTime--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetSystemDateAndTime(struct soap *soap, const struct __tds__SetSystemDateAndTime *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetSystemDateAndTime(soap, tag?tag:"-tds:SetSystemDateAndTime", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetSystemDateAndTime * SOAP_FMAC4 soap_get___tds__SetSystemDateAndTime(struct soap *soap, struct __tds__SetSystemDateAndTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetSystemDateAndTimeResponse(struct soap *soap, struct _tds__SetSystemDateAndTimeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetSystemDateAndTimeResponse))
		soap_serialize__tds__SetSystemDateAndTimeResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetSystemDateAndTimeResponse(struct soap *soap, const char *tag, int id, struct _tds__SetSystemDateAndTimeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetSystemDateAndTimeResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetSystemDateAndTimeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTimeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetSystemDateAndTimeResponse(struct soap *soap, const char *tag, struct _tds__SetSystemDateAndTimeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__SetSystemDateAndTimeResponse **)soap_malloc(soap, sizeof(struct _tds__SetSystemDateAndTimeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__SetSystemDateAndTimeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetSystemDateAndTimeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemDateAndTimeResponse, sizeof(struct _tds__SetSystemDateAndTimeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetSystemDateAndTimeResponse(struct soap *soap, struct _tds__SetSystemDateAndTimeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetSystemDateAndTimeResponse);
	if (soap_out_PointerTo_tds__SetSystemDateAndTimeResponse(soap, tag?tag:"tds:SetSystemDateAndTimeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTimeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetSystemDateAndTimeResponse(struct soap *soap, struct _tds__SetSystemDateAndTimeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetSystemDateAndTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, struct _tds__SetSystemDateAndTime *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetSystemDateAndTime))
		soap_serialize__tds__SetSystemDateAndTime(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, const char *tag, int id, struct _tds__SetSystemDateAndTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetSystemDateAndTime);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetSystemDateAndTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTime ** SOAP_FMAC4 soap_in_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, const char *tag, struct _tds__SetSystemDateAndTime **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__SetSystemDateAndTime **)soap_malloc(soap, sizeof(struct _tds__SetSystemDateAndTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__SetSystemDateAndTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetSystemDateAndTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemDateAndTime, sizeof(struct _tds__SetSystemDateAndTime), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, struct _tds__SetSystemDateAndTime *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetSystemDateAndTime);
	if (soap_out_PointerTo_tds__SetSystemDateAndTime(soap, tag?tag:"tds:SetSystemDateAndTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTime ** SOAP_FMAC4 soap_get_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, struct _tds__SetSystemDateAndTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetSystemDateAndTimeResponse(struct soap *soap, struct _tds__SetSystemDateAndTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetSystemDateAndTimeResponse(struct soap *soap, const struct _tds__SetSystemDateAndTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetSystemDateAndTimeResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetSystemDateAndTimeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetSystemDateAndTimeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTimeResponse * SOAP_FMAC4 soap_in__tds__SetSystemDateAndTimeResponse(struct soap *soap, const char *tag, struct _tds__SetSystemDateAndTimeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetSystemDateAndTimeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetSystemDateAndTimeResponse, sizeof(struct _tds__SetSystemDateAndTimeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetSystemDateAndTimeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetSystemDateAndTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetSystemDateAndTimeResponse, 0, sizeof(struct _tds__SetSystemDateAndTimeResponse), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetSystemDateAndTimeResponse(struct soap *soap, const struct _tds__SetSystemDateAndTimeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetSystemDateAndTimeResponse);
	if (soap_out__tds__SetSystemDateAndTimeResponse(soap, tag?tag:"tds:SetSystemDateAndTimeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTimeResponse * SOAP_FMAC4 soap_get__tds__SetSystemDateAndTimeResponse(struct soap *soap, struct _tds__SetSystemDateAndTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetSystemDateAndTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetSystemDateAndTime(struct soap *soap, struct _tds__SetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SetDateTimeType(soap, &a->DateTimeType);
	soap_default_xsd__boolean_(soap, &a->DaylightSavings);
	a->TimeZone = NULL;
	a->UTCDateTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetSystemDateAndTime(struct soap *soap, const struct _tds__SetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->DaylightSavings, SOAP_TYPE_xsd__boolean_);
	soap_serialize_PointerTott__TimeZone(soap, &a->TimeZone);
	soap_serialize_PointerTott__DateTime(soap, &a->UTCDateTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetSystemDateAndTime(struct soap *soap, const char *tag, int id, const struct _tds__SetSystemDateAndTime *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetSystemDateAndTime), type))
		return soap->error;
	if (soap_out_tt__SetDateTimeType(soap, "tds:DateTimeType", -1, &a->DateTimeType, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tds:DaylightSavings", -1, &a->DaylightSavings, ""))
		return soap->error;
	if (soap_out_PointerTott__TimeZone(soap, "tds:TimeZone", -1, &a->TimeZone, ""))
		return soap->error;
	if (soap_out_PointerTott__DateTime(soap, "tds:UTCDateTime", -1, &a->UTCDateTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTime * SOAP_FMAC4 soap_in__tds__SetSystemDateAndTime(struct soap *soap, const char *tag, struct _tds__SetSystemDateAndTime *a, const char *type)
{
	size_t soap_flag_DateTimeType = 1;
	size_t soap_flag_DaylightSavings = 1;
	size_t soap_flag_TimeZone = 1;
	size_t soap_flag_UTCDateTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetSystemDateAndTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetSystemDateAndTime, sizeof(struct _tds__SetSystemDateAndTime), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__SetSystemDateAndTime(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DateTimeType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__SetDateTimeType(soap, "tds:DateTimeType", &a->DateTimeType, "tt:SetDateTimeType"))
				{	
					soap_flag_DateTimeType--;
					continue;
				}
				if (soap_flag_DaylightSavings && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_xsd__boolean_(soap, "tds:DaylightSavings", &a->DaylightSavings, "xsd:boolean"))
					{	
						soap_flag_DaylightSavings--;
						continue;
					}
					if (soap_flag_TimeZone && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTott__TimeZone(soap, "tds:TimeZone", &a->TimeZone, "tt:TimeZone"))
						{	
							soap_flag_TimeZone--;
							continue;
						}
						if (soap_flag_UTCDateTime && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_PointerTott__DateTime(soap, "tds:UTCDateTime", &a->UTCDateTime, "tt:DateTime"))
							{	
								soap_flag_UTCDateTime--;
								continue;
							}
							if (soap->error == SOAP_TAG_MISMATCH)
								soap->error = soap_ignore_element(soap);
							if (soap->error == SOAP_NO_TAG)
								break;
							if (soap->error)
								return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetSystemDateAndTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetSystemDateAndTime, 0, sizeof(struct _tds__SetSystemDateAndTime), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DateTimeType > 0 || soap_flag_DaylightSavings > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetSystemDateAndTime(struct soap *soap, const struct _tds__SetSystemDateAndTime *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetSystemDateAndTime);
	if (soap_out__tds__SetSystemDateAndTime(soap, tag?tag:"tds:SetSystemDateAndTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTime * SOAP_FMAC4 soap_get__tds__SetSystemDateAndTime(struct soap *soap, struct _tds__SetSystemDateAndTime *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SystemReboot(struct soap *soap, struct __tds__SystemReboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SystemReboot = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SystemReboot(struct soap *soap, const struct __tds__SystemReboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SystemReboot(soap, &a->tds__SystemReboot);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SystemReboot(struct soap *soap, const char *tag, int id, const struct __tds__SystemReboot *a, const char *type)
{
	if (soap_out_PointerTo_tds__SystemReboot(soap, "tds:SystemReboot", -1, &a->tds__SystemReboot, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SystemReboot * SOAP_FMAC4 soap_in___tds__SystemReboot(struct soap *soap, const char *tag, struct __tds__SystemReboot *a, const char *type)
{
	size_t soap_flag_tds__SystemReboot = 1;
	short soap_flag;
	a = (struct __tds__SystemReboot *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SystemReboot, sizeof(struct __tds__SystemReboot), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___tds__SystemReboot(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__SystemReboot && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__SystemReboot(soap, "tds:SystemReboot", &a->tds__SystemReboot, ""))
			{	
				soap_flag_tds__SystemReboot--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SystemReboot(struct soap *soap, const struct __tds__SystemReboot *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SystemReboot(soap, tag?tag:"-tds:SystemReboot", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SystemReboot * SOAP_FMAC4 soap_get___tds__SystemReboot(struct soap *soap, struct __tds__SystemReboot *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SystemReboot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SystemRebootResponse(struct soap *soap, struct _tds__SystemRebootResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SystemRebootResponse))
		soap_serialize__tds__SystemRebootResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SystemRebootResponse(struct soap *soap, const char *tag, int id, struct _tds__SystemRebootResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SystemRebootResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SystemRebootResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SystemRebootResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SystemRebootResponse(struct soap *soap, const char *tag, struct _tds__SystemRebootResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__SystemRebootResponse **)soap_malloc(soap, sizeof(struct _tds__SystemRebootResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__SystemRebootResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SystemRebootResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SystemRebootResponse, sizeof(struct _tds__SystemRebootResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SystemRebootResponse(struct soap *soap, struct _tds__SystemRebootResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SystemRebootResponse);
	if (soap_out_PointerTo_tds__SystemRebootResponse(soap, tag?tag:"tds:SystemRebootResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SystemRebootResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SystemRebootResponse(struct soap *soap, struct _tds__SystemRebootResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SystemRebootResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SystemReboot(struct soap *soap, struct _tds__SystemReboot *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SystemReboot))
		soap_serialize__tds__SystemReboot(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SystemReboot(struct soap *soap, const char *tag, int id, struct _tds__SystemReboot *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SystemReboot);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SystemReboot(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SystemReboot ** SOAP_FMAC4 soap_in_PointerTo_tds__SystemReboot(struct soap *soap, const char *tag, struct _tds__SystemReboot **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__SystemReboot **)soap_malloc(soap, sizeof(struct _tds__SystemReboot *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__SystemReboot(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SystemReboot **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SystemReboot, sizeof(struct _tds__SystemReboot), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SystemReboot(struct soap *soap, struct _tds__SystemReboot *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SystemReboot);
	if (soap_out_PointerTo_tds__SystemReboot(soap, tag?tag:"tds:SystemReboot", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SystemReboot ** SOAP_FMAC4 soap_get_PointerTo_tds__SystemReboot(struct soap *soap, struct _tds__SystemReboot **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SystemReboot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SystemRebootResponse(struct soap *soap, struct _tds__SystemRebootResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SystemRebootResponse(struct soap *soap, const struct _tds__SystemRebootResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Message);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SystemRebootResponse(struct soap *soap, const char *tag, int id, const struct _tds__SystemRebootResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SystemRebootResponse), type))
		return soap->error;
	if (a->Message)
		soap_element_result(soap, "tds:Message");
	if (a->Message)
	{	
		if (soap_out_string(soap, "tds:Message", -1, &a->Message, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Message"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SystemRebootResponse * SOAP_FMAC4 soap_in__tds__SystemRebootResponse(struct soap *soap, const char *tag, struct _tds__SystemRebootResponse *a, const char *type)
{
	size_t soap_flag_Message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SystemRebootResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SystemRebootResponse, sizeof(struct _tds__SystemRebootResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__SystemRebootResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:Message", &a->Message, "xsd:string"))
				{	
					soap_flag_Message--;
					continue;
				}
				soap_check_result(soap, "tds:Message");
				if (soap->error == SOAP_TAG_MISMATCH)
					soap->error = soap_ignore_element(soap);
				if (soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SystemRebootResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SystemRebootResponse, 0, sizeof(struct _tds__SystemRebootResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Message > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SystemRebootResponse(struct soap *soap, const struct _tds__SystemRebootResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SystemRebootResponse);
	if (soap_out__tds__SystemRebootResponse(soap, tag?tag:"tds:SystemRebootResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SystemRebootResponse * SOAP_FMAC4 soap_get__tds__SystemRebootResponse(struct soap *soap, struct _tds__SystemRebootResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SystemRebootResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SystemReboot(struct soap *soap, struct _tds__SystemReboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SystemReboot(struct soap *soap, const struct _tds__SystemReboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SystemReboot(struct soap *soap, const char *tag, int id, const struct _tds__SystemReboot *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SystemReboot), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SystemReboot * SOAP_FMAC4 soap_in__tds__SystemReboot(struct soap *soap, const char *tag, struct _tds__SystemReboot *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SystemReboot *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SystemReboot, sizeof(struct _tds__SystemReboot), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__SystemReboot(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SystemReboot *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SystemReboot, 0, sizeof(struct _tds__SystemReboot), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SystemReboot(struct soap *soap, const struct _tds__SystemReboot *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SystemReboot);
	if (soap_out__tds__SystemReboot(soap, tag?tag:"tds:SystemReboot", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SystemReboot * SOAP_FMAC4 soap_get__tds__SystemReboot(struct soap *soap, struct _tds__SystemReboot *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SystemReboot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetSystemFactoryDefault(struct soap *soap, struct __tds__SetSystemFactoryDefault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetSystemFactoryDefault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetSystemFactoryDefault(struct soap *soap, const struct __tds__SetSystemFactoryDefault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetSystemFactoryDefault(soap, &a->tds__SetSystemFactoryDefault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, int id, const struct __tds__SetSystemFactoryDefault *a, const char *type)
{
	if (soap_out_PointerTo_tds__SetSystemFactoryDefault(soap, "tds:SetSystemFactoryDefault", -1, &a->tds__SetSystemFactoryDefault, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetSystemFactoryDefault * SOAP_FMAC4 soap_in___tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, struct __tds__SetSystemFactoryDefault *a, const char *type)
{
	size_t soap_flag_tds__SetSystemFactoryDefault = 1;
	short soap_flag;
	a = (struct __tds__SetSystemFactoryDefault *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetSystemFactoryDefault, sizeof(struct __tds__SetSystemFactoryDefault), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___tds__SetSystemFactoryDefault(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__SetSystemFactoryDefault && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__SetSystemFactoryDefault(soap, "tds:SetSystemFactoryDefault", &a->tds__SetSystemFactoryDefault, ""))
			{	
				soap_flag_tds__SetSystemFactoryDefault--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetSystemFactoryDefault(struct soap *soap, const struct __tds__SetSystemFactoryDefault *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetSystemFactoryDefault(soap, tag?tag:"-tds:SetSystemFactoryDefault", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetSystemFactoryDefault * SOAP_FMAC4 soap_get___tds__SetSystemFactoryDefault(struct soap *soap, struct __tds__SetSystemFactoryDefault *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetSystemFactoryDefault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetSystemFactoryDefaultResponse(struct soap *soap, struct _tds__SetSystemFactoryDefaultResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse))
		soap_serialize__tds__SetSystemFactoryDefaultResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetSystemFactoryDefaultResponse(struct soap *soap, const char *tag, int id, struct _tds__SetSystemFactoryDefaultResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetSystemFactoryDefaultResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefaultResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetSystemFactoryDefaultResponse(struct soap *soap, const char *tag, struct _tds__SetSystemFactoryDefaultResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__SetSystemFactoryDefaultResponse **)soap_malloc(soap, sizeof(struct _tds__SetSystemFactoryDefaultResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__SetSystemFactoryDefaultResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetSystemFactoryDefaultResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse, sizeof(struct _tds__SetSystemFactoryDefaultResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetSystemFactoryDefaultResponse(struct soap *soap, struct _tds__SetSystemFactoryDefaultResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetSystemFactoryDefaultResponse);
	if (soap_out_PointerTo_tds__SetSystemFactoryDefaultResponse(soap, tag?tag:"tds:SetSystemFactoryDefaultResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefaultResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetSystemFactoryDefaultResponse(struct soap *soap, struct _tds__SetSystemFactoryDefaultResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetSystemFactoryDefaultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, struct _tds__SetSystemFactoryDefault *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetSystemFactoryDefault))
		soap_serialize__tds__SetSystemFactoryDefault(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, int id, struct _tds__SetSystemFactoryDefault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetSystemFactoryDefault);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetSystemFactoryDefault(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefault ** SOAP_FMAC4 soap_in_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, struct _tds__SetSystemFactoryDefault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__SetSystemFactoryDefault **)soap_malloc(soap, sizeof(struct _tds__SetSystemFactoryDefault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__SetSystemFactoryDefault(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetSystemFactoryDefault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemFactoryDefault, sizeof(struct _tds__SetSystemFactoryDefault), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, struct _tds__SetSystemFactoryDefault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetSystemFactoryDefault);
	if (soap_out_PointerTo_tds__SetSystemFactoryDefault(soap, tag?tag:"tds:SetSystemFactoryDefault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefault ** SOAP_FMAC4 soap_get_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, struct _tds__SetSystemFactoryDefault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetSystemFactoryDefault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetSystemFactoryDefaultResponse(struct soap *soap, struct _tds__SetSystemFactoryDefaultResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetSystemFactoryDefaultResponse(struct soap *soap, const struct _tds__SetSystemFactoryDefaultResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetSystemFactoryDefaultResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetSystemFactoryDefaultResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefaultResponse * SOAP_FMAC4 soap_in__tds__SetSystemFactoryDefaultResponse(struct soap *soap, const char *tag, struct _tds__SetSystemFactoryDefaultResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetSystemFactoryDefaultResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse, sizeof(struct _tds__SetSystemFactoryDefaultResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__SetSystemFactoryDefaultResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetSystemFactoryDefaultResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse, 0, sizeof(struct _tds__SetSystemFactoryDefaultResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetSystemFactoryDefaultResponse(struct soap *soap, const struct _tds__SetSystemFactoryDefaultResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse);
	if (soap_out__tds__SetSystemFactoryDefaultResponse(soap, tag?tag:"tds:SetSystemFactoryDefaultResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefaultResponse * SOAP_FMAC4 soap_get__tds__SetSystemFactoryDefaultResponse(struct soap *soap, struct _tds__SetSystemFactoryDefaultResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetSystemFactoryDefaultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetSystemFactoryDefault(struct soap *soap, struct _tds__SetSystemFactoryDefault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__FactoryDefaultType(soap, &a->FactoryDefault);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetSystemFactoryDefault(struct soap *soap, const struct _tds__SetSystemFactoryDefault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, int id, const struct _tds__SetSystemFactoryDefault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetSystemFactoryDefault), type))
		return soap->error;
	if (soap_out_tt__FactoryDefaultType(soap, "tds:FactoryDefault", -1, &a->FactoryDefault, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefault * SOAP_FMAC4 soap_in__tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, struct _tds__SetSystemFactoryDefault *a, const char *type)
{
	size_t soap_flag_FactoryDefault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetSystemFactoryDefault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetSystemFactoryDefault, sizeof(struct _tds__SetSystemFactoryDefault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetSystemFactoryDefault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FactoryDefault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__FactoryDefaultType(soap, "tds:FactoryDefault", &a->FactoryDefault, "tt:FactoryDefaultType"))
				{	
					soap_flag_FactoryDefault--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH)
					soap->error = soap_ignore_element(soap);
				if (soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetSystemFactoryDefault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetSystemFactoryDefault, 0, sizeof(struct _tds__SetSystemFactoryDefault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FactoryDefault > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetSystemFactoryDefault(struct soap *soap, const struct _tds__SetSystemFactoryDefault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetSystemFactoryDefault);
	if (soap_out__tds__SetSystemFactoryDefault(soap, tag?tag:"tds:SetSystemFactoryDefault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefault * SOAP_FMAC4 soap_get__tds__SetSystemFactoryDefault(struct soap *soap, struct _tds__SetSystemFactoryDefault *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetSystemFactoryDefault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FactoryDefaultType(struct soap *soap, enum tt__FactoryDefaultType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__FactoryDefaultType
	*a = SOAP_DEFAULT_tt__FactoryDefaultType;
#else
	*a = (enum tt__FactoryDefaultType)0;
#endif
}

static const struct soap_code_map soap_codes_tt__FactoryDefaultType[] =
{	
	{ (long)tt__FactoryDefaultType__Hard, "Hard" },
	{ (long)tt__FactoryDefaultType__Soft, "Soft" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__FactoryDefaultType2s(struct soap *soap, enum tt__FactoryDefaultType n)
{	
	const char *s = soap_code_str(soap_codes_tt__FactoryDefaultType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FactoryDefaultType(struct soap *soap, const char *tag, int id, const enum tt__FactoryDefaultType *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FactoryDefaultType), type) || soap_send(soap, soap_tt__FactoryDefaultType2s(soap, *a)))
	return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__FactoryDefaultType(struct soap *soap, const char *s, enum tt__FactoryDefaultType *a)
{
	const struct soap_code_map *map;
	if (s == NULL)
		return soap->error;
	map = soap_code(soap_codes_tt__FactoryDefaultType, s);
	if (map)
		*a = (enum tt__FactoryDefaultType)map->code;
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__FactoryDefaultType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__FactoryDefaultType * SOAP_FMAC4 soap_in_tt__FactoryDefaultType(struct soap *soap, const char *tag, enum tt__FactoryDefaultType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	return NULL;
	a = (enum tt__FactoryDefaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FactoryDefaultType, sizeof(enum tt__FactoryDefaultType), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	if (soap->body && !*soap->href)
	{	
		if (!a || soap_s2tt__FactoryDefaultType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (enum tt__FactoryDefaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FactoryDefaultType, 0, sizeof(enum tt__FactoryDefaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FactoryDefaultType(struct soap *soap, const enum tt__FactoryDefaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__FactoryDefaultType);
	if (soap_out_tt__FactoryDefaultType(soap, tag?tag:"tt:FactoryDefaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__FactoryDefaultType * SOAP_FMAC4 soap_get_tt__FactoryDefaultType(struct soap *soap, enum tt__FactoryDefaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FactoryDefaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

//device security
SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetUsers(struct soap *soap, struct __tds__GetUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetUsers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetUsers(struct soap *soap, const struct __tds__GetUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetUsers(soap, &a->tds__GetUsers);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetUsers(struct soap *soap, const char *tag, int id, const struct __tds__GetUsers *a, const char *type)
{
	if (soap_out_PointerTo_tds__GetUsers(soap, "tds:GetUsers", -1, &a->tds__GetUsers, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetUsers * SOAP_FMAC4 soap_in___tds__GetUsers(struct soap *soap, const char *tag, struct __tds__GetUsers *a, const char *type)
{
	size_t soap_flag_tds__GetUsers = 1;
	short soap_flag;
	a = (struct __tds__GetUsers *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetUsers, sizeof(struct __tds__GetUsers), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___tds__GetUsers(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__GetUsers && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__GetUsers(soap, "tds:GetUsers", &a->tds__GetUsers, ""))
			{	
				soap_flag_tds__GetUsers--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetUsers(struct soap *soap, const struct __tds__GetUsers *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetUsers(soap, tag?tag:"-tds:GetUsers", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetUsers * SOAP_FMAC4 soap_get___tds__GetUsers(struct soap *soap, struct __tds__GetUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetUsersResponse(struct soap *soap, struct _tds__GetUsersResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetUsersResponse))
		soap_serialize__tds__GetUsersResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetUsersResponse(struct soap *soap, const char *tag, int id, struct _tds__GetUsersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetUsersResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetUsersResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetUsersResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetUsersResponse(struct soap *soap, const char *tag, struct _tds__GetUsersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__GetUsersResponse **)soap_malloc(soap, sizeof(struct _tds__GetUsersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__GetUsersResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetUsersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetUsersResponse, sizeof(struct _tds__GetUsersResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetUsersResponse(struct soap *soap, struct _tds__GetUsersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetUsersResponse);
	if (soap_out_PointerTo_tds__GetUsersResponse(soap, tag?tag:"tds:GetUsersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetUsersResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetUsersResponse(struct soap *soap, struct _tds__GetUsersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetUsers(struct soap *soap, struct _tds__GetUsers *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetUsers))
		soap_serialize__tds__GetUsers(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetUsers(struct soap *soap, const char *tag, int id, struct _tds__GetUsers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetUsers);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetUsers(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetUsers ** SOAP_FMAC4 soap_in_PointerTo_tds__GetUsers(struct soap *soap, const char *tag, struct _tds__GetUsers **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__GetUsers **)soap_malloc(soap, sizeof(struct _tds__GetUsers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__GetUsers(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetUsers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetUsers, sizeof(struct _tds__GetUsers), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetUsers(struct soap *soap, struct _tds__GetUsers *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetUsers);
	if (soap_out_PointerTo_tds__GetUsers(soap, tag?tag:"tds:GetUsers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetUsers ** SOAP_FMAC4 soap_get_PointerTo_tds__GetUsers(struct soap *soap, struct _tds__GetUsers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__UserLevel(struct soap *soap, enum tt__UserLevel *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__UserLevel
	*a = SOAP_DEFAULT_tt__UserLevel;
#else
	*a = (enum tt__UserLevel)0;
#endif
}

static const struct soap_code_map soap_codes_tt__UserLevel[] =
{	
	{ (long)tt__UserLevel__Administrator, "Administrator" },
	{ (long)tt__UserLevel__Operator, "Operator" },
	{ (long)tt__UserLevel__User, "User" },
	{ (long)tt__UserLevel__Anonymous, "Anonymous" },
	{ (long)tt__UserLevel__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__UserLevel2s(struct soap *soap, enum tt__UserLevel n)
{	
	const char *s = soap_code_str(soap_codes_tt__UserLevel, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__UserLevel(struct soap *soap, const char *tag, int id, const enum tt__UserLevel *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__UserLevel), type) || soap_send(soap, soap_tt__UserLevel2s(soap, *a)))
	return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__UserLevel(struct soap *soap, const char *s, enum tt__UserLevel *a)
{
	const struct soap_code_map *map;
	if (s == NULL)
		return soap->error;
	map = soap_code(soap_codes_tt__UserLevel, s);
	if (map)
		*a = (enum tt__UserLevel)map->code;
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__UserLevel)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__UserLevel * SOAP_FMAC4 soap_in_tt__UserLevel(struct soap *soap, const char *tag, enum tt__UserLevel *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	return NULL;
	a = (enum tt__UserLevel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__UserLevel, sizeof(enum tt__UserLevel), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	if (soap->body && !*soap->href)
	{	
		if (!a || soap_s2tt__UserLevel(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (enum tt__UserLevel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__UserLevel, 0, sizeof(enum tt__UserLevel), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__UserLevel(struct soap *soap, const enum tt__UserLevel *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__UserLevel);
	if (soap_out_tt__UserLevel(soap, tag?tag:"tt:UserLevel", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__UserLevel * SOAP_FMAC4 soap_get_tt__UserLevel(struct soap *soap, enum tt__UserLevel *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__UserLevel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__UserExtension(struct soap *soap, struct tt__UserExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__UserExtension(struct soap *soap, const struct tt__UserExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__UserExtension(struct soap *soap, const char *tag, int id, const struct tt__UserExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__UserExtension), type))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__UserExtension * SOAP_FMAC4 soap_in_tt__UserExtension(struct soap *soap, const char *tag, struct tt__UserExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__UserExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__UserExtension, sizeof(struct tt__UserExtension), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__UserExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__UserExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__UserExtension, 0, sizeof(struct tt__UserExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__UserExtension(struct soap *soap, const struct tt__UserExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__UserExtension);
	if (soap_out_tt__UserExtension(soap, tag?tag:"tt:UserExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__UserExtension * SOAP_FMAC4 soap_get_tt__UserExtension(struct soap *soap, struct tt__UserExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__UserExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__UserExtension(struct soap *soap, struct tt__UserExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__UserExtension))
		soap_serialize_tt__UserExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__UserExtension(struct soap *soap, const char *tag, int id, struct tt__UserExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__UserExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__UserExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__UserExtension ** SOAP_FMAC4 soap_in_PointerTott__UserExtension(struct soap *soap, const char *tag, struct tt__UserExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__UserExtension **)soap_malloc(soap, sizeof(struct tt__UserExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__UserExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__UserExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__UserExtension, sizeof(struct tt__UserExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__UserExtension(struct soap *soap, struct tt__UserExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__UserExtension);
	if (soap_out_PointerTott__UserExtension(soap, tag?tag:"tt:UserExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__UserExtension ** SOAP_FMAC4 soap_get_PointerTott__UserExtension(struct soap *soap, struct tt__UserExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__UserExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__User(struct soap *soap, struct tt__User *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Username);
	soap_default_string(soap, &a->Password);
	soap_default_tt__UserLevel(soap, &a->UserLevel);
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__User(struct soap *soap, const struct tt__User *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Username);
	soap_serialize_string(soap, &a->Password);
	soap_serialize_PointerTott__UserExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__User(struct soap *soap, const char *tag, int id, const struct tt__User *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__User), type))
		return soap->error;
	if (a->Username)
	{	
		if (soap_out_string(soap, "tt:Username", -1, &a->Username, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Username"))
		return soap->error;
	if (soap_out_string(soap, "tt:Password", -1, &a->Password, ""))
		return soap->error;
	if (soap_out_tt__UserLevel(soap, "tt:UserLevel", -1, &a->UserLevel, ""))
		return soap->error;
	if (soap_out_PointerTott__UserExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__User * SOAP_FMAC4 soap_in_tt__User(struct soap *soap, const char *tag, struct tt__User *a, const char *type)
{
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_UserLevel = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__User *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__User, sizeof(struct tt__User), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__User(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Username", &a->Username, "xsd:string"))
				{	
					soap_flag_Username--;
					continue;
				}
				if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
					if (soap_in_string(soap, "tt:Password", &a->Password, "xsd:string"))
					{	
						soap_flag_Password--;
						continue;
					}
					if (soap_flag_UserLevel && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_tt__UserLevel(soap, "tt:UserLevel", &a->UserLevel, "tt:UserLevel"))
						{	
							soap_flag_UserLevel--;
							continue;
						}
						if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_PointerTott__UserExtension(soap, "tt:Extension", &a->Extension, "tt:UserExtension"))
							{	
								soap_flag_Extension--;
								continue;
							}
							if (soap->error == SOAP_TAG_MISMATCH)
								soap->error = soap_ignore_element(soap);
							if (soap->error == SOAP_NO_TAG)
								break;
							if (soap->error)
								return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__User *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__User, 0, sizeof(struct tt__User), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Username > 0 || soap_flag_UserLevel > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__User(struct soap *soap, const struct tt__User *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__User);
	if (soap_out_tt__User(soap, tag?tag:"tt:User", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__User * SOAP_FMAC4 soap_get_tt__User(struct soap *soap, struct tt__User *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__User(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetUsersResponse(struct soap *soap, struct _tds__GetUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeUser = 0;
	a->User = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetUsersResponse(struct soap *soap, const struct _tds__GetUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->User)
	{	
		int i;
		for (i = 0; i < a->__sizeUser; i++)
		{
			soap_embedded(soap, a->User + i, SOAP_TYPE_tt__User);
			soap_serialize_tt__User(soap, a->User + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetUsersResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetUsersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetUsersResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeUser");
	if (a->User)
	{	
		int i;
		for (i = 0; i < a->__sizeUser; i++)
			if (soap_out_tt__User(soap, "tds:User", -1, a->User + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetUsersResponse * SOAP_FMAC4 soap_in__tds__GetUsersResponse(struct soap *soap, const char *tag, struct _tds__GetUsersResponse *a, const char *type)
{
	struct soap_blist *soap_blist_User = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetUsersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetUsersResponse, sizeof(struct _tds__GetUsersResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__GetUsersResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:User", 1, NULL))
			{	
				if (a->User == NULL)
				{	
					if (soap_blist_User == NULL)
						soap_blist_User = soap_new_block(soap);
					a->User = (struct tt__User *)soap_push_block(soap, soap_blist_User, sizeof(struct tt__User));
					if (a->User == NULL)
						return NULL;
					soap_default_tt__User(soap, a->User);
				}
				soap_revert(soap);
				if (soap_in_tt__User(soap, "tds:User", a->User, "tt:User"))
				{	
					a->__sizeUser++;
					a->User = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeUser");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->User)
			soap_pop_block(soap, soap_blist_User);
		if (a->__sizeUser)
			a->User = (struct tt__User *)soap_save_block(soap, soap_blist_User, NULL, 1);
		else
		{	
			a->User = NULL;
			if (soap_blist_User)
				soap_end_block(soap, soap_blist_User);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetUsersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetUsersResponse, 0, sizeof(struct _tds__GetUsersResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetUsersResponse(struct soap *soap, const struct _tds__GetUsersResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetUsersResponse);
	if (soap_out__tds__GetUsersResponse(soap, tag?tag:"tds:GetUsersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetUsersResponse * SOAP_FMAC4 soap_get__tds__GetUsersResponse(struct soap *soap, struct _tds__GetUsersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetUsers(struct soap *soap, struct _tds__GetUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetUsers(struct soap *soap, const struct _tds__GetUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetUsers(struct soap *soap, const char *tag, int id, const struct _tds__GetUsers *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetUsers), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetUsers * SOAP_FMAC4 soap_in__tds__GetUsers(struct soap *soap, const char *tag, struct _tds__GetUsers *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetUsers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetUsers, sizeof(struct _tds__GetUsers), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__GetUsers(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetUsers, 0, sizeof(struct _tds__GetUsers), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetUsers(struct soap *soap, const struct _tds__GetUsers *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetUsers);
	if (soap_out__tds__GetUsers(soap, tag?tag:"tds:GetUsers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetUsers * SOAP_FMAC4 soap_get__tds__GetUsers(struct soap *soap, struct _tds__GetUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__CreateUsers(struct soap *soap, struct __tds__CreateUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__CreateUsers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__CreateUsers(struct soap *soap, const struct __tds__CreateUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__CreateUsers(soap, &a->tds__CreateUsers);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__CreateUsers(struct soap *soap, const char *tag, int id, const struct __tds__CreateUsers *a, const char *type)
{
	if (soap_out_PointerTo_tds__CreateUsers(soap, "tds:CreateUsers", -1, &a->tds__CreateUsers, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__CreateUsers * SOAP_FMAC4 soap_in___tds__CreateUsers(struct soap *soap, const char *tag, struct __tds__CreateUsers *a, const char *type)
{
	size_t soap_flag_tds__CreateUsers = 1;
	short soap_flag;
	a = (struct __tds__CreateUsers *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__CreateUsers, sizeof(struct __tds__CreateUsers), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___tds__CreateUsers(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__CreateUsers && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__CreateUsers(soap, "tds:CreateUsers", &a->tds__CreateUsers, ""))
			{	
				soap_flag_tds__CreateUsers--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__CreateUsers(struct soap *soap, const struct __tds__CreateUsers *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__CreateUsers(soap, tag?tag:"-tds:CreateUsers", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__CreateUsers * SOAP_FMAC4 soap_get___tds__CreateUsers(struct soap *soap, struct __tds__CreateUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__CreateUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__CreateUsersResponse(struct soap *soap, struct _tds__CreateUsersResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__CreateUsersResponse))
		soap_serialize__tds__CreateUsersResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__CreateUsersResponse(struct soap *soap, const char *tag, int id, struct _tds__CreateUsersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__CreateUsersResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__CreateUsersResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__CreateUsersResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__CreateUsersResponse(struct soap *soap, const char *tag, struct _tds__CreateUsersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__CreateUsersResponse **)soap_malloc(soap, sizeof(struct _tds__CreateUsersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__CreateUsersResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__CreateUsersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateUsersResponse, sizeof(struct _tds__CreateUsersResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__CreateUsersResponse(struct soap *soap, struct _tds__CreateUsersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__CreateUsersResponse);
	if (soap_out_PointerTo_tds__CreateUsersResponse(soap, tag?tag:"tds:CreateUsersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateUsersResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__CreateUsersResponse(struct soap *soap, struct _tds__CreateUsersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__CreateUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__CreateUsers(struct soap *soap, struct _tds__CreateUsers *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__CreateUsers))
		soap_serialize__tds__CreateUsers(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__CreateUsers(struct soap *soap, const char *tag, int id, struct _tds__CreateUsers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__CreateUsers);
	if (id < 0)
		return soap->error;
	return soap_out__tds__CreateUsers(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__CreateUsers ** SOAP_FMAC4 soap_in_PointerTo_tds__CreateUsers(struct soap *soap, const char *tag, struct _tds__CreateUsers **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__CreateUsers **)soap_malloc(soap, sizeof(struct _tds__CreateUsers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__CreateUsers(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__CreateUsers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateUsers, sizeof(struct _tds__CreateUsers), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__CreateUsers(struct soap *soap, struct _tds__CreateUsers *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__CreateUsers);
	if (soap_out_PointerTo_tds__CreateUsers(soap, tag?tag:"tds:CreateUsers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateUsers ** SOAP_FMAC4 soap_get_PointerTo_tds__CreateUsers(struct soap *soap, struct _tds__CreateUsers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__CreateUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__CreateUsersResponse(struct soap *soap, struct _tds__CreateUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__CreateUsersResponse(struct soap *soap, const struct _tds__CreateUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateUsersResponse(struct soap *soap, const char *tag, int id, const struct _tds__CreateUsersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateUsersResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__CreateUsersResponse * SOAP_FMAC4 soap_in__tds__CreateUsersResponse(struct soap *soap, const char *tag, struct _tds__CreateUsersResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__CreateUsersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateUsersResponse, sizeof(struct _tds__CreateUsersResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__CreateUsersResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__CreateUsersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateUsersResponse, 0, sizeof(struct _tds__CreateUsersResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__CreateUsersResponse(struct soap *soap, const struct _tds__CreateUsersResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__CreateUsersResponse);
	if (soap_out__tds__CreateUsersResponse(soap, tag?tag:"tds:CreateUsersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateUsersResponse * SOAP_FMAC4 soap_get__tds__CreateUsersResponse(struct soap *soap, struct _tds__CreateUsersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__CreateUsers(struct soap *soap, struct _tds__CreateUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeUser = 0;
	a->User = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__CreateUsers(struct soap *soap, const struct _tds__CreateUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->User)
	{	
		int i;
		for (i = 0; i < a->__sizeUser; i++)
		{
			soap_embedded(soap, a->User + i, SOAP_TYPE_tt__User);
			soap_serialize_tt__User(soap, a->User + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateUsers(struct soap *soap, const char *tag, int id, const struct _tds__CreateUsers *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateUsers), type))
		return soap->error;
	if (a->User)
	{	
		int i;
		for (i = 0; i < a->__sizeUser; i++)
			if (soap_out_tt__User(soap, "tds:User", -1, a->User + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__CreateUsers * SOAP_FMAC4 soap_in__tds__CreateUsers(struct soap *soap, const char *tag, struct _tds__CreateUsers *a, const char *type)
{
	struct soap_blist *soap_blist_User = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__CreateUsers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateUsers, sizeof(struct _tds__CreateUsers), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__CreateUsers(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:User", 1, NULL))
			{	
				if (a->User == NULL)
				{	
					if (soap_blist_User == NULL)
						soap_blist_User = soap_new_block(soap);
					a->User = (struct tt__User *)soap_push_block(soap, soap_blist_User, sizeof(struct tt__User));
					if (a->User == NULL)
						return NULL;
					soap_default_tt__User(soap, a->User);
				}
				soap_revert(soap);
				if (soap_in_tt__User(soap, "tds:User", a->User, "tt:User"))
				{	
					a->__sizeUser++;
					a->User = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->User)
			soap_pop_block(soap, soap_blist_User);
		if (a->__sizeUser)
			a->User = (struct tt__User *)soap_save_block(soap, soap_blist_User, NULL, 1);
		else
		{	
			a->User = NULL;
			if (soap_blist_User)
				soap_end_block(soap, soap_blist_User);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__CreateUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateUsers, 0, sizeof(struct _tds__CreateUsers), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeUser < 1))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__CreateUsers(struct soap *soap, const struct _tds__CreateUsers *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__CreateUsers);
	if (soap_out__tds__CreateUsers(soap, tag?tag:"tds:CreateUsers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateUsers * SOAP_FMAC4 soap_get__tds__CreateUsers(struct soap *soap, struct _tds__CreateUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__DeleteUsers(struct soap *soap, struct __tds__DeleteUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__DeleteUsers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__DeleteUsers(struct soap *soap, const struct __tds__DeleteUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__DeleteUsers(soap, &a->tds__DeleteUsers);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__DeleteUsers(struct soap *soap, const char *tag, int id, const struct __tds__DeleteUsers *a, const char *type)
{
	if (soap_out_PointerTo_tds__DeleteUsers(soap, "tds:DeleteUsers", -1, &a->tds__DeleteUsers, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteUsers * SOAP_FMAC4 soap_in___tds__DeleteUsers(struct soap *soap, const char *tag, struct __tds__DeleteUsers *a, const char *type)
{
	size_t soap_flag_tds__DeleteUsers = 1;
	short soap_flag;
	a = (struct __tds__DeleteUsers *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__DeleteUsers, sizeof(struct __tds__DeleteUsers), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___tds__DeleteUsers(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__DeleteUsers && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__DeleteUsers(soap, "tds:DeleteUsers", &a->tds__DeleteUsers, ""))
			{	
				soap_flag_tds__DeleteUsers--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__DeleteUsers(struct soap *soap, const struct __tds__DeleteUsers *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__DeleteUsers(soap, tag?tag:"-tds:DeleteUsers", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteUsers * SOAP_FMAC4 soap_get___tds__DeleteUsers(struct soap *soap, struct __tds__DeleteUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__DeleteUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteUsersResponse(struct soap *soap, struct _tds__DeleteUsersResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteUsersResponse))
		soap_serialize__tds__DeleteUsersResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteUsersResponse(struct soap *soap, const char *tag, int id, struct _tds__DeleteUsersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteUsersResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__DeleteUsersResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__DeleteUsersResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteUsersResponse(struct soap *soap, const char *tag, struct _tds__DeleteUsersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__DeleteUsersResponse **)soap_malloc(soap, sizeof(struct _tds__DeleteUsersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__DeleteUsersResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__DeleteUsersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteUsersResponse, sizeof(struct _tds__DeleteUsersResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteUsersResponse(struct soap *soap, struct _tds__DeleteUsersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__DeleteUsersResponse);
	if (soap_out_PointerTo_tds__DeleteUsersResponse(soap, tag?tag:"tds:DeleteUsersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteUsersResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteUsersResponse(struct soap *soap, struct _tds__DeleteUsersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteUsers(struct soap *soap, struct _tds__DeleteUsers *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteUsers))
		soap_serialize__tds__DeleteUsers(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteUsers(struct soap *soap, const char *tag, int id, struct _tds__DeleteUsers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteUsers);
	if (id < 0)
		return soap->error;
	return soap_out__tds__DeleteUsers(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__DeleteUsers ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteUsers(struct soap *soap, const char *tag, struct _tds__DeleteUsers **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__DeleteUsers **)soap_malloc(soap, sizeof(struct _tds__DeleteUsers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__DeleteUsers(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__DeleteUsers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteUsers, sizeof(struct _tds__DeleteUsers), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteUsers(struct soap *soap, struct _tds__DeleteUsers *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__DeleteUsers);
	if (soap_out_PointerTo_tds__DeleteUsers(soap, tag?tag:"tds:DeleteUsers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteUsers ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteUsers(struct soap *soap, struct _tds__DeleteUsers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__DeleteUsersResponse(struct soap *soap, struct _tds__DeleteUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__DeleteUsersResponse(struct soap *soap, const struct _tds__DeleteUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteUsersResponse(struct soap *soap, const char *tag, int id, const struct _tds__DeleteUsersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteUsersResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__DeleteUsersResponse * SOAP_FMAC4 soap_in__tds__DeleteUsersResponse(struct soap *soap, const char *tag, struct _tds__DeleteUsersResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__DeleteUsersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteUsersResponse, sizeof(struct _tds__DeleteUsersResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__DeleteUsersResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__DeleteUsersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteUsersResponse, 0, sizeof(struct _tds__DeleteUsersResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__DeleteUsersResponse(struct soap *soap, const struct _tds__DeleteUsersResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__DeleteUsersResponse);
	if (soap_out__tds__DeleteUsersResponse(soap, tag?tag:"tds:DeleteUsersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteUsersResponse * SOAP_FMAC4 soap_get__tds__DeleteUsersResponse(struct soap *soap, struct _tds__DeleteUsersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__DeleteUsers(struct soap *soap, struct _tds__DeleteUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeUsername = 0;
	a->Username = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__DeleteUsers(struct soap *soap, const struct _tds__DeleteUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Username)
	{	
		int i;
		for (i = 0; i < a->__sizeUsername; i++)
		{
			soap_serialize_string(soap, a->Username + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteUsers(struct soap *soap, const char *tag, int id, const struct _tds__DeleteUsers *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteUsers), type))
		return soap->error;
	if (a->Username)
	{	
		int i;
		for (i = 0; i < a->__sizeUsername; i++)
			if (soap_out_string(soap, "tds:Username", -1, a->Username + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__DeleteUsers * SOAP_FMAC4 soap_in__tds__DeleteUsers(struct soap *soap, const char *tag, struct _tds__DeleteUsers *a, const char *type)
{
	struct soap_blist *soap_blist_Username = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__DeleteUsers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteUsers, sizeof(struct _tds__DeleteUsers), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__DeleteUsers(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Username", 1, NULL))
			{	
				if (a->Username == NULL)
				{	
					if (soap_blist_Username == NULL)
						soap_blist_Username = soap_new_block(soap);
					a->Username = (char **)soap_push_block(soap, soap_blist_Username, sizeof(char *));
					if (a->Username == NULL)
						return NULL;
					*a->Username = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tds:Username", a->Username, "xsd:string"))
				{	
					a->__sizeUsername++;
					a->Username = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Username)
			soap_pop_block(soap, soap_blist_Username);
		if (a->__sizeUsername)
			a->Username = (char **)soap_save_block(soap, soap_blist_Username, NULL, 1);
		else
		{	
			a->Username = NULL;
			if (soap_blist_Username)
				soap_end_block(soap, soap_blist_Username);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__DeleteUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteUsers, 0, sizeof(struct _tds__DeleteUsers), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeUsername < 1))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__DeleteUsers(struct soap *soap, const struct _tds__DeleteUsers *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__DeleteUsers);
	if (soap_out__tds__DeleteUsers(soap, tag?tag:"tds:DeleteUsers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteUsers * SOAP_FMAC4 soap_get__tds__DeleteUsers(struct soap *soap, struct _tds__DeleteUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetUser(struct soap *soap, struct __tds__SetUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetUser(struct soap *soap, const struct __tds__SetUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetUser(soap, &a->tds__SetUser);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetUser(struct soap *soap, const char *tag, int id, const struct __tds__SetUser *a, const char *type)
{
	if (soap_out_PointerTo_tds__SetUser(soap, "tds:SetUser", -1, &a->tds__SetUser, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetUser * SOAP_FMAC4 soap_in___tds__SetUser(struct soap *soap, const char *tag, struct __tds__SetUser *a, const char *type)
{
	size_t soap_flag_tds__SetUser = 1;
	short soap_flag;
	a = (struct __tds__SetUser *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetUser, sizeof(struct __tds__SetUser), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___tds__SetUser(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__SetUser && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__SetUser(soap, "tds:SetUser", &a->tds__SetUser, ""))
			{	
				soap_flag_tds__SetUser--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetUser(struct soap *soap, const struct __tds__SetUser *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetUser(soap, tag?tag:"-tds:SetUser", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetUser * SOAP_FMAC4 soap_get___tds__SetUser(struct soap *soap, struct __tds__SetUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetUserResponse(struct soap *soap, struct _tds__SetUserResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetUserResponse))
		soap_serialize__tds__SetUserResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetUserResponse(struct soap *soap, const char *tag, int id, struct _tds__SetUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetUserResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetUserResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetUserResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetUserResponse(struct soap *soap, const char *tag, struct _tds__SetUserResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__SetUserResponse **)soap_malloc(soap, sizeof(struct _tds__SetUserResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__SetUserResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetUserResponse, sizeof(struct _tds__SetUserResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetUserResponse(struct soap *soap, struct _tds__SetUserResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetUserResponse);
	if (soap_out_PointerTo_tds__SetUserResponse(soap, tag?tag:"tds:SetUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetUserResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetUserResponse(struct soap *soap, struct _tds__SetUserResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetUser(struct soap *soap, struct _tds__SetUser *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetUser))
		soap_serialize__tds__SetUser(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetUser(struct soap *soap, const char *tag, int id, struct _tds__SetUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetUser);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetUser(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetUser ** SOAP_FMAC4 soap_in_PointerTo_tds__SetUser(struct soap *soap, const char *tag, struct _tds__SetUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__SetUser **)soap_malloc(soap, sizeof(struct _tds__SetUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__SetUser(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetUser, sizeof(struct _tds__SetUser), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetUser(struct soap *soap, struct _tds__SetUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetUser);
	if (soap_out_PointerTo_tds__SetUser(soap, tag?tag:"tds:SetUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetUser ** SOAP_FMAC4 soap_get_PointerTo_tds__SetUser(struct soap *soap, struct _tds__SetUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetUserResponse(struct soap *soap, struct _tds__SetUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetUserResponse(struct soap *soap, const struct _tds__SetUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetUserResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetUserResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetUserResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetUserResponse * SOAP_FMAC4 soap_in__tds__SetUserResponse(struct soap *soap, const char *tag, struct _tds__SetUserResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetUserResponse, sizeof(struct _tds__SetUserResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__SetUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetUserResponse, 0, sizeof(struct _tds__SetUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetUserResponse(struct soap *soap, const struct _tds__SetUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetUserResponse);
	if (soap_out__tds__SetUserResponse(soap, tag?tag:"tds:SetUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetUserResponse * SOAP_FMAC4 soap_get__tds__SetUserResponse(struct soap *soap, struct _tds__SetUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetUser(struct soap *soap, struct _tds__SetUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeUser = 0;
	a->User = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetUser(struct soap *soap, const struct _tds__SetUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->User)
	{	
		int i;
		for (i = 0; i < a->__sizeUser; i++)
		{
			soap_embedded(soap, a->User + i, SOAP_TYPE_tt__User);
			soap_serialize_tt__User(soap, a->User + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetUser(struct soap *soap, const char *tag, int id, const struct _tds__SetUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetUser), type))
		return soap->error;
	if (a->User)
	{	
		int i;
		for (i = 0; i < a->__sizeUser; i++)
			if (soap_out_tt__User(soap, "tds:User", -1, a->User + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetUser * SOAP_FMAC4 soap_in__tds__SetUser(struct soap *soap, const char *tag, struct _tds__SetUser *a, const char *type)
{
	struct soap_blist *soap_blist_User = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetUser, sizeof(struct _tds__SetUser), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__SetUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:User", 1, NULL))
			{	
				if (a->User == NULL)
				{	
					if (soap_blist_User == NULL)
						soap_blist_User = soap_new_block(soap);
					a->User = (struct tt__User *)soap_push_block(soap, soap_blist_User, sizeof(struct tt__User));
					if (a->User == NULL)
						return NULL;
					soap_default_tt__User(soap, a->User);
				}
				soap_revert(soap);
				if (soap_in_tt__User(soap, "tds:User", a->User, "tt:User"))
				{	
					a->__sizeUser++;
					a->User = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->User)
			soap_pop_block(soap, soap_blist_User);
		if (a->__sizeUser)
			a->User = (struct tt__User *)soap_save_block(soap, soap_blist_User, NULL, 1);
		else
		{	
			a->User = NULL;
			if (soap_blist_User)
				soap_end_block(soap, soap_blist_User);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetUser, 0, sizeof(struct _tds__SetUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeUser < 1))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetUser(struct soap *soap, const struct _tds__SetUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetUser);
	if (soap_out__tds__SetUser(soap, tag?tag:"tds:SetUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetUser * SOAP_FMAC4 soap_get__tds__SetUser(struct soap *soap, struct _tds__SetUser *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__User(struct soap *soap, struct tt__User *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__User))
		soap_serialize_tt__User(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__User(struct soap *soap, const char *tag, int id, struct tt__User *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__User);
	if (id < 0)
		return soap->error;
	return soap_out_tt__User(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__User ** SOAP_FMAC4 soap_in_PointerTott__User(struct soap *soap, const char *tag, struct tt__User **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__User **)soap_malloc(soap, sizeof(struct tt__User *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__User(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__User **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__User, sizeof(struct tt__User), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__User(struct soap *soap, struct tt__User *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__User);
	if (soap_out_PointerTott__User(soap, tag?tag:"tt:User", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__User ** SOAP_FMAC4 soap_get_PointerTott__User(struct soap *soap, struct tt__User **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__User(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

//device network
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DNSName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__DNSName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__DNSName(struct soap *soap, const char *tag, char **a, const char *type)
{	
	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__DNSName, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DNSName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__DNSName);
	if (soap_out_tt__DNSName(soap, tag?tag:"byte", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__DNSName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DNSName(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__HwAddress(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__HwAddress);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__HwAddress(struct soap *soap, const char *tag, char **a, const char *type)
{	
	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__HwAddress, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__HwAddress(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__HwAddress);
	if (soap_out_tt__HwAddress(soap, tag?tag:"byte", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__HwAddress(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__HwAddress(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv4NetworkInterfaceSetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Enabled = NULL;
	a->__sizeManual = 0;
	a->Manual = NULL;
	a->DHCP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const struct tt__IPv4NetworkInterfaceSetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean_(soap, &a->Enabled);
	if (a->Manual != NULL)
	{	
		int i;
		for (i = 0; i < a->__sizeManual; i++)
		{
			soap_embedded(soap, a->Manual + i, SOAP_TYPE_tt__PrefixedIPv4Address);
			soap_serialize_tt__PrefixedIPv4Address(soap, a->Manual + i);
		}
	}
	soap_serialize_PointerToxsd__boolean_(soap, &a->DHCP);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, const struct tt__IPv4NetworkInterfaceSetConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration), type))
	{
		return soap->error;
	}
	if (soap_out_PointerToxsd__boolean_(soap, "tt:Enabled", -1, &a->Enabled, ""))
	{
		return soap->error;
	}
	if (a->Manual != NULL)
	{	
		int i;
		for (i = 0; i < a->__sizeManual; i++)
		{
			if (soap_out_tt__PrefixedIPv4Address(soap, "tt:Manual", -1, a->Manual + i, ""))
			{
				return soap->error;
			}
		}
	}
	if (soap_out_PointerToxsd__boolean_(soap, "tt:DHCP", -1, &a->DHCP, ""))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPv4NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_in_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, struct tt__IPv4NetworkInterfaceSetConfiguration *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	struct soap_blist *soap_blist_Manual = NULL;
	size_t soap_flag_DHCP = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__IPv4NetworkInterfaceSetConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, sizeof(struct tt__IPv4NetworkInterfaceSetConfiguration), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__IPv4NetworkInterfaceSetConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:Enabled", &a->Enabled, "xsd:boolean"))
				{	
					soap_flag_Enabled--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Manual", 1, NULL))
			{	
				if (a->Manual == NULL)
				{	
					if (soap_blist_Manual == NULL)
					{
						soap_blist_Manual = soap_new_block(soap);
					}
					a->Manual = (struct tt__PrefixedIPv4Address *)soap_push_block(soap, soap_blist_Manual, sizeof(struct tt__PrefixedIPv4Address));
					if (a->Manual == NULL)
					{
						return NULL;
					}
					soap_default_tt__PrefixedIPv4Address(soap, a->Manual);
				}
				soap_revert(soap);
				if (soap_in_tt__PrefixedIPv4Address(soap, "tt:Manual", a->Manual, "tt:PrefixedIPv4Address"))
				{	
					a->__sizeManual++;
					a->Manual = NULL;
					continue;
				}
			}
			if (soap_flag_DHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:DHCP", &a->DHCP, "xsd:boolean"))
				{	
					soap_flag_DHCP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
			{
				soap->error = soap_ignore_element(soap);
			}
			if (soap->error == SOAP_NO_TAG)
			{
				break;
			}
			if (soap->error)
			{
				return NULL;
			}
		}
		if (a->Manual != NULL)
		{
			soap_pop_block(soap, soap_blist_Manual);
		}
		if (a->__sizeManual)
		{
			a->Manual = (struct tt__PrefixedIPv4Address *)soap_save_block(soap, soap_blist_Manual, NULL, 1);
		}	
		else
		{	
			a->Manual = NULL;
			if (soap_blist_Manual)
			{
				soap_end_block(soap, soap_blist_Manual);
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__IPv4NetworkInterfaceSetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, 0, sizeof(struct tt__IPv4NetworkInterfaceSetConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const struct tt__IPv4NetworkInterfaceSetConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration);
	if (soap_out_tt__IPv4NetworkInterfaceSetConfiguration(soap, tag?tag:"tt:IPv4NetworkInterfaceSetConfiguration", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv4NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_get_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv4NetworkInterfaceSetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv4NetworkInterfaceSetConfiguration(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkHostType(struct soap *soap, enum tt__NetworkHostType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__NetworkHostType
	*a = SOAP_DEFAULT_tt__NetworkHostType;
#else
	*a = (enum tt__NetworkHostType)0;
#endif
}

static const struct soap_code_map soap_codes_tt__NetworkHostType[] =
{	
	{ (long)tt__NetworkHostType__IPv4, "IPv4" },
	{ (long)tt__NetworkHostType__IPv6, "IPv6" },
	{ (long)tt__NetworkHostType__DNS, "DNS" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__NetworkHostType2s(struct soap *soap, enum tt__NetworkHostType n)
{	
	const char *s = soap_code_str(soap_codes_tt__NetworkHostType, (long)n);
	if (s != NULL)
	{
		return s;
	}
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkHostType(struct soap *soap, const char *tag, int id, const enum tt__NetworkHostType *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkHostType), type) || soap_send(soap, soap_tt__NetworkHostType2s(soap, *a)))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__NetworkHostType(struct soap *soap, const char *s, enum tt__NetworkHostType *a)
{
	const struct soap_code_map *map;
	if (NULL==s)
	{
		return soap->error;
	}
	map = soap_code(soap_codes_tt__NetworkHostType, s);
	if (map != NULL)
	{
		*a = (enum tt__NetworkHostType)map->code;
	}
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
		{
			return soap->error = SOAP_TYPE;
		}
		*a = (enum tt__NetworkHostType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__NetworkHostType * SOAP_FMAC4 soap_in_tt__NetworkHostType(struct soap *soap, const char *tag, enum tt__NetworkHostType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (enum tt__NetworkHostType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkHostType, sizeof(enum tt__NetworkHostType), 0, NULL, NULL, NULL);
	if (NULL==a)
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	
		if ((NULL==a) || soap_s2tt__NetworkHostType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (enum tt__NetworkHostType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkHostType, 0, sizeof(enum tt__NetworkHostType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkHostType(struct soap *soap, const enum tt__NetworkHostType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkHostType);
	if (soap_out_tt__NetworkHostType(soap, tag?tag:"tt:NetworkHostType", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__NetworkHostType * SOAP_FMAC4 soap_get_tt__NetworkHostType(struct soap *soap, enum tt__NetworkHostType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkHostType(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkHostExtension(struct soap *soap, struct tt__NetworkHostExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkHostExtension(struct soap *soap, const struct tt__NetworkHostExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkHostExtension(struct soap *soap, const char *tag, int id, const struct tt__NetworkHostExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkHostExtension), type))
	{
		return soap->error;
	}
	if (a->__any != NULL)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_outliteral(soap, "-any", a->__any + i, NULL);
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkHostExtension * SOAP_FMAC4 soap_in_tt__NetworkHostExtension(struct soap *soap, const char *tag, struct tt__NetworkHostExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__NetworkHostExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkHostExtension, sizeof(struct tt__NetworkHostExtension), 0, NULL, NULL, NULL);
	if (NULL==a)
	{
		return NULL;
	}
	soap_default_tt__NetworkHostExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
					{
						soap_blist___any = soap_new_block(soap);
					}
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
					{
						return NULL;
					}
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{
				soap->error = soap_ignore_element(soap);
			}
			if (soap->error == SOAP_NO_TAG)
			{
				break;
			}
			if (soap->error)
			{
				return NULL;
			}
		}
		if (a->__any != NULL)
		{
			soap_pop_block(soap, soap_blist___any);
		}
		if (a->__size)
		{
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
			{
				soap_end_block(soap, soap_blist___any);
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__NetworkHostExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkHostExtension, 0, sizeof(struct tt__NetworkHostExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkHostExtension(struct soap *soap, const struct tt__NetworkHostExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkHostExtension);
	if (soap_out_tt__NetworkHostExtension(soap, tag?tag:"tt:NetworkHostExtension", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkHostExtension * SOAP_FMAC4 soap_get_tt__NetworkHostExtension(struct soap *soap, struct tt__NetworkHostExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkHostExtension(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkHostExtension(struct soap *soap, struct tt__NetworkHostExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkHostExtension))
	{
		soap_serialize_tt__NetworkHostExtension(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkHostExtension(struct soap *soap, const char *tag, int id, struct tt__NetworkHostExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkHostExtension);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__NetworkHostExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkHostExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkHostExtension(struct soap *soap, const char *tag, struct tt__NetworkHostExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (NULL==a)
	{
		if (NULL==(a = (struct tt__NetworkHostExtension **)soap_malloc(soap, sizeof(struct tt__NetworkHostExtension *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__NetworkHostExtension(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__NetworkHostExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkHostExtension, sizeof(struct tt__NetworkHostExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkHostExtension(struct soap *soap, struct tt__NetworkHostExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkHostExtension);
	if (soap_out_PointerTott__NetworkHostExtension(soap, tag?tag:"tt:NetworkHostExtension", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkHostExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkHostExtension(struct soap *soap, struct tt__NetworkHostExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkHostExtension(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkHost(struct soap *soap, struct tt__NetworkHost *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__NetworkHostType(soap, &a->Type);
	a->IPv4Address = NULL;
	a->IPv6Address = NULL;
	a->DNSname = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkHost(struct soap *soap, const struct tt__NetworkHost *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IPv4Address(soap, &a->IPv4Address);
	soap_serialize_PointerTott__IPv6Address(soap, &a->IPv6Address);
	soap_serialize_PointerTott__DNSName(soap, &a->DNSname);
	soap_serialize_PointerTott__NetworkHostExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkHost(struct soap *soap, const char *tag, int id, const struct tt__NetworkHost *a, const char *type)
{
	if (a->__anyAttribute != NULL)
	{
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	}
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkHost), type))
	{
		return soap->error;
	}
	if (soap_out_tt__NetworkHostType(soap, "tt:Type", -1, &a->Type, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__IPv4Address(soap, "tt:IPv4Address", -1, &a->IPv4Address, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__IPv6Address(soap, "tt:IPv6Address", -1, &a->IPv6Address, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__DNSName(soap, "tt:DNSname", -1, &a->DNSname, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__NetworkHostExtension(soap, "tt:Extension", -1, &a->Extension, ""))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkHost * SOAP_FMAC4 soap_in_tt__NetworkHost(struct soap *soap, const char *tag, struct tt__NetworkHost *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_IPv4Address = 1;
	size_t soap_flag_IPv6Address = 1;
	size_t soap_flag_DNSname = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__NetworkHost *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkHost, sizeof(struct tt__NetworkHost), 0, NULL, NULL, NULL);
	if (NULL==a)
	{
		return NULL;
	}
	soap_default_tt__NetworkHost(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__NetworkHostType(soap, "tt:Type", &a->Type, "tt:NetworkHostType"))
				{	
					soap_flag_Type--;
					continue;
				}
			if (soap_flag_IPv4Address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv4Address(soap, "tt:IPv4Address", &a->IPv4Address, "tt:IPv4Address"))
				{	
					soap_flag_IPv4Address--;
					continue;
				}
			if (soap_flag_IPv6Address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv6Address(soap, "tt:IPv6Address", &a->IPv6Address, "tt:IPv6Address"))
				{	
					soap_flag_IPv6Address--;
					continue;
				}
			if (soap_flag_DNSname && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DNSName(soap, "tt:DNSname", &a->DNSname, "tt:DNSName"))
				{	
					soap_flag_DNSname--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkHostExtension(soap, "tt:Extension", &a->Extension, "tt:NetworkHostExtension"))
				{	
					soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
			{
				soap->error = soap_ignore_element(soap);
			}
			if (soap->error == SOAP_NO_TAG)
			{
				break;
			}
			if (soap->error)
			{
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__NetworkHost *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkHost, 0, sizeof(struct tt__NetworkHost), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkHost(struct soap *soap, const struct tt__NetworkHost *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkHost);
	if (soap_out_tt__NetworkHost(soap, tag?tag:"tt:NetworkHost", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkHost * SOAP_FMAC4 soap_get_tt__NetworkHost(struct soap *soap, struct tt__NetworkHost *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkHost(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetNetworkInterfaces(struct soap *soap, struct __tds__GetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetNetworkInterfaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetNetworkInterfaces(struct soap *soap, const struct __tds__GetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetNetworkInterfaces(soap, &a->tds__GetNetworkInterfaces);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetNetworkInterfaces(struct soap *soap, const char *tag, int id, const struct __tds__GetNetworkInterfaces *a, const char *type)
{
	if (soap_out_PointerTo_tds__GetNetworkInterfaces(soap, "tds:GetNetworkInterfaces", -1, &a->tds__GetNetworkInterfaces, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkInterfaces * SOAP_FMAC4 soap_in___tds__GetNetworkInterfaces(struct soap *soap, const char *tag, struct __tds__GetNetworkInterfaces *a, const char *type)
{
	size_t soap_flag_tds__GetNetworkInterfaces = 1;
	short soap_flag;
	a = (struct __tds__GetNetworkInterfaces *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetNetworkInterfaces, sizeof(struct __tds__GetNetworkInterfaces), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___tds__GetNetworkInterfaces(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__GetNetworkInterfaces && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__GetNetworkInterfaces(soap, "tds:GetNetworkInterfaces", &a->tds__GetNetworkInterfaces, ""))
			{	
				soap_flag_tds__GetNetworkInterfaces--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetNetworkInterfaces(struct soap *soap, const struct __tds__GetNetworkInterfaces *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetNetworkInterfaces(soap, tag?tag:"-tds:GetNetworkInterfaces", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkInterfaces * SOAP_FMAC4 soap_get___tds__GetNetworkInterfaces(struct soap *soap, struct __tds__GetNetworkInterfaces *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkInterfacesResponse(struct soap *soap, struct _tds__GetNetworkInterfacesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkInterfacesResponse))
		soap_serialize__tds__GetNetworkInterfacesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkInterfacesResponse(struct soap *soap, const char *tag, int id, struct _tds__GetNetworkInterfacesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkInterfacesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetNetworkInterfacesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetNetworkInterfacesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkInterfacesResponse(struct soap *soap, const char *tag, struct _tds__GetNetworkInterfacesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__GetNetworkInterfacesResponse **)soap_malloc(soap, sizeof(struct _tds__GetNetworkInterfacesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__GetNetworkInterfacesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetNetworkInterfacesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkInterfacesResponse, sizeof(struct _tds__GetNetworkInterfacesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkInterfacesResponse(struct soap *soap, struct _tds__GetNetworkInterfacesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNetworkInterfacesResponse);
	if (soap_out_PointerTo_tds__GetNetworkInterfacesResponse(soap, tag?tag:"tds:GetNetworkInterfacesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkInterfacesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkInterfacesResponse(struct soap *soap, struct _tds__GetNetworkInterfacesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkInterfacesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, struct _tds__GetNetworkInterfaces *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkInterfaces))
		soap_serialize__tds__GetNetworkInterfaces(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, const char *tag, int id, struct _tds__GetNetworkInterfaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkInterfaces);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetNetworkInterfaces(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetNetworkInterfaces ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, const char *tag, struct _tds__GetNetworkInterfaces **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__GetNetworkInterfaces **)soap_malloc(soap, sizeof(struct _tds__GetNetworkInterfaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__GetNetworkInterfaces(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetNetworkInterfaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkInterfaces, sizeof(struct _tds__GetNetworkInterfaces), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, struct _tds__GetNetworkInterfaces *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNetworkInterfaces);
	if (soap_out_PointerTo_tds__GetNetworkInterfaces(soap, tag?tag:"tds:GetNetworkInterfaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkInterfaces ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, struct _tds__GetNetworkInterfaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceInfo(struct soap *soap, struct tt__NetworkInterfaceInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceInfo))
		soap_serialize_tt__NetworkInterfaceInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceInfo(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceInfo);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceInfo ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceInfo(struct soap *soap, const char *tag, struct tt__NetworkInterfaceInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__NetworkInterfaceInfo **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__NetworkInterfaceInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceInfo, sizeof(struct tt__NetworkInterfaceInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceInfo(struct soap *soap, struct tt__NetworkInterfaceInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkInterfaceInfo);
	if (soap_out_PointerTott__NetworkInterfaceInfo(soap, tag?tag:"tt:NetworkInterfaceInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceInfo ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceInfo(struct soap *soap, struct tt__NetworkInterfaceInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceLink(struct soap *soap, struct tt__NetworkInterfaceLink *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceLink))
		soap_serialize_tt__NetworkInterfaceLink(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceLink(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceLink *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceLink);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceLink(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceLink ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceLink(struct soap *soap, const char *tag, struct tt__NetworkInterfaceLink **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__NetworkInterfaceLink **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceLink *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceLink(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__NetworkInterfaceLink **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceLink, sizeof(struct tt__NetworkInterfaceLink), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceLink(struct soap *soap, struct tt__NetworkInterfaceLink *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkInterfaceLink);
	if (soap_out_PointerTott__NetworkInterfaceLink(soap, tag?tag:"tt:NetworkInterfaceLink", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceLink ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceLink(struct soap *soap, struct tt__NetworkInterfaceLink **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4NetworkInterface(struct soap *soap, struct tt__IPv4NetworkInterface *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4NetworkInterface))
		soap_serialize_tt__IPv4NetworkInterface(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4NetworkInterface(struct soap *soap, const char *tag, int id, struct tt__IPv4NetworkInterface *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4NetworkInterface);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv4NetworkInterface(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPv4NetworkInterface ** SOAP_FMAC4 soap_in_PointerTott__IPv4NetworkInterface(struct soap *soap, const char *tag, struct tt__IPv4NetworkInterface **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a== NULL)
		if (!(a = (struct tt__IPv4NetworkInterface **)soap_malloc(soap, sizeof(struct tt__IPv4NetworkInterface *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__IPv4NetworkInterface(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__IPv4NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4NetworkInterface, sizeof(struct tt__IPv4NetworkInterface), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4NetworkInterface(struct soap *soap, struct tt__IPv4NetworkInterface *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv4NetworkInterface);
	if (soap_out_PointerTott__IPv4NetworkInterface(soap, tag?tag:"tt:IPv4NetworkInterface", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv4NetworkInterface ** SOAP_FMAC4 soap_get_PointerTott__IPv4NetworkInterface(struct soap *soap, struct tt__IPv4NetworkInterface **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv4NetworkInterfaceSetConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration))
		soap_serialize_tt__IPv4NetworkInterfaceSetConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, struct tt__IPv4NetworkInterfaceSetConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv4NetworkInterfaceSetConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPv4NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_in_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, struct tt__IPv4NetworkInterfaceSetConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__IPv4NetworkInterfaceSetConfiguration **)soap_malloc(soap, sizeof(struct tt__IPv4NetworkInterfaceSetConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__IPv4NetworkInterfaceSetConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__IPv4NetworkInterfaceSetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, sizeof(struct tt__IPv4NetworkInterfaceSetConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv4NetworkInterfaceSetConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv4NetworkInterfaceSetConfiguration);
	if (soap_out_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, tag?tag:"tt:IPv4NetworkInterfaceSetConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv4NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_get_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv4NetworkInterfaceSetConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6NetworkInterface(struct soap *soap, struct tt__IPv6NetworkInterface *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6NetworkInterface))
		soap_serialize_tt__IPv6NetworkInterface(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6NetworkInterface(struct soap *soap, const char *tag, int id, struct tt__IPv6NetworkInterface *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6NetworkInterface);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv6NetworkInterface(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPv6NetworkInterface ** SOAP_FMAC4 soap_in_PointerTott__IPv6NetworkInterface(struct soap *soap, const char *tag, struct tt__IPv6NetworkInterface **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__IPv6NetworkInterface **)soap_malloc(soap, sizeof(struct tt__IPv6NetworkInterface *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__IPv6NetworkInterface(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__IPv6NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6NetworkInterface, sizeof(struct tt__IPv6NetworkInterface), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6NetworkInterface(struct soap *soap, struct tt__IPv6NetworkInterface *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv6NetworkInterface);
	if (soap_out_PointerTott__IPv6NetworkInterface(soap, tag?tag:"tt:IPv6NetworkInterface", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv6NetworkInterface ** SOAP_FMAC4 soap_get_PointerTott__IPv6NetworkInterface(struct soap *soap, struct tt__IPv6NetworkInterface **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv6NetworkInterfaceSetConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration))
		soap_serialize_tt__IPv6NetworkInterfaceSetConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, struct tt__IPv6NetworkInterfaceSetConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv6NetworkInterfaceSetConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPv6NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_in_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, struct tt__IPv6NetworkInterfaceSetConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__IPv6NetworkInterfaceSetConfiguration **)soap_malloc(soap, sizeof(struct tt__IPv6NetworkInterfaceSetConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__IPv6NetworkInterfaceSetConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__IPv6NetworkInterfaceSetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, sizeof(struct tt__IPv6NetworkInterfaceSetConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv6NetworkInterfaceSetConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv6NetworkInterfaceSetConfiguration);
	if (soap_out_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, tag?tag:"tt:IPv6NetworkInterfaceSetConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv6NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_get_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv6NetworkInterfaceSetConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkInterfaceExtension(struct soap *soap, struct tt__NetworkInterfaceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_tt__IANA_IfTypes(soap, &a->InterfaceType);
	a->__sizeDot3 = 0;
	a->Dot3 = NULL;
	a->__sizeDot11 = 0;
	a->Dot11 = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterfaceExtension(struct soap *soap, const struct tt__NetworkInterfaceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Dot3)
	{	
		int i;
		for (i = 0; i < a->__sizeDot3; i++)
		{
			soap_embedded(soap, a->Dot3 + i, SOAP_TYPE_tt__Dot3Configuration);
			soap_serialize_tt__Dot3Configuration(soap, a->Dot3 + i);
		}
	}
	if (a->Dot11)
	{	
		int i;
		for (i = 0; i < a->__sizeDot11; i++)
		{
			soap_embedded(soap, a->Dot11 + i, SOAP_TYPE_tt__Dot11Configuration);
			soap_serialize_tt__Dot11Configuration(soap, a->Dot11 + i);
		}
	}
	soap_serialize_PointerTott__NetworkInterfaceExtension2(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceExtension(struct soap *soap, const char *tag, int id, const struct tt__NetworkInterfaceExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceExtension), type))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	if (soap_out_tt__IANA_IfTypes(soap, "tt:InterfaceType", -1, &a->InterfaceType, ""))
		return soap->error;
	if (a->Dot3)
	{	
		int i;
		for (i = 0; i < a->__sizeDot3; i++)
			if (soap_out_tt__Dot3Configuration(soap, "tt:Dot3", -1, a->Dot3 + i, ""))
				return soap->error;
	}
	if (a->Dot11)
	{	
		int i;
		for (i = 0; i < a->__sizeDot11; i++)
			if (soap_out_tt__Dot11Configuration(soap, "tt:Dot11", -1, a->Dot11 + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__NetworkInterfaceExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension * SOAP_FMAC4 soap_in_tt__NetworkInterfaceExtension(struct soap *soap, const char *tag, struct tt__NetworkInterfaceExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_InterfaceType = 1;
	struct soap_blist *soap_blist_Dot3 = NULL;
	struct soap_blist *soap_blist_Dot11 = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkInterfaceExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceExtension, sizeof(struct tt__NetworkInterfaceExtension), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__NetworkInterfaceExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap_flag_InterfaceType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__IANA_IfTypes(soap, "tt:InterfaceType", &a->InterfaceType, "tt:IANA-IfTypes"))
				{	
					soap_flag_InterfaceType--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Dot3", 1, NULL))
				{	
					if (a->Dot3 == NULL)
					{	
						if (soap_blist_Dot3 == NULL)
							soap_blist_Dot3 = soap_new_block(soap);
						a->Dot3 = (struct tt__Dot3Configuration *)soap_push_block(soap, soap_blist_Dot3, sizeof(struct tt__Dot3Configuration));
						if (a->Dot3 == NULL)
							return NULL;
						soap_default_tt__Dot3Configuration(soap, a->Dot3);
					}
					soap_revert(soap);
					if (soap_in_tt__Dot3Configuration(soap, "tt:Dot3", a->Dot3, "tt:Dot3Configuration"))
					{	
						a->__sizeDot3++;
						a->Dot3 = NULL;
						continue;
					}
				}
				if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Dot11", 1, NULL))
				{	
					if (a->Dot11 == NULL)
					{	
						if (soap_blist_Dot11 == NULL)
							soap_blist_Dot11 = soap_new_block(soap);
						a->Dot11 = (struct tt__Dot11Configuration *)soap_push_block(soap, soap_blist_Dot11, sizeof(struct tt__Dot11Configuration));
						if (a->Dot11 == NULL)
							return NULL;
						soap_default_tt__Dot11Configuration(soap, a->Dot11);
					}
					soap_revert(soap);
					if (soap_in_tt__Dot11Configuration(soap, "tt:Dot11", a->Dot11, "tt:Dot11Configuration"))
					{	
						a->__sizeDot11++;
						a->Dot11 = NULL;
						continue;
					}
				}
				if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__NetworkInterfaceExtension2(soap, "tt:Extension", &a->Extension, "tt:NetworkInterfaceExtension2"))
					{	
						soap_flag_Extension--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH)
						soap->error = soap_ignore_element(soap);
					if (soap->error == SOAP_NO_TAG)
						break;
					if (soap->error)
						return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->Dot3)
			soap_pop_block(soap, soap_blist_Dot3);
		if (a->__sizeDot3)
			a->Dot3 = (struct tt__Dot3Configuration *)soap_save_block(soap, soap_blist_Dot3, NULL, 1);
		else
		{	
			a->Dot3 = NULL;
			if (soap_blist_Dot3)
				soap_end_block(soap, soap_blist_Dot3);
		}
		if (a->Dot11)
			soap_pop_block(soap, soap_blist_Dot11);
		if (a->__sizeDot11)
			a->Dot11 = (struct tt__Dot11Configuration *)soap_save_block(soap, soap_blist_Dot11, NULL, 1);
		else
		{	
			a->Dot11 = NULL;
			if (soap_blist_Dot11)
				soap_end_block(soap, soap_blist_Dot11);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__NetworkInterfaceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceExtension, 0, sizeof(struct tt__NetworkInterfaceExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceType > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterfaceExtension(struct soap *soap, const struct tt__NetworkInterfaceExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkInterfaceExtension);
	if (soap_out_tt__NetworkInterfaceExtension(soap, tag?tag:"tt:NetworkInterfaceExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension * SOAP_FMAC4 soap_get_tt__NetworkInterfaceExtension(struct soap *soap, struct tt__NetworkInterfaceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceExtension(struct soap *soap, struct tt__NetworkInterfaceExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceExtension))
		soap_serialize_tt__NetworkInterfaceExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceExtension(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceExtension(struct soap *soap, const char *tag, struct tt__NetworkInterfaceExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__NetworkInterfaceExtension **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__NetworkInterfaceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceExtension, sizeof(struct tt__NetworkInterfaceExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceExtension(struct soap *soap, struct tt__NetworkInterfaceExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkInterfaceExtension);
	if (soap_out_PointerTott__NetworkInterfaceExtension(soap, tag?tag:"tt:NetworkInterfaceExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceExtension(struct soap *soap, struct tt__NetworkInterfaceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkInterface(struct soap *soap, struct tt__NetworkInterface *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_xsd__boolean_(soap, &a->Enabled);
	a->Info = NULL;
	a->Link = NULL;
	a->IPv4 = NULL;
	a->IPv6 = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterface(struct soap *soap, const struct tt__NetworkInterface *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean_);
	soap_serialize_PointerTott__NetworkInterfaceInfo(soap, &a->Info);
	soap_serialize_PointerTott__NetworkInterfaceLink(soap, &a->Link);
	soap_serialize_PointerTott__IPv4NetworkInterface(soap, &a->IPv4);
	soap_serialize_PointerTott__IPv6NetworkInterface(soap, &a->IPv6);
	soap_serialize_PointerTott__NetworkInterfaceExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterface(struct soap *soap, const char *tag, int id, const struct tt__NetworkInterface *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterface), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceInfo(soap, "tt:Info", -1, &a->Info, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceLink(soap, "tt:Link", -1, &a->Link, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv4NetworkInterface(soap, "tt:IPv4", -1, &a->IPv4, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6NetworkInterface(soap, "tt:IPv6", -1, &a->IPv6, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkInterface * SOAP_FMAC4 soap_in_tt__NetworkInterface(struct soap *soap, const char *tag, struct tt__NetworkInterface *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_Info = 1;
	size_t soap_flag_Link = 1;
	size_t soap_flag_IPv4 = 1;
	size_t soap_flag_IPv6 = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkInterface *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterface, sizeof(struct tt__NetworkInterface), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__NetworkInterface(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, 0, 64))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:Enabled", &a->Enabled, "xsd:boolean"))
				{	
					soap_flag_Enabled--;
					continue;
				}
				if (soap_flag_Info && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__NetworkInterfaceInfo(soap, "tt:Info", &a->Info, "tt:NetworkInterfaceInfo"))
					{	
						soap_flag_Info--;
						continue;
					}
					if (soap_flag_Link && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTott__NetworkInterfaceLink(soap, "tt:Link", &a->Link, "tt:NetworkInterfaceLink"))
						{	
							soap_flag_Link--;
							continue;
						}
						if (soap_flag_IPv4 && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_PointerTott__IPv4NetworkInterface(soap, "tt:IPv4", &a->IPv4, "tt:IPv4NetworkInterface"))
							{	
								soap_flag_IPv4--;
								continue;
							}
							if (soap_flag_IPv6 && soap->error == SOAP_TAG_MISMATCH)
								if (soap_in_PointerTott__IPv6NetworkInterface(soap, "tt:IPv6", &a->IPv6, "tt:IPv6NetworkInterface"))
								{	
									soap_flag_IPv6--;
									continue;
								}
								if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
									if (soap_in_PointerTott__NetworkInterfaceExtension(soap, "tt:Extension", &a->Extension, "tt:NetworkInterfaceExtension"))
									{	
										soap_flag_Extension--;
										continue;
									}
									if (soap->error == SOAP_TAG_MISMATCH)
										soap->error = soap_ignore_element(soap);
									if (soap->error == SOAP_NO_TAG)
										break;
									if (soap->error)
										return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__NetworkInterface *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterface, 0, sizeof(struct tt__NetworkInterface), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterface(struct soap *soap, const struct tt__NetworkInterface *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkInterface);
	if (soap_out_tt__NetworkInterface(soap, tag?tag:"tt:NetworkInterface", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterface * SOAP_FMAC4 soap_get_tt__NetworkInterface(struct soap *soap, struct tt__NetworkInterface *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNetworkInterfacesResponse(struct soap *soap, struct _tds__GetNetworkInterfacesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNetworkInterfaces = 0;
	a->NetworkInterfaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNetworkInterfacesResponse(struct soap *soap, const struct _tds__GetNetworkInterfacesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->NetworkInterfaces)
	{	
		int i;
		for (i = 0; i < a->__sizeNetworkInterfaces; i++)
		{
			soap_embedded(soap, a->NetworkInterfaces + i, SOAP_TYPE_tt__NetworkInterface);
			soap_serialize_tt__NetworkInterface(soap, a->NetworkInterfaces + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkInterfacesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetNetworkInterfacesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkInterfacesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeNetworkInterfaces");
	if (a->NetworkInterfaces)
	{	
		int i;
		for (i = 0; i < a->__sizeNetworkInterfaces; i++)
			if (soap_out_tt__NetworkInterface(soap, "tds:NetworkInterfaces", -1, a->NetworkInterfaces + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNetworkInterfacesResponse * SOAP_FMAC4 soap_in__tds__GetNetworkInterfacesResponse(struct soap *soap, const char *tag, struct _tds__GetNetworkInterfacesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_NetworkInterfaces = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetNetworkInterfacesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkInterfacesResponse, sizeof(struct _tds__GetNetworkInterfacesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetNetworkInterfacesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NetworkInterfaces", 1, NULL))
			{	
				if (a->NetworkInterfaces == NULL)
				{	
					if (soap_blist_NetworkInterfaces == NULL)
						soap_blist_NetworkInterfaces = soap_new_block(soap);
					a->NetworkInterfaces = (struct tt__NetworkInterface *)soap_push_block(soap, soap_blist_NetworkInterfaces, sizeof(struct tt__NetworkInterface));
					if (a->NetworkInterfaces == NULL)
						return NULL;
					soap_default_tt__NetworkInterface(soap, a->NetworkInterfaces);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkInterface(soap, "tds:NetworkInterfaces", a->NetworkInterfaces, "tt:NetworkInterface"))
				{	
					a->__sizeNetworkInterfaces++;
					a->NetworkInterfaces = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeNetworkInterfaces");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NetworkInterfaces)
			soap_pop_block(soap, soap_blist_NetworkInterfaces);
		if (a->__sizeNetworkInterfaces)
			a->NetworkInterfaces = (struct tt__NetworkInterface *)soap_save_block(soap, soap_blist_NetworkInterfaces, NULL, 1);
		else
		{	
			a->NetworkInterfaces = NULL;
			if (soap_blist_NetworkInterfaces)
				soap_end_block(soap, soap_blist_NetworkInterfaces);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetNetworkInterfacesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkInterfacesResponse, 0, sizeof(struct _tds__GetNetworkInterfacesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeNetworkInterfaces < 1))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNetworkInterfacesResponse(struct soap *soap, const struct _tds__GetNetworkInterfacesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetNetworkInterfacesResponse);
	if (soap_out__tds__GetNetworkInterfacesResponse(soap, tag?tag:"tds:GetNetworkInterfacesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkInterfacesResponse * SOAP_FMAC4 soap_get__tds__GetNetworkInterfacesResponse(struct soap *soap, struct _tds__GetNetworkInterfacesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkInterfacesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNetworkInterfaces(struct soap *soap, struct _tds__GetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNetworkInterfaces(struct soap *soap, const struct _tds__GetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkInterfaces(struct soap *soap, const char *tag, int id, const struct _tds__GetNetworkInterfaces *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkInterfaces), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNetworkInterfaces * SOAP_FMAC4 soap_in__tds__GetNetworkInterfaces(struct soap *soap, const char *tag, struct _tds__GetNetworkInterfaces *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetNetworkInterfaces *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkInterfaces, sizeof(struct _tds__GetNetworkInterfaces), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__GetNetworkInterfaces(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetNetworkInterfaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkInterfaces, 0, sizeof(struct _tds__GetNetworkInterfaces), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNetworkInterfaces(struct soap *soap, const struct _tds__GetNetworkInterfaces *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetNetworkInterfaces);
	if (soap_out__tds__GetNetworkInterfaces(soap, tag?tag:"tds:GetNetworkInterfaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkInterfaces * SOAP_FMAC4 soap_get__tds__GetNetworkInterfaces(struct soap *soap, struct _tds__GetNetworkInterfaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkInterfaceInfo(struct soap *soap, struct tt__NetworkInterfaceInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	soap_default_tt__HwAddress(soap, &a->HwAddress);
	a->MTU = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterfaceInfo(struct soap *soap, const struct tt__NetworkInterfaceInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Name);
	soap_serialize_tt__HwAddress(soap, &a->HwAddress);
	soap_serialize_PointerToint(soap, &a->MTU);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceInfo(struct soap *soap, const char *tag, int id, const struct tt__NetworkInterfaceInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceInfo), type))
		return soap->error;
	if (soap_out_string(soap, "tt:Name", -1, &a->Name, ""))
		return soap->error;
	if (a->HwAddress)
	{	
		if (soap_out_tt__HwAddress(soap, "tt:HwAddress", -1, &a->HwAddress, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:HwAddress"))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:MTU", -1, &a->MTU, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkInterfaceInfo * SOAP_FMAC4 soap_in_tt__NetworkInterfaceInfo(struct soap *soap, const char *tag, struct tt__NetworkInterfaceInfo *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_HwAddress = 1;
	size_t soap_flag_MTU = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkInterfaceInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceInfo, sizeof(struct tt__NetworkInterfaceInfo), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__NetworkInterfaceInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Name", &a->Name, "xsd:string"))
				{	
					soap_flag_Name--;
					continue;
				}
				if (soap_flag_HwAddress && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
					if (soap_in_tt__HwAddress(soap, "tt:HwAddress", &a->HwAddress, "tt:HwAddress"))
					{	
						soap_flag_HwAddress--;
						continue;
					}
					if (soap_flag_MTU && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerToint(soap, "tt:MTU", &a->MTU, "xsd:int"))
						{	
							soap_flag_MTU--;
							continue;
						}
						if (soap->error == SOAP_TAG_MISMATCH)
							soap->error = soap_ignore_element(soap);
						if (soap->error == SOAP_NO_TAG)
							break;
						if (soap->error)
							return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__NetworkInterfaceInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceInfo, 0, sizeof(struct tt__NetworkInterfaceInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_HwAddress > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterfaceInfo(struct soap *soap, const struct tt__NetworkInterfaceInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkInterfaceInfo);
	if (soap_out_tt__NetworkInterfaceInfo(soap, tag?tag:"tt:NetworkInterfaceInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceInfo * SOAP_FMAC4 soap_get_tt__NetworkInterfaceInfo(struct soap *soap, struct tt__NetworkInterfaceInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkInterfaceLink(struct soap *soap, struct tt__NetworkInterfaceLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->AdminSettings = NULL;
	a->OperSettings = NULL;
	soap_default_tt__IANA_IfTypes(soap, &a->InterfaceType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterfaceLink(struct soap *soap, const struct tt__NetworkInterfaceLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(soap, &a->AdminSettings);
	soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(soap, &a->OperSettings);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceLink(struct soap *soap, const char *tag, int id, const struct tt__NetworkInterfaceLink *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceLink), type))
		return soap->error;
	if (a->AdminSettings)
	{	
		if (soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:AdminSettings", -1, &a->AdminSettings, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:AdminSettings"))
		return soap->error;
	if (a->OperSettings)
	{	
		if (soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:OperSettings", -1, &a->OperSettings, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:OperSettings"))
		return soap->error;
	if (soap_out_tt__IANA_IfTypes(soap, "tt:InterfaceType", -1, &a->InterfaceType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkInterfaceLink * SOAP_FMAC4 soap_in_tt__NetworkInterfaceLink(struct soap *soap, const char *tag, struct tt__NetworkInterfaceLink *a, const char *type)
{
	size_t soap_flag_AdminSettings = 1;
	size_t soap_flag_OperSettings = 1;
	size_t soap_flag_InterfaceType = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkInterfaceLink *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceLink, sizeof(struct tt__NetworkInterfaceLink), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__NetworkInterfaceLink(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AdminSettings && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:AdminSettings", &a->AdminSettings, "tt:NetworkInterfaceConnectionSetting"))
				{	
					soap_flag_AdminSettings--;
					continue;
				}
				if (soap_flag_OperSettings && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:OperSettings", &a->OperSettings, "tt:NetworkInterfaceConnectionSetting"))
					{	
						soap_flag_OperSettings--;
						continue;
					}
					if (soap_flag_InterfaceType && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_tt__IANA_IfTypes(soap, "tt:InterfaceType", &a->InterfaceType, "tt:IANA-IfTypes"))
						{	
							soap_flag_InterfaceType--;
							continue;
						}
						if (soap->error == SOAP_TAG_MISMATCH)
							soap->error = soap_ignore_element(soap);
						if (soap->error == SOAP_NO_TAG)
							break;
						if (soap->error)
							return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__NetworkInterfaceLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceLink, 0, sizeof(struct tt__NetworkInterfaceLink), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AdminSettings > 0 || soap_flag_OperSettings > 0 || soap_flag_InterfaceType > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterfaceLink(struct soap *soap, const struct tt__NetworkInterfaceLink *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkInterfaceLink);
	if (soap_out_tt__NetworkInterfaceLink(soap, tag?tag:"tt:NetworkInterfaceLink", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceLink * SOAP_FMAC4 soap_get_tt__NetworkInterfaceLink(struct soap *soap, struct tt__NetworkInterfaceLink *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPv4NetworkInterface(struct soap *soap, struct tt__IPv4NetworkInterface *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->Enabled);
	a->Config = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPv4NetworkInterface(struct soap *soap, const struct tt__IPv4NetworkInterface *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean_);
	soap_serialize_PointerTott__IPv4Configuration(soap, &a->Config);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv4NetworkInterface(struct soap *soap, const char *tag, int id, const struct tt__IPv4NetworkInterface *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv4NetworkInterface), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (a->Config)
	{	
		if (soap_out_PointerTott__IPv4Configuration(soap, "tt:Config", -1, &a->Config, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Config"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPv4NetworkInterface * SOAP_FMAC4 soap_in_tt__IPv4NetworkInterface(struct soap *soap, const char *tag, struct tt__IPv4NetworkInterface *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_Config = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IPv4NetworkInterface *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv4NetworkInterface, sizeof(struct tt__IPv4NetworkInterface), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__IPv4NetworkInterface(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:Enabled", &a->Enabled, "xsd:boolean"))
				{	
					soap_flag_Enabled--;
					continue;
				}
				if (soap_flag_Config && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__IPv4Configuration(soap, "tt:Config", &a->Config, "tt:IPv4Configuration"))
					{	
						soap_flag_Config--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH)
						soap->error = soap_ignore_element(soap);
					if (soap->error == SOAP_NO_TAG)
						break;
					if (soap->error)
						return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__IPv4NetworkInterface *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv4NetworkInterface, 0, sizeof(struct tt__IPv4NetworkInterface), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled > 0 || soap_flag_Config > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv4NetworkInterface(struct soap *soap, const struct tt__IPv4NetworkInterface *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPv4NetworkInterface);
	if (soap_out_tt__IPv4NetworkInterface(soap, tag?tag:"tt:IPv4NetworkInterface", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv4NetworkInterface * SOAP_FMAC4 soap_get_tt__IPv4NetworkInterface(struct soap *soap, struct tt__IPv4NetworkInterface *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv4NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPv6NetworkInterface(struct soap *soap, struct tt__IPv6NetworkInterface *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->Enabled);
	a->Config = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPv6NetworkInterface(struct soap *soap, const struct tt__IPv6NetworkInterface *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean_);
	soap_serialize_PointerTott__IPv6Configuration(soap, &a->Config);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6NetworkInterface(struct soap *soap, const char *tag, int id, const struct tt__IPv6NetworkInterface *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6NetworkInterface), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6Configuration(soap, "tt:Config", -1, &a->Config, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPv6NetworkInterface * SOAP_FMAC4 soap_in_tt__IPv6NetworkInterface(struct soap *soap, const char *tag, struct tt__IPv6NetworkInterface *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_Config = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IPv6NetworkInterface *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6NetworkInterface, sizeof(struct tt__IPv6NetworkInterface), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__IPv6NetworkInterface(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:Enabled", &a->Enabled, "xsd:boolean"))
				{	
					soap_flag_Enabled--;
					continue;
				}
				if (soap_flag_Config && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__IPv6Configuration(soap, "tt:Config", &a->Config, "tt:IPv6Configuration"))
					{	
						soap_flag_Config--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH)
						soap->error = soap_ignore_element(soap);
					if (soap->error == SOAP_NO_TAG)
						break;
					if (soap->error)
						return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__IPv6NetworkInterface *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6NetworkInterface, 0, sizeof(struct tt__IPv6NetworkInterface), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv6NetworkInterface(struct soap *soap, const struct tt__IPv6NetworkInterface *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPv6NetworkInterface);
	if (soap_out_tt__IPv6NetworkInterface(soap, tag?tag:"tt:IPv6NetworkInterface", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv6NetworkInterface * SOAP_FMAC4 soap_get_tt__IPv6NetworkInterface(struct soap *soap, struct tt__IPv6NetworkInterface *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv6NetworkInterfaceSetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Enabled = NULL;
	a->AcceptRouterAdvert = NULL;
	a->__sizeManual = 0;
	a->Manual = NULL;
	a->DHCP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const struct tt__IPv6NetworkInterfaceSetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean_(soap, &a->Enabled);
	soap_serialize_PointerToxsd__boolean_(soap, &a->AcceptRouterAdvert);
	if (a->Manual)
	{	
		int i;
		for (i = 0; i < a->__sizeManual; i++)
		{
			soap_embedded(soap, a->Manual + i, SOAP_TYPE_tt__PrefixedIPv6Address);
			soap_serialize_tt__PrefixedIPv6Address(soap, a->Manual + i);
		}
	}
	soap_serialize_PointerTott__IPv6DHCPConfiguration(soap, &a->DHCP);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, const struct tt__IPv6NetworkInterfaceSetConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:AcceptRouterAdvert", -1, &a->AcceptRouterAdvert, ""))
		return soap->error;
	if (a->Manual)
	{	
		int i;
		for (i = 0; i < a->__sizeManual; i++)
			if (soap_out_tt__PrefixedIPv6Address(soap, "tt:Manual", -1, a->Manual + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__IPv6DHCPConfiguration(soap, "tt:DHCP", -1, &a->DHCP, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPv6NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_in_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, struct tt__IPv6NetworkInterfaceSetConfiguration *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_AcceptRouterAdvert = 1;
	struct soap_blist *soap_blist_Manual = NULL;
	size_t soap_flag_DHCP = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IPv6NetworkInterfaceSetConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, sizeof(struct tt__IPv6NetworkInterfaceSetConfiguration), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__IPv6NetworkInterfaceSetConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:Enabled", &a->Enabled, "xsd:boolean"))
				{	
					soap_flag_Enabled--;
					continue;
				}
				if (soap_flag_AcceptRouterAdvert && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerToxsd__boolean_(soap, "tt:AcceptRouterAdvert", &a->AcceptRouterAdvert, "xsd:boolean"))
					{	
						soap_flag_AcceptRouterAdvert--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Manual", 1, NULL))
					{	
						if (a->Manual == NULL)
						{	
							if (soap_blist_Manual == NULL)
								soap_blist_Manual = soap_new_block(soap);
							a->Manual = (struct tt__PrefixedIPv6Address *)soap_push_block(soap, soap_blist_Manual, sizeof(struct tt__PrefixedIPv6Address));
							if (a->Manual == NULL)
								return NULL;
							soap_default_tt__PrefixedIPv6Address(soap, a->Manual);
						}
						soap_revert(soap);
						if (soap_in_tt__PrefixedIPv6Address(soap, "tt:Manual", a->Manual, "tt:PrefixedIPv6Address"))
						{	
							a->__sizeManual++;
							a->Manual = NULL;
							continue;
						}
					}
					if (soap_flag_DHCP && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTott__IPv6DHCPConfiguration(soap, "tt:DHCP", &a->DHCP, "tt:IPv6DHCPConfiguration"))
						{	
							soap_flag_DHCP--;
							continue;
						}
						if (soap->error == SOAP_TAG_MISMATCH)
							soap->error = soap_ignore_element(soap);
						if (soap->error == SOAP_NO_TAG)
							break;
						if (soap->error)
							return NULL;
		}
		if (a->Manual)
			soap_pop_block(soap, soap_blist_Manual);
		if (a->__sizeManual)
			a->Manual = (struct tt__PrefixedIPv6Address *)soap_save_block(soap, soap_blist_Manual, NULL, 1);
		else
		{	
			a->Manual = NULL;
			if (soap_blist_Manual)
				soap_end_block(soap, soap_blist_Manual);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__IPv6NetworkInterfaceSetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, 0, sizeof(struct tt__IPv6NetworkInterfaceSetConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const struct tt__IPv6NetworkInterfaceSetConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration);
	if (soap_out_tt__IPv6NetworkInterfaceSetConfiguration(soap, tag?tag:"tt:IPv6NetworkInterfaceSetConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv6NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_get_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv6NetworkInterfaceSetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot3Configuration(struct soap *soap, struct tt__Dot3Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot3Configuration(struct soap *soap, const struct tt__Dot3Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot3Configuration(struct soap *soap, const char *tag, int id, const struct tt__Dot3Configuration *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot3Configuration), type))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot3Configuration * SOAP_FMAC4 soap_in_tt__Dot3Configuration(struct soap *soap, const char *tag, struct tt__Dot3Configuration *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot3Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot3Configuration, sizeof(struct tt__Dot3Configuration), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__Dot3Configuration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
				soap_blist___any = soap_new_block(soap);
				a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
				if (a->__any == NULL)
					return NULL;
				*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
				a->__any = NULL;
				continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__Dot3Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot3Configuration, 0, sizeof(struct tt__Dot3Configuration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot3Configuration(struct soap *soap, const struct tt__Dot3Configuration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Dot3Configuration);
	if (soap_out_tt__Dot3Configuration(soap, tag?tag:"tt:Dot3Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot3Configuration * SOAP_FMAC4 soap_get_tt__Dot3Configuration(struct soap *soap, struct tt__Dot3Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot3Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11SSIDType(struct soap *soap, const char *tag, int id, const struct xsd__hexBinary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_tt__Dot11SSIDType);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_puthex(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xsd__hexBinary * SOAP_FMAC4 soap_in_tt__Dot11SSIDType(struct soap *soap, const char *tag, struct xsd__hexBinary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":hexBinary"))
	{	soap->error = SOAP_TYPE;
	return NULL;
	}
	a = (struct xsd__hexBinary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SSIDType, sizeof(struct xsd__hexBinary), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11SSIDType(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_gethex(soap, &a->__size);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xsd__hexBinary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11SSIDType, 0, sizeof(struct xsd__hexBinary), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11SSIDType(struct soap *soap, const struct xsd__hexBinary *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_tt__Dot11SSIDType);
	if (soap_out_tt__Dot11SSIDType(soap, tag?tag:"tt:Dot11SSIDType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xsd__hexBinary * SOAP_FMAC4 soap_get_tt__Dot11SSIDType(struct soap *soap, struct xsd__hexBinary *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11SSIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceConfigPriority(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_tt__NetworkInterfaceConfigPriority);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_tt__NetworkInterfaceConfigPriority(struct soap *soap, const char *tag, int *a, const char *type)
{	
	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_tt__NetworkInterfaceConfigPriority);
	if (p && *p < 0)
	{	
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	if (p && *p > 31)
	{	
		soap->error = SOAP_LENGTH;
		return NULL;
	}
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterfaceConfigPriority(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkInterfaceConfigPriority);
	if (soap_out_tt__NetworkInterfaceConfigPriority(soap, tag?tag:"tt:NetworkInterfaceConfigPriority", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_tt__NetworkInterfaceConfigPriority(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceConfigPriority(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11StationMode(struct soap *soap, enum tt__Dot11StationMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__Dot11StationMode
	*a = SOAP_DEFAULT_tt__Dot11StationMode;
#else
	*a = (enum tt__Dot11StationMode)0;
#endif
}

static const struct soap_code_map soap_codes_tt__Dot11StationMode[] =
{	{ (long)tt__Dot11StationMode__Ad_hoc, "Ad-hoc" },
{ (long)tt__Dot11StationMode__Infrastructure, "Infrastructure" },
{ (long)tt__Dot11StationMode__Extended, "Extended" },
{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Dot11StationMode2s(struct soap *soap, enum tt__Dot11StationMode n)
{	const char *s = soap_code_str(soap_codes_tt__Dot11StationMode, (long)n);
if (s)
return s;
return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11StationMode(struct soap *soap, const char *tag, int id, const enum tt__Dot11StationMode *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11StationMode), type) || soap_send(soap, soap_tt__Dot11StationMode2s(soap, *a)))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Dot11StationMode(struct soap *soap, const char *s, enum tt__Dot11StationMode *a)
{
	const struct soap_code_map *map;
	if (NULL==s)
	{
		return soap->error;
	}
	map = soap_code(soap_codes_tt__Dot11StationMode, s);
	if (map != NULL)
	{
		*a = (enum tt__Dot11StationMode)map->code;
	}
	else
	{
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
		{
			return soap->error = SOAP_TYPE;
		}
		*a = (enum tt__Dot11StationMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Dot11StationMode * SOAP_FMAC4 soap_in_tt__Dot11StationMode(struct soap *soap, const char *tag, enum tt__Dot11StationMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (enum tt__Dot11StationMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11StationMode, sizeof(enum tt__Dot11StationMode), 0, NULL, NULL, NULL);
	if (NULL==a)
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	
		if ((NULL==a) || soap_s2tt__Dot11StationMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (enum tt__Dot11StationMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11StationMode, 0, sizeof(enum tt__Dot11StationMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11StationMode(struct soap *soap, const enum tt__Dot11StationMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Dot11StationMode);
	if (soap_out_tt__Dot11StationMode(soap, tag?tag:"tt:Dot11StationMode", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Dot11StationMode * SOAP_FMAC4 soap_get_tt__Dot11StationMode(struct soap *soap, enum tt__Dot11StationMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11StationMode(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11Configuration(struct soap *soap, struct tt__Dot11Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Dot11SSIDType(soap, &a->SSID);
	soap_default_tt__Dot11StationMode(soap, &a->Mode);
	soap_default_tt__Name(soap, &a->Alias);
	soap_default_tt__NetworkInterfaceConfigPriority(soap, &a->Priority);
	a->Security = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11Configuration(struct soap *soap, const struct tt__Dot11Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__Dot11SSIDType(soap, &a->SSID);
	soap_serialize_tt__Name(soap, &a->Alias);
	soap_serialize_PointerTott__Dot11SecurityConfiguration(soap, &a->Security);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11Configuration(struct soap *soap, const char *tag, int id, const struct tt__Dot11Configuration *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11Configuration), type))
		return soap->error;
	if (soap_out_tt__Dot11SSIDType(soap, "tt:SSID", -1, &a->SSID, ""))
		return soap->error;
	if (soap_out_tt__Dot11StationMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (a->Alias)
	{	
		if (soap_out_tt__Name(soap, "tt:Alias", -1, &a->Alias, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Alias"))
		return soap->error;
	if (soap_out_tt__NetworkInterfaceConfigPriority(soap, "tt:Priority", -1, &a->Priority, ""))
		return soap->error;
	if (a->Security)
	{	
		if (soap_out_PointerTott__Dot11SecurityConfiguration(soap, "tt:Security", -1, &a->Security, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Security"))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot11Configuration * SOAP_FMAC4 soap_in_tt__Dot11Configuration(struct soap *soap, const char *tag, struct tt__Dot11Configuration *a, const char *type)
{
	size_t soap_flag_SSID = 1;
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Alias = 1;
	size_t soap_flag_Priority = 1;
	size_t soap_flag_Security = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot11Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11Configuration, sizeof(struct tt__Dot11Configuration), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__Dot11Configuration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SSID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__Dot11SSIDType(soap, "tt:SSID", &a->SSID, "tt:Dot11SSIDType"))
				{	
					soap_flag_SSID--;
					continue;
				}
				if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_tt__Dot11StationMode(soap, "tt:Mode", &a->Mode, "tt:Dot11StationMode"))
					{	
						soap_flag_Mode--;
						continue;
					}
					if (soap_flag_Alias && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
						if (soap_in_tt__Name(soap, "tt:Alias", &a->Alias, "tt:Name"))
						{	
							soap_flag_Alias--;
							continue;
						}
						if (soap_flag_Priority && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_tt__NetworkInterfaceConfigPriority(soap, "tt:Priority", &a->Priority, "tt:NetworkInterfaceConfigPriority"))
							{	
								soap_flag_Priority--;
								continue;
							}
							if (soap_flag_Security && soap->error == SOAP_TAG_MISMATCH)
								if (soap_in_PointerTott__Dot11SecurityConfiguration(soap, "tt:Security", &a->Security, "tt:Dot11SecurityConfiguration"))
								{	
									soap_flag_Security--;
									continue;
								}
								if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
								{	
									if (a->__any == NULL)
									{	
										if (soap_blist___any == NULL)
											soap_blist___any = soap_new_block(soap);
										a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
										if (a->__any == NULL)
											return NULL;
										*a->__any = NULL;
									}
									if (soap_inliteral(soap, "-any", a->__any))
									{	
										a->__size++;
										a->__any = NULL;
										continue;
									}
								}
								if (soap->error == SOAP_TAG_MISMATCH)
									soap->error = soap_ignore_element(soap);
								if (soap->error == SOAP_NO_TAG)
									break;
								if (soap->error)
									return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__Dot11Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11Configuration, 0, sizeof(struct tt__Dot11Configuration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SSID > 0 || soap_flag_Mode > 0 || soap_flag_Alias > 0 || soap_flag_Priority > 0 || soap_flag_Security > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11Configuration(struct soap *soap, const struct tt__Dot11Configuration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Dot11Configuration);
	if (soap_out_tt__Dot11Configuration(soap, tag?tag:"tt:Dot11Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11Configuration * SOAP_FMAC4 soap_get_tt__Dot11Configuration(struct soap *soap, struct tt__Dot11Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceExtension2(struct soap *soap, struct tt__NetworkInterfaceExtension2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceExtension2))
		soap_serialize_tt__NetworkInterfaceExtension2(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceExtension2(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceExtension2);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension2 ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceExtension2(struct soap *soap, const char *tag, struct tt__NetworkInterfaceExtension2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__NetworkInterfaceExtension2 **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__NetworkInterfaceExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceExtension2, sizeof(struct tt__NetworkInterfaceExtension2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceExtension2(struct soap *soap, struct tt__NetworkInterfaceExtension2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkInterfaceExtension2);
	if (soap_out_PointerTott__NetworkInterfaceExtension2(soap, tag?tag:"tt:NetworkInterfaceExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension2 ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceExtension2(struct soap *soap, struct tt__NetworkInterfaceExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IANA_IfTypes(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_tt__IANA_IfTypes);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_tt__IANA_IfTypes(struct soap *soap, const char *tag, int *a, const char *type)
{	
	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_tt__IANA_IfTypes);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IANA_IfTypes(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IANA_IfTypes);
	if (soap_out_tt__IANA_IfTypes(soap, tag?tag:"tt:IANA-IfTypes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_tt__IANA_IfTypes(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IANA_IfTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, struct tt__NetworkInterfaceConnectionSetting *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting))
		soap_serialize_tt__NetworkInterfaceConnectionSetting(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceConnectionSetting *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceConnectionSetting(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceConnectionSetting ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, struct tt__NetworkInterfaceConnectionSetting **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__NetworkInterfaceConnectionSetting **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceConnectionSetting *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceConnectionSetting(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__NetworkInterfaceConnectionSetting **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, sizeof(struct tt__NetworkInterfaceConnectionSetting), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, struct tt__NetworkInterfaceConnectionSetting *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkInterfaceConnectionSetting);
	if (soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, tag?tag:"tt:NetworkInterfaceConnectionSetting", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceConnectionSetting ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, struct tt__NetworkInterfaceConnectionSetting **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PrefixedIPv4Address(struct soap *soap, struct tt__PrefixedIPv4Address *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PrefixedIPv4Address))
		soap_serialize_tt__PrefixedIPv4Address(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PrefixedIPv4Address(struct soap *soap, const char *tag, int id, struct tt__PrefixedIPv4Address *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PrefixedIPv4Address);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PrefixedIPv4Address(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PrefixedIPv4Address ** SOAP_FMAC4 soap_in_PointerTott__PrefixedIPv4Address(struct soap *soap, const char *tag, struct tt__PrefixedIPv4Address **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__PrefixedIPv4Address **)soap_malloc(soap, sizeof(struct tt__PrefixedIPv4Address *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__PrefixedIPv4Address(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__PrefixedIPv4Address **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PrefixedIPv4Address, sizeof(struct tt__PrefixedIPv4Address), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PrefixedIPv4Address(struct soap *soap, struct tt__PrefixedIPv4Address *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PrefixedIPv4Address);
	if (soap_out_PointerTott__PrefixedIPv4Address(soap, tag?tag:"tt:PrefixedIPv4Address", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PrefixedIPv4Address ** SOAP_FMAC4 soap_get_PointerTott__PrefixedIPv4Address(struct soap *soap, struct tt__PrefixedIPv4Address **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PrefixedIPv4Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4Configuration(struct soap *soap, struct tt__IPv4Configuration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4Configuration))
		soap_serialize_tt__IPv4Configuration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4Configuration(struct soap *soap, const char *tag, int id, struct tt__IPv4Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4Configuration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv4Configuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPv4Configuration ** SOAP_FMAC4 soap_in_PointerTott__IPv4Configuration(struct soap *soap, const char *tag, struct tt__IPv4Configuration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__IPv4Configuration **)soap_malloc(soap, sizeof(struct tt__IPv4Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__IPv4Configuration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{
		a = (struct tt__IPv4Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4Configuration, sizeof(struct tt__IPv4Configuration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4Configuration(struct soap *soap, struct tt__IPv4Configuration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv4Configuration);
	if (soap_out_PointerTott__IPv4Configuration(soap, tag?tag:"tt:IPv4Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv4Configuration ** SOAP_FMAC4 soap_get_PointerTott__IPv4Configuration(struct soap *soap, struct tt__IPv4Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PrefixedIPv6Address(struct soap *soap, struct tt__PrefixedIPv6Address *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PrefixedIPv6Address))
		soap_serialize_tt__PrefixedIPv6Address(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PrefixedIPv6Address(struct soap *soap, const char *tag, int id, struct tt__PrefixedIPv6Address *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PrefixedIPv6Address);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PrefixedIPv6Address(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PrefixedIPv6Address ** SOAP_FMAC4 soap_in_PointerTott__PrefixedIPv6Address(struct soap *soap, const char *tag, struct tt__PrefixedIPv6Address **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__PrefixedIPv6Address **)soap_malloc(soap, sizeof(struct tt__PrefixedIPv6Address *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__PrefixedIPv6Address(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__PrefixedIPv6Address **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PrefixedIPv6Address, sizeof(struct tt__PrefixedIPv6Address), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PrefixedIPv6Address(struct soap *soap, struct tt__PrefixedIPv6Address *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PrefixedIPv6Address);
	if (soap_out_PointerTott__PrefixedIPv6Address(soap, tag?tag:"tt:PrefixedIPv6Address", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PrefixedIPv6Address ** SOAP_FMAC4 soap_get_PointerTott__PrefixedIPv6Address(struct soap *soap, struct tt__PrefixedIPv6Address **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PrefixedIPv6Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6Configuration(struct soap *soap, struct tt__IPv6Configuration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6Configuration))
		soap_serialize_tt__IPv6Configuration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6Configuration(struct soap *soap, const char *tag, int id, struct tt__IPv6Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6Configuration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv6Configuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPv6Configuration ** SOAP_FMAC4 soap_in_PointerTott__IPv6Configuration(struct soap *soap, const char *tag, struct tt__IPv6Configuration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__IPv6Configuration **)soap_malloc(soap, sizeof(struct tt__IPv6Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__IPv6Configuration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__IPv6Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6Configuration, sizeof(struct tt__IPv6Configuration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6Configuration(struct soap *soap, struct tt__IPv6Configuration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv6Configuration);
	if (soap_out_PointerTott__IPv6Configuration(soap, tag?tag:"tt:IPv6Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv6Configuration ** SOAP_FMAC4 soap_get_PointerTott__IPv6Configuration(struct soap *soap, struct tt__IPv6Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6DHCPConfiguration(struct soap *soap, enum tt__IPv6DHCPConfiguration *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_tt__IPv6DHCPConfiguration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6DHCPConfiguration(struct soap *soap, const char *tag, int id, enum tt__IPv6DHCPConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6DHCPConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv6DHCPConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__IPv6DHCPConfiguration ** SOAP_FMAC4 soap_in_PointerTott__IPv6DHCPConfiguration(struct soap *soap, const char *tag, enum tt__IPv6DHCPConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	return NULL;
	if (a == NULL)
		if (!(a = (enum tt__IPv6DHCPConfiguration **)soap_malloc(soap, sizeof(enum tt__IPv6DHCPConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__IPv6DHCPConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (enum tt__IPv6DHCPConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6DHCPConfiguration, sizeof(enum tt__IPv6DHCPConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6DHCPConfiguration(struct soap *soap, enum tt__IPv6DHCPConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv6DHCPConfiguration);
	if (soap_out_PointerTott__IPv6DHCPConfiguration(soap, tag?tag:"tt:IPv6DHCPConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IPv6DHCPConfiguration ** SOAP_FMAC4 soap_get_PointerTott__IPv6DHCPConfiguration(struct soap *soap, enum tt__IPv6DHCPConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6DHCPConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11SecurityConfiguration(struct soap *soap, struct tt__Dot11SecurityConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11SecurityConfiguration))
		soap_serialize_tt__Dot11SecurityConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11SecurityConfiguration(struct soap *soap, const char *tag, int id, struct tt__Dot11SecurityConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11SecurityConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11SecurityConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot11SecurityConfiguration ** SOAP_FMAC4 soap_in_PointerTott__Dot11SecurityConfiguration(struct soap *soap, const char *tag, struct tt__Dot11SecurityConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__Dot11SecurityConfiguration **)soap_malloc(soap, sizeof(struct tt__Dot11SecurityConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11SecurityConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__Dot11SecurityConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11SecurityConfiguration, sizeof(struct tt__Dot11SecurityConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11SecurityConfiguration(struct soap *soap, struct tt__Dot11SecurityConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Dot11SecurityConfiguration);
	if (soap_out_PointerTott__Dot11SecurityConfiguration(soap, tag?tag:"tt:Dot11SecurityConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11SecurityConfiguration ** SOAP_FMAC4 soap_get_PointerTott__Dot11SecurityConfiguration(struct soap *soap, struct tt__Dot11SecurityConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11SecurityConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkInterfaceExtension2(struct soap *soap, struct tt__NetworkInterfaceExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterfaceExtension2(struct soap *soap, const struct tt__NetworkInterfaceExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceExtension2(struct soap *soap, const char *tag, int id, const struct tt__NetworkInterfaceExtension2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceExtension2), type))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension2 * SOAP_FMAC4 soap_in_tt__NetworkInterfaceExtension2(struct soap *soap, const char *tag, struct tt__NetworkInterfaceExtension2 *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkInterfaceExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceExtension2, sizeof(struct tt__NetworkInterfaceExtension2), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__NetworkInterfaceExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__NetworkInterfaceExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceExtension2, 0, sizeof(struct tt__NetworkInterfaceExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterfaceExtension2(struct soap *soap, const struct tt__NetworkInterfaceExtension2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkInterfaceExtension2);
	if (soap_out_tt__NetworkInterfaceExtension2(soap, tag?tag:"tt:NetworkInterfaceExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension2 * SOAP_FMAC4 soap_get_tt__NetworkInterfaceExtension2(struct soap *soap, struct tt__NetworkInterfaceExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PrefixedIPv6Address(struct soap *soap, struct tt__PrefixedIPv6Address *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__IPv6Address(soap, &a->Address);
	soap_default_int(soap, &a->PrefixLength);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PrefixedIPv6Address(struct soap *soap, const struct tt__PrefixedIPv6Address *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__IPv6Address(soap, &a->Address);
	soap_embedded(soap, &a->PrefixLength, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PrefixedIPv6Address(struct soap *soap, const char *tag, int id, const struct tt__PrefixedIPv6Address *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PrefixedIPv6Address), type))
		return soap->error;
	if (a->Address)
	{	
		if (soap_out_tt__IPv6Address(soap, "tt:Address", -1, &a->Address, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Address"))
		return soap->error;
	if (soap_out_int(soap, "tt:PrefixLength", -1, &a->PrefixLength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PrefixedIPv6Address * SOAP_FMAC4 soap_in_tt__PrefixedIPv6Address(struct soap *soap, const char *tag, struct tt__PrefixedIPv6Address *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_PrefixLength = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PrefixedIPv6Address *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PrefixedIPv6Address, sizeof(struct tt__PrefixedIPv6Address), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__PrefixedIPv6Address(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__IPv6Address(soap, "tt:Address", &a->Address, "tt:IPv6Address"))
				{	
					soap_flag_Address--;
					continue;
				}
				if (soap_flag_PrefixLength && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_int(soap, "tt:PrefixLength", &a->PrefixLength, "xsd:int"))
					{	
						soap_flag_PrefixLength--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH)
						soap->error = soap_ignore_element(soap);
					if (soap->error == SOAP_NO_TAG)
						break;
					if (soap->error)
						return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__PrefixedIPv6Address *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PrefixedIPv6Address, 0, sizeof(struct tt__PrefixedIPv6Address), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0 || soap_flag_PrefixLength > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PrefixedIPv6Address(struct soap *soap, const struct tt__PrefixedIPv6Address *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PrefixedIPv6Address);
	if (soap_out_tt__PrefixedIPv6Address(soap, tag?tag:"tt:PrefixedIPv6Address", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PrefixedIPv6Address * SOAP_FMAC4 soap_get_tt__PrefixedIPv6Address(struct soap *soap, struct tt__PrefixedIPv6Address *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PrefixedIPv6Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PrefixedIPv4Address(struct soap *soap, struct tt__PrefixedIPv4Address *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__IPv4Address(soap, &a->Address);
	soap_default_int(soap, &a->PrefixLength);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PrefixedIPv4Address(struct soap *soap, const struct tt__PrefixedIPv4Address *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__IPv4Address(soap, &a->Address);
	soap_embedded(soap, &a->PrefixLength, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PrefixedIPv4Address(struct soap *soap, const char *tag, int id, const struct tt__PrefixedIPv4Address *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PrefixedIPv4Address), type))
		return soap->error;
	if (a->Address)
	{	
		if (soap_out_tt__IPv4Address(soap, "tt:Address", -1, &a->Address, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Address"))
		return soap->error;
	if (soap_out_int(soap, "tt:PrefixLength", -1, &a->PrefixLength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PrefixedIPv4Address * SOAP_FMAC4 soap_in_tt__PrefixedIPv4Address(struct soap *soap, const char *tag, struct tt__PrefixedIPv4Address *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_PrefixLength = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PrefixedIPv4Address *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PrefixedIPv4Address, sizeof(struct tt__PrefixedIPv4Address), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__PrefixedIPv4Address(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__IPv4Address(soap, "tt:Address", &a->Address, "tt:IPv4Address"))
				{	
					soap_flag_Address--;
					continue;
				}
				if (soap_flag_PrefixLength && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_int(soap, "tt:PrefixLength", &a->PrefixLength, "xsd:int"))
					{	
						soap_flag_PrefixLength--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH)
						soap->error = soap_ignore_element(soap);
					if (soap->error == SOAP_NO_TAG)
						break;
					if (soap->error)
						return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__PrefixedIPv4Address *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PrefixedIPv4Address, 0, sizeof(struct tt__PrefixedIPv4Address), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0 || soap_flag_PrefixLength > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PrefixedIPv4Address(struct soap *soap, const struct tt__PrefixedIPv4Address *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PrefixedIPv4Address);
	if (soap_out_tt__PrefixedIPv4Address(soap, tag?tag:"tt:PrefixedIPv4Address", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PrefixedIPv4Address * SOAP_FMAC4 soap_get_tt__PrefixedIPv4Address(struct soap *soap, struct tt__PrefixedIPv4Address *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PrefixedIPv4Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkInterfaceConnectionSetting(struct soap *soap, struct tt__NetworkInterfaceConnectionSetting *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->AutoNegotiation);
	soap_default_int(soap, &a->Speed);
	soap_default_tt__Duplex(soap, &a->Duplex);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterfaceConnectionSetting(struct soap *soap, const struct tt__NetworkInterfaceConnectionSetting *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->AutoNegotiation, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->Speed, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, int id, const struct tt__NetworkInterfaceConnectionSetting *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:AutoNegotiation", -1, &a->AutoNegotiation, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Speed", -1, &a->Speed, ""))
		return soap->error;
	if (soap_out_tt__Duplex(soap, "tt:Duplex", -1, &a->Duplex, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkInterfaceConnectionSetting * SOAP_FMAC4 soap_in_tt__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, struct tt__NetworkInterfaceConnectionSetting *a, const char *type)
{
	size_t soap_flag_AutoNegotiation = 1;
	size_t soap_flag_Speed = 1;
	size_t soap_flag_Duplex = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkInterfaceConnectionSetting *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, sizeof(struct tt__NetworkInterfaceConnectionSetting), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__NetworkInterfaceConnectionSetting(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AutoNegotiation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:AutoNegotiation", &a->AutoNegotiation, "xsd:boolean"))
				{	
					soap_flag_AutoNegotiation--;
					continue;
				}
				if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_int(soap, "tt:Speed", &a->Speed, "xsd:int"))
					{	
						soap_flag_Speed--;
						continue;
					}
					if (soap_flag_Duplex && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_tt__Duplex(soap, "tt:Duplex", &a->Duplex, "tt:Duplex"))
						{	
							soap_flag_Duplex--;
							continue;
						}
						if (soap->error == SOAP_TAG_MISMATCH)
							soap->error = soap_ignore_element(soap);
						if (soap->error == SOAP_NO_TAG)
							break;
						if (soap->error)
							return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__NetworkInterfaceConnectionSetting *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, 0, sizeof(struct tt__NetworkInterfaceConnectionSetting), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AutoNegotiation > 0 || soap_flag_Speed > 0 || soap_flag_Duplex > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterfaceConnectionSetting(struct soap *soap, const struct tt__NetworkInterfaceConnectionSetting *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting);
	if (soap_out_tt__NetworkInterfaceConnectionSetting(soap, tag?tag:"tt:NetworkInterfaceConnectionSetting", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceConnectionSetting * SOAP_FMAC4 soap_get_tt__NetworkInterfaceConnectionSetting(struct soap *soap, struct tt__NetworkInterfaceConnectionSetting *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceConnectionSetting(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPv4Configuration(struct soap *soap, struct tt__IPv4Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeManual = 0;
	a->Manual = NULL;
	a->LinkLocal = NULL;
	a->FromDHCP = NULL;
	soap_default_xsd__boolean_(soap, &a->DHCP);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPv4Configuration(struct soap *soap, const struct tt__IPv4Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Manual)
	{	int i;
	for (i = 0; i < a->__sizeManual; i++)
	{
		soap_embedded(soap, a->Manual + i, SOAP_TYPE_tt__PrefixedIPv4Address);
		soap_serialize_tt__PrefixedIPv4Address(soap, a->Manual + i);
	}
	}
	soap_serialize_PointerTott__PrefixedIPv4Address(soap, &a->LinkLocal);
	soap_serialize_PointerTott__PrefixedIPv4Address(soap, &a->FromDHCP);
	soap_embedded(soap, &a->DHCP, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv4Configuration(struct soap *soap, const char *tag, int id, const struct tt__IPv4Configuration *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv4Configuration), type))
		return soap->error;
	if (a->Manual)
	{	int i;
	for (i = 0; i < a->__sizeManual; i++)
		if (soap_out_tt__PrefixedIPv4Address(soap, "tt:Manual", -1, a->Manual + i, ""))
			return soap->error;
	}
	if (soap_out_PointerTott__PrefixedIPv4Address(soap, "tt:LinkLocal", -1, &a->LinkLocal, ""))
		return soap->error;
	if (soap_out_PointerTott__PrefixedIPv4Address(soap, "tt:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:DHCP", -1, &a->DHCP, ""))
		return soap->error;
	if (a->__any)
	{	int i;
	for (i = 0; i < a->__size; i++)
		soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPv4Configuration * SOAP_FMAC4 soap_in_tt__IPv4Configuration(struct soap *soap, const char *tag, struct tt__IPv4Configuration *a, const char *type)
{
	struct soap_blist *soap_blist_Manual = NULL;
	size_t soap_flag_LinkLocal = 1;
	size_t soap_flag_FromDHCP = 1;
	size_t soap_flag_DHCP = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IPv4Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv4Configuration, sizeof(struct tt__IPv4Configuration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IPv4Configuration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Manual", 1, NULL))
		{	if (a->Manual == NULL)
		{	if (soap_blist_Manual == NULL)
		soap_blist_Manual = soap_new_block(soap);
		a->Manual = (struct tt__PrefixedIPv4Address *)soap_push_block(soap, soap_blist_Manual, sizeof(struct tt__PrefixedIPv4Address));
		if (a->Manual == NULL)
			return NULL;
		soap_default_tt__PrefixedIPv4Address(soap, a->Manual);
		}
		soap_revert(soap);
		if (soap_in_tt__PrefixedIPv4Address(soap, "tt:Manual", a->Manual, "tt:PrefixedIPv4Address"))
		{	a->__sizeManual++;
		a->Manual = NULL;
		continue;
		}
		}
		if (soap_flag_LinkLocal && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTott__PrefixedIPv4Address(soap, "tt:LinkLocal", &a->LinkLocal, "tt:PrefixedIPv4Address"))
			{	soap_flag_LinkLocal--;
		continue;
		}
		if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTott__PrefixedIPv4Address(soap, "tt:FromDHCP", &a->FromDHCP, "tt:PrefixedIPv4Address"))
			{	soap_flag_FromDHCP--;
		continue;
		}
		if (soap_flag_DHCP && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_xsd__boolean_(soap, "tt:DHCP", &a->DHCP, "xsd:boolean"))
			{	soap_flag_DHCP--;
		continue;
		}
		if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
		{	if (a->__any == NULL)
		{	if (soap_blist___any == NULL)
		soap_blist___any = soap_new_block(soap);
		a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
		if (a->__any == NULL)
			return NULL;
		*a->__any = NULL;
		}
		if (soap_inliteral(soap, "-any", a->__any))
		{	a->__size++;
		a->__any = NULL;
		continue;
		}
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (a->Manual)
			soap_pop_block(soap, soap_blist_Manual);
		if (a->__sizeManual)
			a->Manual = (struct tt__PrefixedIPv4Address *)soap_save_block(soap, soap_blist_Manual, NULL, 1);
		else
		{	a->Manual = NULL;
		if (soap_blist_Manual)
			soap_end_block(soap, soap_blist_Manual);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
		if (soap_blist___any)
			soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IPv4Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv4Configuration, 0, sizeof(struct tt__IPv4Configuration), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DHCP > 0))
	{	soap->error = SOAP_OCCURS;
	return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv4Configuration(struct soap *soap, const struct tt__IPv4Configuration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPv4Configuration);
	if (soap_out_tt__IPv4Configuration(soap, tag?tag:"tt:IPv4Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv4Configuration * SOAP_FMAC4 soap_get_tt__IPv4Configuration(struct soap *soap, struct tt__IPv4Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPv6Configuration(struct soap *soap, struct tt__IPv6Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->AcceptRouterAdvert = NULL;
	soap_default_tt__IPv6DHCPConfiguration(soap, &a->DHCP);
	a->__sizeManual = 0;
	a->Manual = NULL;
	a->__sizeLinkLocal = 0;
	a->LinkLocal = NULL;
	a->__sizeFromDHCP = 0;
	a->FromDHCP = NULL;
	a->__sizeFromRA = 0;
	a->FromRA = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPv6Configuration(struct soap *soap, const struct tt__IPv6Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean_(soap, &a->AcceptRouterAdvert);
	soap_embedded(soap, &a->DHCP, SOAP_TYPE_tt__IPv6DHCPConfiguration);
	if (a->Manual)
	{	
		int i;
		for (i = 0; i < a->__sizeManual; i++)
		{
			soap_embedded(soap, a->Manual + i, SOAP_TYPE_tt__PrefixedIPv6Address);
			soap_serialize_tt__PrefixedIPv6Address(soap, a->Manual + i);
		}
	}
	if (a->LinkLocal)
	{	
		int i;
		for (i = 0; i < a->__sizeLinkLocal; i++)
		{
			soap_embedded(soap, a->LinkLocal + i, SOAP_TYPE_tt__PrefixedIPv6Address);
			soap_serialize_tt__PrefixedIPv6Address(soap, a->LinkLocal + i);
		}
	}
	if (a->FromDHCP)
	{	
		int i;
		for (i = 0; i < a->__sizeFromDHCP; i++)
		{
			soap_embedded(soap, a->FromDHCP + i, SOAP_TYPE_tt__PrefixedIPv6Address);
			soap_serialize_tt__PrefixedIPv6Address(soap, a->FromDHCP + i);
		}
	}
	if (a->FromRA)
	{	
		int i;
		for (i = 0; i < a->__sizeFromRA; i++)
		{
			soap_embedded(soap, a->FromRA + i, SOAP_TYPE_tt__PrefixedIPv6Address);
			soap_serialize_tt__PrefixedIPv6Address(soap, a->FromRA + i);
		}
	}
	soap_serialize_PointerTott__IPv6ConfigurationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6Configuration(struct soap *soap, const char *tag, int id, const struct tt__IPv6Configuration *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6Configuration), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:AcceptRouterAdvert", -1, &a->AcceptRouterAdvert, ""))
		return soap->error;
	if (soap_out_tt__IPv6DHCPConfiguration(soap, "tt:DHCP", -1, &a->DHCP, ""))
		return soap->error;
	if (a->Manual)
	{
		int i;
		for (i = 0; i < a->__sizeManual; i++)
			if (soap_out_tt__PrefixedIPv6Address(soap, "tt:Manual", -1, a->Manual + i, ""))
				return soap->error;
	}
	if (a->LinkLocal)
	{	
		int i;
		for (i = 0; i < a->__sizeLinkLocal; i++)
			if (soap_out_tt__PrefixedIPv6Address(soap, "tt:LinkLocal", -1, a->LinkLocal + i, ""))
				return soap->error;
	}
	if (a->FromDHCP)
	{	
		int i;
		for (i = 0; i < a->__sizeFromDHCP; i++)
			if (soap_out_tt__PrefixedIPv6Address(soap, "tt:FromDHCP", -1, a->FromDHCP + i, ""))
				return soap->error;
	}
	if (a->FromRA)
	{	
		int i;
		for (i = 0; i < a->__sizeFromRA; i++)
			if (soap_out_tt__PrefixedIPv6Address(soap, "tt:FromRA", -1, a->FromRA + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__IPv6ConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPv6Configuration * SOAP_FMAC4 soap_in_tt__IPv6Configuration(struct soap *soap, const char *tag, struct tt__IPv6Configuration *a, const char *type)
{
	size_t soap_flag_AcceptRouterAdvert = 1;
	size_t soap_flag_DHCP = 1;
	struct soap_blist *soap_blist_Manual = NULL;
	struct soap_blist *soap_blist_LinkLocal = NULL;
	struct soap_blist *soap_blist_FromDHCP = NULL;
	struct soap_blist *soap_blist_FromRA = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IPv6Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6Configuration, sizeof(struct tt__IPv6Configuration), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__IPv6Configuration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AcceptRouterAdvert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:AcceptRouterAdvert", &a->AcceptRouterAdvert, "xsd:boolean"))
				{	
					soap_flag_AcceptRouterAdvert--;
					continue;
				}
				if (soap_flag_DHCP && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_tt__IPv6DHCPConfiguration(soap, "tt:DHCP", &a->DHCP, "tt:IPv6DHCPConfiguration"))
					{	
						soap_flag_DHCP--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Manual", 1, NULL))
					{	
						if (a->Manual == NULL)
						{	
							if (soap_blist_Manual == NULL)
								soap_blist_Manual = soap_new_block(soap);
							a->Manual = (struct tt__PrefixedIPv6Address *)soap_push_block(soap, soap_blist_Manual, sizeof(struct tt__PrefixedIPv6Address));
							if (a->Manual == NULL)
								return NULL;
							soap_default_tt__PrefixedIPv6Address(soap, a->Manual);
						}
						soap_revert(soap);
						if (soap_in_tt__PrefixedIPv6Address(soap, "tt:Manual", a->Manual, "tt:PrefixedIPv6Address"))
						{	
							a->__sizeManual++;
							a->Manual = NULL;
							continue;
						}
					}
					if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:LinkLocal", 1, NULL))
					{	
						if (a->LinkLocal == NULL)
						{	
							if (soap_blist_LinkLocal == NULL)
								soap_blist_LinkLocal = soap_new_block(soap);
							a->LinkLocal = (struct tt__PrefixedIPv6Address *)soap_push_block(soap, soap_blist_LinkLocal, sizeof(struct tt__PrefixedIPv6Address));
							if (a->LinkLocal == NULL)
								return NULL;
							soap_default_tt__PrefixedIPv6Address(soap, a->LinkLocal);
						}
						soap_revert(soap);
						if (soap_in_tt__PrefixedIPv6Address(soap, "tt:LinkLocal", a->LinkLocal, "tt:PrefixedIPv6Address"))
						{	
							a->__sizeLinkLocal++;
							a->LinkLocal = NULL;
							continue;
						}
					}
					if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:FromDHCP", 1, NULL))
					{
						if (a->FromDHCP == NULL)
						{	
							if (soap_blist_FromDHCP == NULL)
								soap_blist_FromDHCP = soap_new_block(soap);
							a->FromDHCP = (struct tt__PrefixedIPv6Address *)soap_push_block(soap, soap_blist_FromDHCP, sizeof(struct tt__PrefixedIPv6Address));
							if (a->FromDHCP == NULL)
								return NULL;
							soap_default_tt__PrefixedIPv6Address(soap, a->FromDHCP);
						}
						soap_revert(soap);
						if (soap_in_tt__PrefixedIPv6Address(soap, "tt:FromDHCP", a->FromDHCP, "tt:PrefixedIPv6Address"))
						{	
							a->__sizeFromDHCP++;
							a->FromDHCP = NULL;
							continue;
						}
					}
					if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:FromRA", 1, NULL))
					{	
						if (a->FromRA == NULL)
						{	
							if (soap_blist_FromRA == NULL)
								soap_blist_FromRA = soap_new_block(soap);
							a->FromRA = (struct tt__PrefixedIPv6Address *)soap_push_block(soap, soap_blist_FromRA, sizeof(struct tt__PrefixedIPv6Address));
							if (a->FromRA == NULL)
								return NULL;
							soap_default_tt__PrefixedIPv6Address(soap, a->FromRA);
						}
						soap_revert(soap);
						if (soap_in_tt__PrefixedIPv6Address(soap, "tt:FromRA", a->FromRA, "tt:PrefixedIPv6Address"))
						{	
							a->__sizeFromRA++;
							a->FromRA = NULL;
							continue;
						}
					}
					if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTott__IPv6ConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:IPv6ConfigurationExtension"))
						{	
							soap_flag_Extension--;
							continue;
						}
						if (soap->error == SOAP_TAG_MISMATCH)
							soap->error = soap_ignore_element(soap);
						if (soap->error == SOAP_NO_TAG)
							break;
						if (soap->error)
							return NULL;
		}
		if (a->Manual)
			soap_pop_block(soap, soap_blist_Manual);
		if (a->__sizeManual)
			a->Manual = (struct tt__PrefixedIPv6Address *)soap_save_block(soap, soap_blist_Manual, NULL, 1);
		else
		{	
			a->Manual = NULL;
			if (soap_blist_Manual)
				soap_end_block(soap, soap_blist_Manual);
		}
		if (a->LinkLocal)
			soap_pop_block(soap, soap_blist_LinkLocal);
		if (a->__sizeLinkLocal)
			a->LinkLocal = (struct tt__PrefixedIPv6Address *)soap_save_block(soap, soap_blist_LinkLocal, NULL, 1);
		else
		{	
			a->LinkLocal = NULL;
			if (soap_blist_LinkLocal)
				soap_end_block(soap, soap_blist_LinkLocal);
		}
		if (a->FromDHCP)
			soap_pop_block(soap, soap_blist_FromDHCP);
		if (a->__sizeFromDHCP)
			a->FromDHCP = (struct tt__PrefixedIPv6Address *)soap_save_block(soap, soap_blist_FromDHCP, NULL, 1);
		else
		{	
			a->FromDHCP = NULL;
			if (soap_blist_FromDHCP)
				soap_end_block(soap, soap_blist_FromDHCP);
		}
		if (a->FromRA)
			soap_pop_block(soap, soap_blist_FromRA);
		if (a->__sizeFromRA)
			a->FromRA = (struct tt__PrefixedIPv6Address *)soap_save_block(soap, soap_blist_FromRA, NULL, 1);
		else
		{	
			a->FromRA = NULL;
			if (soap_blist_FromRA)
				soap_end_block(soap, soap_blist_FromRA);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__IPv6Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6Configuration, 0, sizeof(struct tt__IPv6Configuration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DHCP > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv6Configuration(struct soap *soap, const struct tt__IPv6Configuration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPv6Configuration);
	if (soap_out_tt__IPv6Configuration(soap, tag?tag:"tt:IPv6Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv6Configuration * SOAP_FMAC4 soap_get_tt__IPv6Configuration(struct soap *soap, struct tt__IPv6Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPv6DHCPConfiguration(struct soap *soap, enum tt__IPv6DHCPConfiguration *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__IPv6DHCPConfiguration
	*a = SOAP_DEFAULT_tt__IPv6DHCPConfiguration;
#else
	*a = (enum tt__IPv6DHCPConfiguration)0;
#endif
}

static const struct soap_code_map soap_codes_tt__IPv6DHCPConfiguration[] =
{	
	{ (long)tt__IPv6DHCPConfiguration__Auto, "Auto" },
	{ (long)tt__IPv6DHCPConfiguration__Stateful, "Stateful" },
	{ (long)tt__IPv6DHCPConfiguration__Stateless, "Stateless" },
	{ (long)tt__IPv6DHCPConfiguration__Off, "Off" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__IPv6DHCPConfiguration2s(struct soap *soap, enum tt__IPv6DHCPConfiguration n)
{	
	const char *s = soap_code_str(soap_codes_tt__IPv6DHCPConfiguration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6DHCPConfiguration(struct soap *soap, const char *tag, int id, const enum tt__IPv6DHCPConfiguration *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6DHCPConfiguration), type) || soap_send(soap, soap_tt__IPv6DHCPConfiguration2s(soap, *a)))
	return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__IPv6DHCPConfiguration(struct soap *soap, const char *s, enum tt__IPv6DHCPConfiguration *a)
{
	const struct soap_code_map *map;
	if (s == NULL)
		return soap->error;
	map = soap_code(soap_codes_tt__IPv6DHCPConfiguration, s);
	if (map)
		*a = (enum tt__IPv6DHCPConfiguration)map->code;
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__IPv6DHCPConfiguration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__IPv6DHCPConfiguration * SOAP_FMAC4 soap_in_tt__IPv6DHCPConfiguration(struct soap *soap, const char *tag, enum tt__IPv6DHCPConfiguration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	return NULL;
	a = (enum tt__IPv6DHCPConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6DHCPConfiguration, sizeof(enum tt__IPv6DHCPConfiguration), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	if (soap->body && !*soap->href)
	{	
		if (!a || soap_s2tt__IPv6DHCPConfiguration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (enum tt__IPv6DHCPConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6DHCPConfiguration, 0, sizeof(enum tt__IPv6DHCPConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv6DHCPConfiguration(struct soap *soap, const enum tt__IPv6DHCPConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPv6DHCPConfiguration);
	if (soap_out_tt__IPv6DHCPConfiguration(soap, tag?tag:"tt:IPv6DHCPConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IPv6DHCPConfiguration * SOAP_FMAC4 soap_get_tt__IPv6DHCPConfiguration(struct soap *soap, enum tt__IPv6DHCPConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6DHCPConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11SecurityConfiguration(struct soap *soap, struct tt__Dot11SecurityConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Dot11SecurityMode(soap, &a->Mode);
	a->Algorithm = NULL;
	a->PSK = NULL;
	soap_default_tt__ReferenceToken(soap, &a->Dot1X);
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11SecurityConfiguration(struct soap *soap, const struct tt__Dot11SecurityConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Dot11Cipher(soap, &a->Algorithm);
	soap_serialize_PointerTott__Dot11PSKSet(soap, &a->PSK);
	soap_serialize_tt__ReferenceToken(soap, &a->Dot1X);
	soap_serialize_PointerTott__Dot11SecurityConfigurationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11SecurityConfiguration(struct soap *soap, const char *tag, int id, const struct tt__Dot11SecurityConfiguration *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11SecurityConfiguration), type))
		return soap->error;
	if (soap_out_tt__Dot11SecurityMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11Cipher(soap, "tt:Algorithm", -1, &a->Algorithm, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11PSKSet(soap, "tt:PSK", -1, &a->PSK, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:Dot1X", -1, &a->Dot1X, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11SecurityConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot11SecurityConfiguration * SOAP_FMAC4 soap_in_tt__Dot11SecurityConfiguration(struct soap *soap, const char *tag, struct tt__Dot11SecurityConfiguration *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Algorithm = 1;
	size_t soap_flag_PSK = 1;
	size_t soap_flag_Dot1X = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot11SecurityConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SecurityConfiguration, sizeof(struct tt__Dot11SecurityConfiguration), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__Dot11SecurityConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__Dot11SecurityMode(soap, "tt:Mode", &a->Mode, "tt:Dot11SecurityMode"))
				{	
					soap_flag_Mode--;
					continue;
				}
				if (soap_flag_Algorithm && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__Dot11Cipher(soap, "tt:Algorithm", &a->Algorithm, "tt:Dot11Cipher"))
					{	
						soap_flag_Algorithm--;
						continue;
					}
					if (soap_flag_PSK && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTott__Dot11PSKSet(soap, "tt:PSK", &a->PSK, "tt:Dot11PSKSet"))
						{	
							soap_flag_PSK--;
							continue;
						}
						if (soap_flag_Dot1X && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
							if (soap_in_tt__ReferenceToken(soap, "tt:Dot1X", &a->Dot1X, "tt:ReferenceToken"))
							{	
								soap_flag_Dot1X--;
								continue;
							}
							if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
								if (soap_in_PointerTott__Dot11SecurityConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:Dot11SecurityConfigurationExtension"))
								{	
									soap_flag_Extension--;
									continue;
								}
								if (soap->error == SOAP_TAG_MISMATCH)
									soap->error = soap_ignore_element(soap);
								if (soap->error == SOAP_NO_TAG)
									break;
								if (soap->error)
									return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__Dot11SecurityConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11SecurityConfiguration, 0, sizeof(struct tt__Dot11SecurityConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11SecurityConfiguration(struct soap *soap, const struct tt__Dot11SecurityConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Dot11SecurityConfiguration);
	if (soap_out_tt__Dot11SecurityConfiguration(soap, tag?tag:"tt:Dot11SecurityConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11SecurityConfiguration * SOAP_FMAC4 soap_get_tt__Dot11SecurityConfiguration(struct soap *soap, struct tt__Dot11SecurityConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11SecurityConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11SecurityConfigurationExtension(struct soap *soap, struct tt__Dot11SecurityConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11SecurityConfigurationExtension(struct soap *soap, const struct tt__Dot11SecurityConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11SecurityConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__Dot11SecurityConfigurationExtension *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension), type))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot11SecurityConfigurationExtension * SOAP_FMAC4 soap_in_tt__Dot11SecurityConfigurationExtension(struct soap *soap, const char *tag, struct tt__Dot11SecurityConfigurationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot11SecurityConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, sizeof(struct tt__Dot11SecurityConfigurationExtension), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__Dot11SecurityConfigurationExtension(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__Dot11SecurityConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, 0, sizeof(struct tt__Dot11SecurityConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11SecurityConfigurationExtension(struct soap *soap, const struct tt__Dot11SecurityConfigurationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension);
	if (soap_out_tt__Dot11SecurityConfigurationExtension(soap, tag?tag:"tt:Dot11SecurityConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11SecurityConfigurationExtension * SOAP_FMAC4 soap_get_tt__Dot11SecurityConfigurationExtension(struct soap *soap, struct tt__Dot11SecurityConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11SecurityConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Duplex(struct soap *soap, enum tt__Duplex *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__Duplex
	*a = SOAP_DEFAULT_tt__Duplex;
#else
	*a = (enum tt__Duplex)0;
#endif
}

static const struct soap_code_map soap_codes_tt__Duplex[] =
{	
	{ (long)tt__Duplex__Full, "Full" },
	{ (long)tt__Duplex__Half, "Half" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Duplex2s(struct soap *soap, enum tt__Duplex n)
{	
	const char *s = soap_code_str(soap_codes_tt__Duplex, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Duplex(struct soap *soap, const char *tag, int id, const enum tt__Duplex *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Duplex), type) || soap_send(soap, soap_tt__Duplex2s(soap, *a)))
	return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Duplex(struct soap *soap, const char *s, enum tt__Duplex *a)
{
	const struct soap_code_map *map;
	if (s == NULL)
		return soap->error;
	map = soap_code(soap_codes_tt__Duplex, s);
	if (map)
		*a = (enum tt__Duplex)map->code;
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Duplex)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Duplex * SOAP_FMAC4 soap_in_tt__Duplex(struct soap *soap, const char *tag, enum tt__Duplex *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	return NULL;
	a = (enum tt__Duplex *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Duplex, sizeof(enum tt__Duplex), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	if (soap->body && !*soap->href)
	{	
		if (!a || soap_s2tt__Duplex(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (enum tt__Duplex *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Duplex, 0, sizeof(enum tt__Duplex), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Duplex(struct soap *soap, const enum tt__Duplex *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Duplex);
	if (soap_out_tt__Duplex(soap, tag?tag:"tt:Duplex", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Duplex * SOAP_FMAC4 soap_get_tt__Duplex(struct soap *soap, enum tt__Duplex *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Duplex(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6ConfigurationExtension(struct soap *soap, struct tt__IPv6ConfigurationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6ConfigurationExtension))
		soap_serialize_tt__IPv6ConfigurationExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6ConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__IPv6ConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6ConfigurationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv6ConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPv6ConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__IPv6ConfigurationExtension(struct soap *soap, const char *tag, struct tt__IPv6ConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__IPv6ConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__IPv6ConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__IPv6ConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__IPv6ConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6ConfigurationExtension, sizeof(struct tt__IPv6ConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6ConfigurationExtension(struct soap *soap, struct tt__IPv6ConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv6ConfigurationExtension);
	if (soap_out_PointerTott__IPv6ConfigurationExtension(soap, tag?tag:"tt:IPv6ConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv6ConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__IPv6ConfigurationExtension(struct soap *soap, struct tt__IPv6ConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6ConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11SecurityMode(struct soap *soap, enum tt__Dot11SecurityMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__Dot11SecurityMode
	*a = SOAP_DEFAULT_tt__Dot11SecurityMode;
#else
	*a = (enum tt__Dot11SecurityMode)0;
#endif
}

static const struct soap_code_map soap_codes_tt__Dot11SecurityMode[] =
{	
	{ (long)tt__Dot11SecurityMode__None, "None" },
	{ (long)tt__Dot11SecurityMode__WEP, "WEP" },
	{ (long)tt__Dot11SecurityMode__PSK, "PSK" },
	{ (long)tt__Dot11SecurityMode__Dot1X, "Dot1X" },
	{ (long)tt__Dot11SecurityMode__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Dot11SecurityMode2s(struct soap *soap, enum tt__Dot11SecurityMode n)
{	
	const char *s = soap_code_str(soap_codes_tt__Dot11SecurityMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11SecurityMode(struct soap *soap, const char *tag, int id, const enum tt__Dot11SecurityMode *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11SecurityMode), type) || soap_send(soap, soap_tt__Dot11SecurityMode2s(soap, *a)))
	return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Dot11SecurityMode(struct soap *soap, const char *s, enum tt__Dot11SecurityMode *a)
{
	const struct soap_code_map *map;
	if (s == NULL)
		return soap->error;
	map = soap_code(soap_codes_tt__Dot11SecurityMode, s);
	if (map)
		*a = (enum tt__Dot11SecurityMode)map->code;
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Dot11SecurityMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Dot11SecurityMode * SOAP_FMAC4 soap_in_tt__Dot11SecurityMode(struct soap *soap, const char *tag, enum tt__Dot11SecurityMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	return NULL;
	a = (enum tt__Dot11SecurityMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SecurityMode, sizeof(enum tt__Dot11SecurityMode), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	if (soap->body && !*soap->href)
	{	
		if (!a || soap_s2tt__Dot11SecurityMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (enum tt__Dot11SecurityMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11SecurityMode, 0, sizeof(enum tt__Dot11SecurityMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11SecurityMode(struct soap *soap, const enum tt__Dot11SecurityMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Dot11SecurityMode);
	if (soap_out_tt__Dot11SecurityMode(soap, tag?tag:"tt:Dot11SecurityMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Dot11SecurityMode * SOAP_FMAC4 soap_get_tt__Dot11SecurityMode(struct soap *soap, enum tt__Dot11SecurityMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11SecurityMode(soap, tag, p, type)) !=NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11PSK(struct soap *soap, const char *tag, int id, const struct xsd__hexBinary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_tt__Dot11PSK);
	if (id < 0)
	{
		return soap->error;
	}
	if (soap_element_begin_out(soap, tag, id, type))
	{
		return soap->error;
	}
	if (soap_puthex(soap, a->__ptr, a->__size))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xsd__hexBinary * SOAP_FMAC4 soap_in_tt__Dot11PSK(struct soap *soap, const char *tag, struct xsd__hexBinary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":hexBinary"))
	{	
		soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd__hexBinary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11PSK, sizeof(struct xsd__hexBinary), 0, NULL, NULL, NULL);
	if (NULL==a)
	{
		return NULL;
	}
	soap_default_tt__Dot11PSK(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_gethex(soap, &a->__size);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct xsd__hexBinary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11PSK, 0, sizeof(struct xsd__hexBinary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11PSK(struct soap *soap, const struct xsd__hexBinary *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_tt__Dot11PSK);
	if (soap_out_tt__Dot11PSK(soap, tag?tag:"tt:Dot11PSK", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xsd__hexBinary * SOAP_FMAC4 soap_get_tt__Dot11PSK(struct soap *soap, struct xsd__hexBinary *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11PSK(soap, tag, p, type)) !=NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11PSKSet(struct soap *soap, struct tt__Dot11PSKSet *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11PSKSet))
		soap_serialize_tt__Dot11PSKSet(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11PSKSet(struct soap *soap, const char *tag, int id, struct tt__Dot11PSKSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11PSKSet);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11PSKSet(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot11PSKSet ** SOAP_FMAC4 soap_in_PointerTott__Dot11PSKSet(struct soap *soap, const char *tag, struct tt__Dot11PSKSet **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__Dot11PSKSet **)soap_malloc(soap, sizeof(struct tt__Dot11PSKSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11PSKSet(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__Dot11PSKSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11PSKSet, sizeof(struct tt__Dot11PSKSet), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11PSKSet(struct soap *soap, struct tt__Dot11PSKSet *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Dot11PSKSet);
	if (soap_out_PointerTott__Dot11PSKSet(soap, tag?tag:"tt:Dot11PSKSet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11PSKSet ** SOAP_FMAC4 soap_get_PointerTott__Dot11PSKSet(struct soap *soap, struct tt__Dot11PSKSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11PSKSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11Cipher(struct soap *soap, enum tt__Dot11Cipher *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_tt__Dot11Cipher);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11Cipher(struct soap *soap, const char *tag, int id, enum tt__Dot11Cipher *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11Cipher);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11Cipher(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__Dot11Cipher ** SOAP_FMAC4 soap_in_PointerTott__Dot11Cipher(struct soap *soap, const char *tag, enum tt__Dot11Cipher **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	return NULL;
	if (a == NULL)
		if (!(a = (enum tt__Dot11Cipher **)soap_malloc(soap, sizeof(enum tt__Dot11Cipher *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11Cipher(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (enum tt__Dot11Cipher **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11Cipher, sizeof(enum tt__Dot11Cipher), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11Cipher(struct soap *soap, enum tt__Dot11Cipher *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Dot11Cipher);
	if (soap_out_PointerTott__Dot11Cipher(soap, tag?tag:"tt:Dot11Cipher", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Dot11Cipher ** SOAP_FMAC4 soap_get_PointerTott__Dot11Cipher(struct soap *soap, enum tt__Dot11Cipher **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11Cipher(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11SecurityConfigurationExtension(struct soap *soap, struct tt__Dot11SecurityConfigurationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension))
		soap_serialize_tt__Dot11SecurityConfigurationExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11SecurityConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__Dot11SecurityConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11SecurityConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot11SecurityConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__Dot11SecurityConfigurationExtension(struct soap *soap, const char *tag, struct tt__Dot11SecurityConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot11SecurityConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__Dot11SecurityConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_tt__Dot11SecurityConfigurationExtension(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	
		a = (struct tt__Dot11SecurityConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, sizeof(struct tt__Dot11SecurityConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11SecurityConfigurationExtension(struct soap *soap, struct tt__Dot11SecurityConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Dot11SecurityConfigurationExtension);
	if (soap_out_PointerTott__Dot11SecurityConfigurationExtension(soap, tag?tag:"tt:Dot11SecurityConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11SecurityConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__Dot11SecurityConfigurationExtension(struct soap *soap, struct tt__Dot11SecurityConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11SecurityConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPv6ConfigurationExtension(struct soap *soap, struct tt__IPv6ConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPv6ConfigurationExtension(struct soap *soap, const struct tt__IPv6ConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6ConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__IPv6ConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6ConfigurationExtension), type))
		return soap->error;
	if (a->__any)
	{
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPv6ConfigurationExtension * SOAP_FMAC4 soap_in_tt__IPv6ConfigurationExtension(struct soap *soap, const char *tag, struct tt__IPv6ConfigurationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IPv6ConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6ConfigurationExtension, sizeof(struct tt__IPv6ConfigurationExtension), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__IPv6ConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}	
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__IPv6ConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6ConfigurationExtension, 0, sizeof(struct tt__IPv6ConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv6ConfigurationExtension(struct soap *soap, const struct tt__IPv6ConfigurationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPv6ConfigurationExtension);
	if (soap_out_tt__IPv6ConfigurationExtension(soap, tag?tag:"tt:IPv6ConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv6ConfigurationExtension * SOAP_FMAC4 soap_get_tt__IPv6ConfigurationExtension(struct soap *soap, struct tt__IPv6ConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6ConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11PSKSetExtension(struct soap *soap, struct tt__Dot11PSKSetExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11PSKSetExtension(struct soap *soap, const struct tt__Dot11PSKSetExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11PSKSetExtension(struct soap *soap, const char *tag, int id, const struct tt__Dot11PSKSetExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11PSKSetExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
	for (i = 0; i < a->__size; i++)
		soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot11PSKSetExtension * SOAP_FMAC4 soap_in_tt__Dot11PSKSetExtension(struct soap *soap, const char *tag, struct tt__Dot11PSKSetExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot11PSKSetExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11PSKSetExtension, sizeof(struct tt__Dot11PSKSetExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11PSKSetExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
		{	if (a->__any == NULL)
		{	if (soap_blist___any == NULL)
		soap_blist___any = soap_new_block(soap);
		a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
		if (a->__any == NULL)
			return NULL;
		*a->__any = NULL;
		}
		if (soap_inliteral(soap, "-any", a->__any))
		{	a->__size++;
		a->__any = NULL;
		continue;
		}
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
		if (soap_blist___any)
			soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11PSKSetExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11PSKSetExtension, 0, sizeof(struct tt__Dot11PSKSetExtension), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11PSKSetExtension(struct soap *soap, const struct tt__Dot11PSKSetExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Dot11PSKSetExtension);
	if (soap_out_tt__Dot11PSKSetExtension(soap, tag?tag:"tt:Dot11PSKSetExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11PSKSetExtension * SOAP_FMAC4 soap_get_tt__Dot11PSKSetExtension(struct soap *soap, struct tt__Dot11PSKSetExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11PSKSetExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11PSKPassphrase(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__Dot11PSKPassphrase);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__Dot11PSKPassphrase(struct soap *soap, const char *tag, char **a, const char *type)
{	
	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__Dot11PSKPassphrase, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11PSKPassphrase(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Dot11PSKPassphrase);
	if (soap_out_tt__Dot11PSKPassphrase(soap, tag?tag:"byte", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__Dot11PSKPassphrase(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11PSKPassphrase(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11PSKSet(struct soap *soap, struct tt__Dot11PSKSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Key = NULL;
	soap_default_tt__Dot11PSKPassphrase(soap, &a->Passphrase);
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11PSKSet(struct soap *soap, const struct tt__Dot11PSKSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Dot11PSK(soap, &a->Key);
	soap_serialize_tt__Dot11PSKPassphrase(soap, &a->Passphrase);
	soap_serialize_PointerTott__Dot11PSKSetExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11PSKSet(struct soap *soap, const char *tag, int id, const struct tt__Dot11PSKSet *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11PSKSet), type))
		return soap->error;
	if (soap_out_PointerTott__Dot11PSK(soap, "tt:Key", -1, &a->Key, ""))
		return soap->error;
	if (soap_out_tt__Dot11PSKPassphrase(soap, "tt:Passphrase", -1, &a->Passphrase, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11PSKSetExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot11PSKSet * SOAP_FMAC4 soap_in_tt__Dot11PSKSet(struct soap *soap, const char *tag, struct tt__Dot11PSKSet *a, const char *type)
{
	size_t soap_flag_Key = 1;
	size_t soap_flag_Passphrase = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot11PSKSet *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11PSKSet, sizeof(struct tt__Dot11PSKSet), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11PSKSet(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Key && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11PSK(soap, "tt:Key", &a->Key, "tt:Dot11PSK"))
				{	
					soap_flag_Key--;
					continue;
				}
				if (soap_flag_Passphrase && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
					if (soap_in_tt__Dot11PSKPassphrase(soap, "tt:Passphrase", &a->Passphrase, "tt:Dot11PSKPassphrase"))
					{	
						soap_flag_Passphrase--;
						continue;
					}
					if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTott__Dot11PSKSetExtension(soap, "tt:Extension", &a->Extension, "tt:Dot11PSKSetExtension"))
						{	
							soap_flag_Extension--;
							continue;
						}
						if (soap->error == SOAP_TAG_MISMATCH)
							soap->error = soap_ignore_element(soap);
						if (soap->error == SOAP_NO_TAG)
							break;
						if (soap->error)
							return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__Dot11PSKSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11PSKSet, 0, sizeof(struct tt__Dot11PSKSet), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11PSKSet(struct soap *soap, const struct tt__Dot11PSKSet *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Dot11PSKSet);
	if (soap_out_tt__Dot11PSKSet(soap, tag?tag:"tt:Dot11PSKSet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11PSKSet * SOAP_FMAC4 soap_get_tt__Dot11PSKSet(struct soap *soap, struct tt__Dot11PSKSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11PSKSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11Cipher(struct soap *soap, enum tt__Dot11Cipher *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__Dot11Cipher
	*a = SOAP_DEFAULT_tt__Dot11Cipher;
#else
	*a = (enum tt__Dot11Cipher)0;
#endif
}

static const struct soap_code_map soap_codes_tt__Dot11Cipher[] =
{	
	{ (long)tt__Dot11Cipher__CCMP, "CCMP" },
	{ (long)tt__Dot11Cipher__TKIP, "TKIP" },
	{ (long)tt__Dot11Cipher__Any, "Any" },
	{ (long)tt__Dot11Cipher__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Dot11Cipher2s(struct soap *soap, enum tt__Dot11Cipher n)
{	
	const char *s = soap_code_str(soap_codes_tt__Dot11Cipher, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11Cipher(struct soap *soap, const char *tag, int id, const enum tt__Dot11Cipher *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11Cipher), type) || soap_send(soap, soap_tt__Dot11Cipher2s(soap, *a)))
	return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Dot11Cipher(struct soap *soap, const char *s, enum tt__Dot11Cipher *a)
{
	const struct soap_code_map *map;
	if (s == NULL)
		return soap->error;
	map = soap_code(soap_codes_tt__Dot11Cipher, s);
	if (map)
		*a = (enum tt__Dot11Cipher)map->code;
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Dot11Cipher)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Dot11Cipher * SOAP_FMAC4 soap_in_tt__Dot11Cipher(struct soap *soap, const char *tag, enum tt__Dot11Cipher *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	return NULL;
	a = (enum tt__Dot11Cipher *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11Cipher, sizeof(enum tt__Dot11Cipher), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	if (soap->body && !*soap->href)
	{	
		if (!a || soap_s2tt__Dot11Cipher(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{
		a = (enum tt__Dot11Cipher *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11Cipher, 0, sizeof(enum tt__Dot11Cipher), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11Cipher(struct soap *soap, const enum tt__Dot11Cipher *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Dot11Cipher);
	if (soap_out_tt__Dot11Cipher(soap, tag?tag:"tt:Dot11Cipher", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Dot11Cipher * SOAP_FMAC4 soap_get_tt__Dot11Cipher(struct soap *soap, enum tt__Dot11Cipher *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11Cipher(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11PSKSetExtension(struct soap *soap, struct tt__Dot11PSKSetExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11PSKSetExtension))
		soap_serialize_tt__Dot11PSKSetExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11PSKSetExtension(struct soap *soap, const char *tag, int id, struct tt__Dot11PSKSetExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11PSKSetExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11PSKSetExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot11PSKSetExtension ** SOAP_FMAC4 soap_in_PointerTott__Dot11PSKSetExtension(struct soap *soap, const char *tag, struct tt__Dot11PSKSetExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot11PSKSetExtension **)soap_malloc(soap, sizeof(struct tt__Dot11PSKSetExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_tt__Dot11PSKSetExtension(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct tt__Dot11PSKSetExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11PSKSetExtension, sizeof(struct tt__Dot11PSKSetExtension), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11PSKSetExtension(struct soap *soap, struct tt__Dot11PSKSetExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Dot11PSKSetExtension);
	if (soap_out_PointerTott__Dot11PSKSetExtension(soap, tag?tag:"tt:Dot11PSKSetExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11PSKSetExtension ** SOAP_FMAC4 soap_get_PointerTott__Dot11PSKSetExtension(struct soap *soap, struct tt__Dot11PSKSetExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11PSKSetExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11PSK(struct soap *soap, struct xsd__hexBinary *const*a)
{
	if (*a)
		soap_serialize_tt__Dot11PSK(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11PSK(struct soap *soap, const char *tag, int id, struct xsd__hexBinary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_tt__Dot11PSK);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11PSK(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xsd__hexBinary ** SOAP_FMAC4 soap_in_PointerTott__Dot11PSK(struct soap *soap, const char *tag, struct xsd__hexBinary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xsd__hexBinary **)soap_malloc(soap, sizeof(struct xsd__hexBinary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in_tt__Dot11PSK(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct xsd__hexBinary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11PSK, sizeof(struct xsd__hexBinary), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11PSK(struct soap *soap, struct xsd__hexBinary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Dot11PSK);
	if (soap_out_PointerTott__Dot11PSK(soap, tag?tag:"tt:Dot11PSK", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xsd__hexBinary ** SOAP_FMAC4 soap_get_PointerTott__Dot11PSK(struct soap *soap, struct xsd__hexBinary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11PSK(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetNetworkInterfaces(struct soap *soap, struct __tds__SetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetNetworkInterfaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetNetworkInterfaces(struct soap *soap, const struct __tds__SetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetNetworkInterfaces(soap, &a->tds__SetNetworkInterfaces);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetNetworkInterfaces(struct soap *soap, const char *tag, int id, const struct __tds__SetNetworkInterfaces *a, const char *type)
{
	if (soap_out_PointerTo_tds__SetNetworkInterfaces(soap, "tds:SetNetworkInterfaces", -1, &a->tds__SetNetworkInterfaces, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkInterfaces * SOAP_FMAC4 soap_in___tds__SetNetworkInterfaces(struct soap *soap, const char *tag, struct __tds__SetNetworkInterfaces *a, const char *type)
{
	size_t soap_flag_tds__SetNetworkInterfaces = 1;
	short soap_flag;
	a = (struct __tds__SetNetworkInterfaces *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetNetworkInterfaces, sizeof(struct __tds__SetNetworkInterfaces), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___tds__SetNetworkInterfaces(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__SetNetworkInterfaces && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__SetNetworkInterfaces(soap, "tds:SetNetworkInterfaces", &a->tds__SetNetworkInterfaces, ""))
			{	
				soap_flag_tds__SetNetworkInterfaces--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetNetworkInterfaces(struct soap *soap, const struct __tds__SetNetworkInterfaces *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetNetworkInterfaces(soap, tag?tag:"-tds:SetNetworkInterfaces", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkInterfaces * SOAP_FMAC4 soap_get___tds__SetNetworkInterfaces(struct soap *soap, struct __tds__SetNetworkInterfaces *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkInterfacesResponse(struct soap *soap, struct _tds__SetNetworkInterfacesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkInterfacesResponse))
		soap_serialize__tds__SetNetworkInterfacesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkInterfacesResponse(struct soap *soap, const char *tag, int id, struct _tds__SetNetworkInterfacesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkInterfacesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetNetworkInterfacesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetNetworkInterfacesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkInterfacesResponse(struct soap *soap, const char *tag, struct _tds__SetNetworkInterfacesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__SetNetworkInterfacesResponse **)soap_malloc(soap, sizeof(struct _tds__SetNetworkInterfacesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__SetNetworkInterfacesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetNetworkInterfacesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkInterfacesResponse, sizeof(struct _tds__SetNetworkInterfacesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkInterfacesResponse(struct soap *soap, struct _tds__SetNetworkInterfacesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNetworkInterfacesResponse);
	if (soap_out_PointerTo_tds__SetNetworkInterfacesResponse(soap, tag?tag:"tds:SetNetworkInterfacesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkInterfacesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkInterfacesResponse(struct soap *soap, struct _tds__SetNetworkInterfacesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkInterfacesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, struct _tds__SetNetworkInterfaces *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkInterfaces))
		soap_serialize__tds__SetNetworkInterfaces(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, const char *tag, int id, struct _tds__SetNetworkInterfaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkInterfaces);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetNetworkInterfaces(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetNetworkInterfaces ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, const char *tag, struct _tds__SetNetworkInterfaces **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__SetNetworkInterfaces **)soap_malloc(soap, sizeof(struct _tds__SetNetworkInterfaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__SetNetworkInterfaces(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetNetworkInterfaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkInterfaces, sizeof(struct _tds__SetNetworkInterfaces), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, struct _tds__SetNetworkInterfaces *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNetworkInterfaces);
	if (soap_out_PointerTo_tds__SetNetworkInterfaces(soap, tag?tag:"tds:SetNetworkInterfaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkInterfaces ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, struct _tds__SetNetworkInterfaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNetworkInterfacesResponse(struct soap *soap, struct _tds__SetNetworkInterfacesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->RebootNeeded);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNetworkInterfacesResponse(struct soap *soap, const struct _tds__SetNetworkInterfacesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->RebootNeeded, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkInterfacesResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetNetworkInterfacesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkInterfacesResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:RebootNeeded");
	if (soap_out_xsd__boolean_(soap, "tds:RebootNeeded", -1, &a->RebootNeeded, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNetworkInterfacesResponse * SOAP_FMAC4 soap_in__tds__SetNetworkInterfacesResponse(struct soap *soap, const char *tag, struct _tds__SetNetworkInterfacesResponse *a, const char *type)
{
	size_t soap_flag_RebootNeeded = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetNetworkInterfacesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkInterfacesResponse, sizeof(struct _tds__SetNetworkInterfacesResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__SetNetworkInterfacesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RebootNeeded && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tds:RebootNeeded", &a->RebootNeeded, "xsd:boolean"))
				{	
					soap_flag_RebootNeeded--;
					continue;
				}
				soap_check_result(soap, "tds:RebootNeeded");
				if (soap->error == SOAP_TAG_MISMATCH)
					soap->error = soap_ignore_element(soap);
				if (soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetNetworkInterfacesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkInterfacesResponse, 0, sizeof(struct _tds__SetNetworkInterfacesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RebootNeeded > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNetworkInterfacesResponse(struct soap *soap, const struct _tds__SetNetworkInterfacesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetNetworkInterfacesResponse);
	if (soap_out__tds__SetNetworkInterfacesResponse(soap, tag?tag:"tds:SetNetworkInterfacesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkInterfacesResponse * SOAP_FMAC4 soap_get__tds__SetNetworkInterfacesResponse(struct soap *soap, struct _tds__SetNetworkInterfacesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkInterfacesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNetworkInterfaces(struct soap *soap, struct _tds__SetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->InterfaceToken);
	a->NetworkInterface = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNetworkInterfaces(struct soap *soap, const struct _tds__SetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->InterfaceToken);
	soap_serialize_PointerTott__NetworkInterfaceSetConfiguration(soap, &a->NetworkInterface);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkInterfaces(struct soap *soap, const char *tag, int id, const struct _tds__SetNetworkInterfaces *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkInterfaces), type))
		return soap->error;
	if (a->InterfaceToken)
	{	
		if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, &a->InterfaceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:InterfaceToken"))
		return soap->error;
	if (a->NetworkInterface)
	{	
		if (soap_out_PointerTott__NetworkInterfaceSetConfiguration(soap, "tds:NetworkInterface", -1, &a->NetworkInterface, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:NetworkInterface"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNetworkInterfaces * SOAP_FMAC4 soap_in__tds__SetNetworkInterfaces(struct soap *soap, const char *tag, struct _tds__SetNetworkInterfaces *a, const char *type)
{
	size_t soap_flag_InterfaceToken = 1;
	size_t soap_flag_NetworkInterface = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetNetworkInterfaces *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkInterfaces, sizeof(struct _tds__SetNetworkInterfaces), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__SetNetworkInterfaces(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", &a->InterfaceToken, "tt:ReferenceToken"))
				{	
					soap_flag_InterfaceToken--;
					continue;
				}
				if (soap_flag_NetworkInterface && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__NetworkInterfaceSetConfiguration(soap, "tds:NetworkInterface", &a->NetworkInterface, "tt:NetworkInterfaceSetConfiguration"))
					{	
						soap_flag_NetworkInterface--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH)
						soap->error = soap_ignore_element(soap);
					if (soap->error == SOAP_NO_TAG)
						break;
					if (soap->error)
						return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetNetworkInterfaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkInterfaces, 0, sizeof(struct _tds__SetNetworkInterfaces), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceToken > 0 || soap_flag_NetworkInterface > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNetworkInterfaces(struct soap *soap, const struct _tds__SetNetworkInterfaces *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetNetworkInterfaces);
	if (soap_out__tds__SetNetworkInterfaces(soap, tag?tag:"tds:SetNetworkInterfaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkInterfaces * SOAP_FMAC4 soap_get__tds__SetNetworkInterfaces(struct soap *soap, struct _tds__SetNetworkInterfaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__NetworkInterfaceSetConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration))
		soap_serialize_tt__NetworkInterfaceSetConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceSetConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceSetConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, struct tt__NetworkInterfaceSetConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__NetworkInterfaceSetConfiguration **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceSetConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceSetConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__NetworkInterfaceSetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, sizeof(struct tt__NetworkInterfaceSetConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__NetworkInterfaceSetConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkInterfaceSetConfiguration);
	if (soap_out_PointerTott__NetworkInterfaceSetConfiguration(soap, tag?tag:"tt:NetworkInterfaceSetConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__NetworkInterfaceSetConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__NetworkInterfaceSetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Enabled = NULL;
	a->Link = NULL;
	a->MTU = NULL;
	a->IPv4 = NULL;
	a->IPv6 = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterfaceSetConfiguration(struct soap *soap, const struct tt__NetworkInterfaceSetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean_(soap, &a->Enabled);
	soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(soap, &a->Link);
	soap_serialize_PointerToint(soap, &a->MTU);
	soap_serialize_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, &a->IPv4);
	soap_serialize_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, &a->IPv6);
	soap_serialize_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, const struct tt__NetworkInterfaceSetConfiguration *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:Link", -1, &a->Link, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:MTU", -1, &a->MTU, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, "tt:IPv4", -1, &a->IPv4, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, "tt:IPv6", -1, &a->IPv6, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_in_tt__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, struct tt__NetworkInterfaceSetConfiguration *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_Link = 1;
	size_t soap_flag_MTU = 1;
	size_t soap_flag_IPv4 = 1;
	size_t soap_flag_IPv6 = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkInterfaceSetConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, sizeof(struct tt__NetworkInterfaceSetConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkInterfaceSetConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerToxsd__boolean_(soap, "tt:Enabled", &a->Enabled, "xsd:boolean"))
			{	soap_flag_Enabled--;
		continue;
		}
		if (soap_flag_Link && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:Link", &a->Link, "tt:NetworkInterfaceConnectionSetting"))
			{	soap_flag_Link--;
		continue;
		}
		if (soap_flag_MTU && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerToint(soap, "tt:MTU", &a->MTU, "xsd:int"))
			{	soap_flag_MTU--;
		continue;
		}
		if (soap_flag_IPv4 && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, "tt:IPv4", &a->IPv4, "tt:IPv4NetworkInterfaceSetConfiguration"))
			{	soap_flag_IPv4--;
		continue;
		}
		if (soap_flag_IPv6 && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, "tt:IPv6", &a->IPv6, "tt:IPv6NetworkInterfaceSetConfiguration"))
			{	soap_flag_IPv6--;
		continue;
		}
		if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:NetworkInterfaceSetConfigurationExtension"))
			{	soap_flag_Extension--;
		continue;
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceSetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, 0, sizeof(struct tt__NetworkInterfaceSetConfiguration), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterfaceSetConfiguration(struct soap *soap, const struct tt__NetworkInterfaceSetConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration);
	if (soap_out_tt__NetworkInterfaceSetConfiguration(soap, tag?tag:"tt:NetworkInterfaceSetConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_get_tt__NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__NetworkInterfaceSetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2))
		soap_serialize_tt__NetworkInterfaceSetConfigurationExtension2(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceSetConfigurationExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceSetConfigurationExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfigurationExtension2 ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, const char *tag, struct tt__NetworkInterfaceSetConfigurationExtension2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__NetworkInterfaceSetConfigurationExtension2 **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceSetConfigurationExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__NetworkInterfaceSetConfigurationExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkInterfaceSetConfigurationExtension2);
	if (soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, tag?tag:"tt:NetworkInterfaceSetConfigurationExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfigurationExtension2 ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension))
		soap_serialize_tt__NetworkInterfaceSetConfigurationExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceSetConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceSetConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, struct tt__NetworkInterfaceSetConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__NetworkInterfaceSetConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceSetConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__NetworkInterfaceSetConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkInterfaceSetConfigurationExtension);
	if (soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, tag?tag:"tt:NetworkInterfaceSetConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, const struct tt__NetworkInterfaceSetConfigurationExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, const char *tag, int id, const struct tt__NetworkInterfaceSetConfigurationExtension2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2), type))
		return soap->error;
	if (a->__any)
	{	int i;
	for (i = 0; i < a->__size; i++)
		soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfigurationExtension2 * SOAP_FMAC4 soap_in_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, const char *tag, struct tt__NetworkInterfaceSetConfigurationExtension2 *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkInterfaceSetConfigurationExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkInterfaceSetConfigurationExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
		{	if (a->__any == NULL)
		{	if (soap_blist___any == NULL)
		soap_blist___any = soap_new_block(soap);
		a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
		if (a->__any == NULL)
			return NULL;
		*a->__any = NULL;
		}
		if (soap_inliteral(soap, "-any", a->__any))
		{	a->__size++;
		a->__any = NULL;
		continue;
		}
		}
		if (soap->error == SOAP_TAG_MISMATCH)
			soap->error = soap_ignore_element(soap);
		if (soap->error == SOAP_NO_TAG)
			break;
		if (soap->error)
			return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
		if (soap_blist___any)
			soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceSetConfigurationExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, 0, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension2), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, const struct tt__NetworkInterfaceSetConfigurationExtension2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2);
	if (soap_out_tt__NetworkInterfaceSetConfigurationExtension2(soap, tag?tag:"tt:NetworkInterfaceSetConfigurationExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfigurationExtension2 * SOAP_FMAC4 soap_get_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceSetConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__sizeDot3 = 0;
	a->Dot3 = NULL;
	a->Dot11 = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const struct tt__NetworkInterfaceSetConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Dot3)
	{	
		int i;
		for (i = 0; i < a->__sizeDot3; i++)
		{
			soap_embedded(soap, a->Dot3 + i, SOAP_TYPE_tt__Dot3Configuration);
			soap_serialize_tt__Dot3Configuration(soap, a->Dot3 + i);
		}
	}
	soap_serialize_PointerTott__Dot11Configuration(soap, &a->Dot11);
	soap_serialize_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__NetworkInterfaceSetConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension), type))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	if (a->Dot3)
	{	
		int i;
		for (i = 0; i < a->__sizeDot3; i++)
			if (soap_out_tt__Dot3Configuration(soap, "tt:Dot3", -1, a->Dot3 + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__Dot11Configuration(soap, "tt:Dot11", -1, &a->Dot11, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfigurationExtension * SOAP_FMAC4 soap_in_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, struct tt__NetworkInterfaceSetConfigurationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	struct soap_blist *soap_blist_Dot3 = NULL;
	size_t soap_flag_Dot11 = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkInterfaceSetConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__NetworkInterfaceSetConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Dot3", 1, NULL))
			{	
				if (a->Dot3 == NULL)
				{	
					if (soap_blist_Dot3 == NULL)
						soap_blist_Dot3 = soap_new_block(soap);
					a->Dot3 = (struct tt__Dot3Configuration *)soap_push_block(soap, soap_blist_Dot3, sizeof(struct tt__Dot3Configuration));
					if (a->Dot3 == NULL)
						return NULL;
					soap_default_tt__Dot3Configuration(soap, a->Dot3);
				}
				soap_revert(soap);
				if (soap_in_tt__Dot3Configuration(soap, "tt:Dot3", a->Dot3, "tt:Dot3Configuration"))
				{	
					a->__sizeDot3++;
					a->Dot3 = NULL;
					continue;
				}
			}
			if (soap_flag_Dot11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11Configuration(soap, "tt:Dot11", &a->Dot11, "tt:Dot11Configuration"))
				{	
					soap_flag_Dot11--;
					continue;
				}
				if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, "tt:Extension", &a->Extension, "tt:NetworkInterfaceSetConfigurationExtension2"))
					{	
						soap_flag_Extension--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH)
						soap->error = soap_ignore_element(soap);
					if (soap->error == SOAP_NO_TAG)
						break;
					if (soap->error)
						return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->Dot3)
			soap_pop_block(soap, soap_blist_Dot3);
		if (a->__sizeDot3)
			a->Dot3 = (struct tt__Dot3Configuration *)soap_save_block(soap, soap_blist_Dot3, NULL, 1);
		else
		{	
			a->Dot3 = NULL;
			if (soap_blist_Dot3)
				soap_end_block(soap, soap_blist_Dot3);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__NetworkInterfaceSetConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, 0, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const struct tt__NetworkInterfaceSetConfigurationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension);
	if (soap_out_tt__NetworkInterfaceSetConfigurationExtension(soap, tag?tag:"tt:NetworkInterfaceSetConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfigurationExtension * SOAP_FMAC4 soap_get_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceSetConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11Configuration(struct soap *soap, struct tt__Dot11Configuration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11Configuration))
		soap_serialize_tt__Dot11Configuration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11Configuration(struct soap *soap, const char *tag, int id, struct tt__Dot11Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11Configuration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11Configuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot11Configuration ** SOAP_FMAC4 soap_in_PointerTott__Dot11Configuration(struct soap *soap, const char *tag, struct tt__Dot11Configuration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__Dot11Configuration **)soap_malloc(soap, sizeof(struct tt__Dot11Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11Configuration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__Dot11Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11Configuration, sizeof(struct tt__Dot11Configuration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11Configuration(struct soap *soap, struct tt__Dot11Configuration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Dot11Configuration);
	if (soap_out_PointerTott__Dot11Configuration(soap, tag?tag:"tt:Dot11Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11Configuration ** SOAP_FMAC4 soap_get_PointerTott__Dot11Configuration(struct soap *soap, struct tt__Dot11Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot3Configuration(struct soap *soap, struct tt__Dot3Configuration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot3Configuration))
		soap_serialize_tt__Dot3Configuration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot3Configuration(struct soap *soap, const char *tag, int id, struct tt__Dot3Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot3Configuration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot3Configuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot3Configuration ** SOAP_FMAC4 soap_in_PointerTott__Dot3Configuration(struct soap *soap, const char *tag, struct tt__Dot3Configuration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__Dot3Configuration **)soap_malloc(soap, sizeof(struct tt__Dot3Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__Dot3Configuration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__Dot3Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot3Configuration, sizeof(struct tt__Dot3Configuration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot3Configuration(struct soap *soap, struct tt__Dot3Configuration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Dot3Configuration);
	if (soap_out_PointerTott__Dot3Configuration(soap, tag?tag:"tt:Dot3Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot3Configuration ** SOAP_FMAC4 soap_get_PointerTott__Dot3Configuration(struct soap *soap, struct tt__Dot3Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot3Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetNetworkProtocols(struct soap *soap, struct __tds__SetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetNetworkProtocols = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetNetworkProtocols(struct soap *soap, const struct __tds__SetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetNetworkProtocols(soap, &a->tds__SetNetworkProtocols);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetNetworkProtocols(struct soap *soap, const char *tag, int id, const struct __tds__SetNetworkProtocols *a, const char *type)
{
	if (soap_out_PointerTo_tds__SetNetworkProtocols(soap, "tds:SetNetworkProtocols", -1, &a->tds__SetNetworkProtocols, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkProtocols * SOAP_FMAC4 soap_in___tds__SetNetworkProtocols(struct soap *soap, const char *tag, struct __tds__SetNetworkProtocols *a, const char *type)
{
	size_t soap_flag_tds__SetNetworkProtocols = 1;
	short soap_flag;
	a = (struct __tds__SetNetworkProtocols *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetNetworkProtocols, sizeof(struct __tds__SetNetworkProtocols), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetNetworkProtocols(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	soap->error = SOAP_TAG_MISMATCH;
	if (soap_flag_tds__SetNetworkProtocols && soap->error == SOAP_TAG_MISMATCH)
		if (soap_in_PointerTo_tds__SetNetworkProtocols(soap, "tds:SetNetworkProtocols", &a->tds__SetNetworkProtocols, ""))
		{	soap_flag_tds__SetNetworkProtocols--;
	continue;
	}
	if (soap->error == SOAP_TAG_MISMATCH)
		if (soap_flag)
		{	soap->error = SOAP_OK;
	break;
	}
	if (soap_flag && soap->error == SOAP_NO_TAG)
		break;
	if (soap->error)
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetNetworkProtocols(struct soap *soap, const struct __tds__SetNetworkProtocols *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetNetworkProtocols(soap, tag?tag:"-tds:SetNetworkProtocols", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkProtocols * SOAP_FMAC4 soap_get___tds__SetNetworkProtocols(struct soap *soap, struct __tds__SetNetworkProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetNetworkProtocols(struct soap *soap, struct __tds__GetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetNetworkProtocols = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetNetworkProtocols(struct soap *soap, const struct __tds__GetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetNetworkProtocols(soap, &a->tds__GetNetworkProtocols);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetNetworkProtocols(struct soap *soap, const char *tag, int id, const struct __tds__GetNetworkProtocols *a, const char *type)
{
	if (soap_out_PointerTo_tds__GetNetworkProtocols(soap, "tds:GetNetworkProtocols", -1, &a->tds__GetNetworkProtocols, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkProtocols * SOAP_FMAC4 soap_in___tds__GetNetworkProtocols(struct soap *soap, const char *tag, struct __tds__GetNetworkProtocols *a, const char *type)
{
	size_t soap_flag_tds__GetNetworkProtocols = 1;
	short soap_flag;
	a = (struct __tds__GetNetworkProtocols *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetNetworkProtocols, sizeof(struct __tds__GetNetworkProtocols), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___tds__GetNetworkProtocols(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__GetNetworkProtocols && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__GetNetworkProtocols(soap, "tds:GetNetworkProtocols", &a->tds__GetNetworkProtocols, ""))
			{	
				soap_flag_tds__GetNetworkProtocols--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetNetworkProtocols(struct soap *soap, const struct __tds__GetNetworkProtocols *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetNetworkProtocols(soap, tag?tag:"-tds:GetNetworkProtocols", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkProtocols * SOAP_FMAC4 soap_get___tds__GetNetworkProtocols(struct soap *soap, struct __tds__GetNetworkProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkProtocolsResponse(struct soap *soap, struct _tds__SetNetworkProtocolsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkProtocolsResponse))
		soap_serialize__tds__SetNetworkProtocolsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkProtocolsResponse(struct soap *soap, const char *tag, int id, struct _tds__SetNetworkProtocolsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkProtocolsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetNetworkProtocolsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetNetworkProtocolsResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkProtocolsResponse(struct soap *soap, const char *tag, struct _tds__SetNetworkProtocolsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__SetNetworkProtocolsResponse **)soap_malloc(soap, sizeof(struct _tds__SetNetworkProtocolsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__SetNetworkProtocolsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetNetworkProtocolsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkProtocolsResponse, sizeof(struct _tds__SetNetworkProtocolsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkProtocolsResponse(struct soap *soap, struct _tds__SetNetworkProtocolsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNetworkProtocolsResponse);
	if (soap_out_PointerTo_tds__SetNetworkProtocolsResponse(soap, tag?tag:"tds:SetNetworkProtocolsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkProtocolsResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkProtocolsResponse(struct soap *soap, struct _tds__SetNetworkProtocolsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkProtocolsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkProtocols(struct soap *soap, struct _tds__SetNetworkProtocols *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkProtocols))
		soap_serialize__tds__SetNetworkProtocols(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkProtocols(struct soap *soap, const char *tag, int id, struct _tds__SetNetworkProtocols *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkProtocols);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetNetworkProtocols(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetNetworkProtocols ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkProtocols(struct soap *soap, const char *tag, struct _tds__SetNetworkProtocols **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__SetNetworkProtocols **)soap_malloc(soap, sizeof(struct _tds__SetNetworkProtocols *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__SetNetworkProtocols(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetNetworkProtocols **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkProtocols, sizeof(struct _tds__SetNetworkProtocols), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkProtocols(struct soap *soap, struct _tds__SetNetworkProtocols *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNetworkProtocols);
	if (soap_out_PointerTo_tds__SetNetworkProtocols(soap, tag?tag:"tds:SetNetworkProtocols", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkProtocols ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkProtocols(struct soap *soap, struct _tds__SetNetworkProtocols **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkProtocolsResponse(struct soap *soap, struct _tds__GetNetworkProtocolsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkProtocolsResponse))
		soap_serialize__tds__GetNetworkProtocolsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkProtocolsResponse(struct soap *soap, const char *tag, int id, struct _tds__GetNetworkProtocolsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkProtocolsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetNetworkProtocolsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetNetworkProtocolsResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkProtocolsResponse(struct soap *soap, const char *tag, struct _tds__GetNetworkProtocolsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__GetNetworkProtocolsResponse **)soap_malloc(soap, sizeof(struct _tds__GetNetworkProtocolsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__GetNetworkProtocolsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetNetworkProtocolsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkProtocolsResponse, sizeof(struct _tds__GetNetworkProtocolsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkProtocolsResponse(struct soap *soap, struct _tds__GetNetworkProtocolsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNetworkProtocolsResponse);
	if (soap_out_PointerTo_tds__GetNetworkProtocolsResponse(soap, tag?tag:"tds:GetNetworkProtocolsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkProtocolsResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkProtocolsResponse(struct soap *soap, struct _tds__GetNetworkProtocolsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkProtocolsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkProtocols(struct soap *soap, struct _tds__GetNetworkProtocols *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkProtocols))
		soap_serialize__tds__GetNetworkProtocols(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkProtocols(struct soap *soap, const char *tag, int id, struct _tds__GetNetworkProtocols *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkProtocols);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetNetworkProtocols(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetNetworkProtocols ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkProtocols(struct soap *soap, const char *tag, struct _tds__GetNetworkProtocols **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__GetNetworkProtocols **)soap_malloc(soap, sizeof(struct _tds__GetNetworkProtocols *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__GetNetworkProtocols(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetNetworkProtocols **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkProtocols, sizeof(struct _tds__GetNetworkProtocols), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkProtocols(struct soap *soap, struct _tds__GetNetworkProtocols *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNetworkProtocols);
	if (soap_out_PointerTo_tds__GetNetworkProtocols(soap, tag?tag:"tds:GetNetworkProtocols", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkProtocols ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkProtocols(struct soap *soap, struct _tds__GetNetworkProtocols **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNetworkProtocolsResponse(struct soap *soap, struct _tds__SetNetworkProtocolsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNetworkProtocolsResponse(struct soap *soap, const struct _tds__SetNetworkProtocolsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkProtocolsResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetNetworkProtocolsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkProtocolsResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNetworkProtocolsResponse * SOAP_FMAC4 soap_in__tds__SetNetworkProtocolsResponse(struct soap *soap, const char *tag, struct _tds__SetNetworkProtocolsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetNetworkProtocolsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkProtocolsResponse, sizeof(struct _tds__SetNetworkProtocolsResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__SetNetworkProtocolsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetNetworkProtocolsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkProtocolsResponse, 0, sizeof(struct _tds__SetNetworkProtocolsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNetworkProtocolsResponse(struct soap *soap, const struct _tds__SetNetworkProtocolsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetNetworkProtocolsResponse);
	if (soap_out__tds__SetNetworkProtocolsResponse(soap, tag?tag:"tds:SetNetworkProtocolsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkProtocolsResponse * SOAP_FMAC4 soap_get__tds__SetNetworkProtocolsResponse(struct soap *soap, struct _tds__SetNetworkProtocolsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkProtocolsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNetworkProtocols(struct soap *soap, struct _tds__SetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNetworkProtocols = 0;
	a->NetworkProtocols = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNetworkProtocols(struct soap *soap, const struct _tds__SetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->NetworkProtocols)
	{
		int i;
		for (i = 0; i < a->__sizeNetworkProtocols; i++)
		{
			soap_embedded(soap, a->NetworkProtocols + i, SOAP_TYPE_tt__NetworkProtocol);
			soap_serialize_tt__NetworkProtocol(soap, a->NetworkProtocols + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkProtocols(struct soap *soap, const char *tag, int id, const struct _tds__SetNetworkProtocols *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkProtocols), type))
		return soap->error;
	if (a->NetworkProtocols)
	{	
		int i;
		for (i = 0; i < a->__sizeNetworkProtocols; i++)
			if (soap_out_tt__NetworkProtocol(soap, "tds:NetworkProtocols", -1, a->NetworkProtocols + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNetworkProtocols * SOAP_FMAC4 soap_in__tds__SetNetworkProtocols(struct soap *soap, const char *tag, struct _tds__SetNetworkProtocols *a, const char *type)
{
	struct soap_blist *soap_blist_NetworkProtocols = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetNetworkProtocols *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkProtocols, sizeof(struct _tds__SetNetworkProtocols), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetNetworkProtocols(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NetworkProtocols", 1, NULL))
			{	
				if (a->NetworkProtocols == NULL)
				{	
					if (soap_blist_NetworkProtocols == NULL)
						soap_blist_NetworkProtocols = soap_new_block(soap);
					a->NetworkProtocols = (struct tt__NetworkProtocol *)soap_push_block(soap, soap_blist_NetworkProtocols, sizeof(struct tt__NetworkProtocol));
					if (a->NetworkProtocols == NULL)
						return NULL;
					soap_default_tt__NetworkProtocol(soap, a->NetworkProtocols);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkProtocol(soap, "tds:NetworkProtocols", a->NetworkProtocols, "tt:NetworkProtocol"))
				{	
					a->__sizeNetworkProtocols++;
					a->NetworkProtocols = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NetworkProtocols)
			soap_pop_block(soap, soap_blist_NetworkProtocols);
		if (a->__sizeNetworkProtocols)
			a->NetworkProtocols = (struct tt__NetworkProtocol *)soap_save_block(soap, soap_blist_NetworkProtocols, NULL, 1);
		else
		{	
			a->NetworkProtocols = NULL;
			if (soap_blist_NetworkProtocols)
				soap_end_block(soap, soap_blist_NetworkProtocols);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetNetworkProtocols *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkProtocols, 0, sizeof(struct _tds__SetNetworkProtocols), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeNetworkProtocols < 1))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNetworkProtocols(struct soap *soap, const struct _tds__SetNetworkProtocols *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetNetworkProtocols);
	if (soap_out__tds__SetNetworkProtocols(soap, tag?tag:"tds:SetNetworkProtocols", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkProtocols * SOAP_FMAC4 soap_get__tds__SetNetworkProtocols(struct soap *soap, struct _tds__SetNetworkProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkProtocol(struct soap *soap, struct tt__NetworkProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__NetworkProtocolType(soap, &a->Name);
	soap_default_xsd__boolean_(soap, &a->Enabled);
	a->__sizePort = 0;
	a->Port = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkProtocol(struct soap *soap, const struct tt__NetworkProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean_);
	if (a->Port)
	{	
		int i;
		for (i = 0; i < a->__sizePort; i++)
		{
			soap_embedded(soap, a->Port + i, SOAP_TYPE_int);
		}
	}
	soap_serialize_PointerTott__NetworkProtocolExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkProtocol(struct soap *soap, const char *tag, int id, const struct tt__NetworkProtocol *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkProtocol), type))
		return soap->error;
	if (soap_out_tt__NetworkProtocolType(soap, "tt:Name", -1, &a->Name, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (a->Port)
	{	
		int i;
		for (i = 0; i < a->__sizePort; i++)
			if (soap_out_int(soap, "tt:Port", -1, a->Port + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__NetworkProtocolExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkProtocol * SOAP_FMAC4 soap_in_tt__NetworkProtocol(struct soap *soap, const char *tag, struct tt__NetworkProtocol *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Enabled = 1;
	struct soap_blist *soap_blist_Port = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkProtocol *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkProtocol, sizeof(struct tt__NetworkProtocol), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__NetworkProtocol(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__NetworkProtocolType(soap, "tt:Name", &a->Name, "tt:NetworkProtocolType"))
				{	
					soap_flag_Name--;
					continue;
				}
				if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_xsd__boolean_(soap, "tt:Enabled", &a->Enabled, "xsd:boolean"))
					{	
						soap_flag_Enabled--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Port", 1, NULL))
					{	
						if (a->Port == NULL)
						{	
							if (soap_blist_Port == NULL)
								soap_blist_Port = soap_new_block(soap);
							a->Port = (int *)soap_push_block(soap, soap_blist_Port, sizeof(int));
							if (a->Port == NULL)
								return NULL;
							soap_default_int(soap, a->Port);
						}
						soap_revert(soap);
						if (soap_in_int(soap, "tt:Port", a->Port, "xsd:int"))
						{	
							a->__sizePort++;
							a->Port = NULL;
							continue;
						}
					}
					if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTott__NetworkProtocolExtension(soap, "tt:Extension", &a->Extension, "tt:NetworkProtocolExtension"))
						{	
							soap_flag_Extension--;
							continue;
						}
						if (soap->error == SOAP_TAG_MISMATCH)
							soap->error = soap_ignore_element(soap);
						if (soap->error == SOAP_NO_TAG)
							break;
						if (soap->error)
							return NULL;
		}
		if (a->Port)
			soap_pop_block(soap, soap_blist_Port);
		if (a->__sizePort)
			a->Port = (int *)soap_save_block(soap, soap_blist_Port, NULL, 1);
		else
		{	
			a->Port = NULL;
			if (soap_blist_Port)
				soap_end_block(soap, soap_blist_Port);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__NetworkProtocol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkProtocol, 0, sizeof(struct tt__NetworkProtocol), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_Enabled > 0 || a->__sizePort < 1))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkProtocol(struct soap *soap, const struct tt__NetworkProtocol *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkProtocol);
	if (soap_out_tt__NetworkProtocol(soap, tag?tag:"tt:NetworkProtocol", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkProtocol * SOAP_FMAC4 soap_get_tt__NetworkProtocol(struct soap *soap, struct tt__NetworkProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNetworkProtocolsResponse(struct soap *soap, struct _tds__GetNetworkProtocolsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNetworkProtocols = 0;
	a->NetworkProtocols = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNetworkProtocolsResponse(struct soap *soap, const struct _tds__GetNetworkProtocolsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->NetworkProtocols)
	{	
		int i;
		for (i = 0; i < a->__sizeNetworkProtocols; i++)
		{
			soap_embedded(soap, a->NetworkProtocols + i, SOAP_TYPE_tt__NetworkProtocol);
			soap_serialize_tt__NetworkProtocol(soap, a->NetworkProtocols + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkProtocolsResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetNetworkProtocolsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkProtocolsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeNetworkProtocols");
	if (a->NetworkProtocols)
	{	
		int i;
		for (i = 0; i < a->__sizeNetworkProtocols; i++)
			if (soap_out_tt__NetworkProtocol(soap, "tds:NetworkProtocols", -1, a->NetworkProtocols + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNetworkProtocolsResponse * SOAP_FMAC4 soap_in__tds__GetNetworkProtocolsResponse(struct soap *soap, const char *tag, struct _tds__GetNetworkProtocolsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_NetworkProtocols = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetNetworkProtocolsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkProtocolsResponse, sizeof(struct _tds__GetNetworkProtocolsResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__GetNetworkProtocolsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NetworkProtocols", 1, NULL))
			{	
				if (a->NetworkProtocols == NULL)
				{	
					if (soap_blist_NetworkProtocols == NULL)
						soap_blist_NetworkProtocols = soap_new_block(soap);
					a->NetworkProtocols = (struct tt__NetworkProtocol *)soap_push_block(soap, soap_blist_NetworkProtocols, sizeof(struct tt__NetworkProtocol));
					if (a->NetworkProtocols == NULL)
						return NULL;
					soap_default_tt__NetworkProtocol(soap, a->NetworkProtocols);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkProtocol(soap, "tds:NetworkProtocols", a->NetworkProtocols, "tt:NetworkProtocol"))
				{	
					a->__sizeNetworkProtocols++;
					a->NetworkProtocols = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeNetworkProtocols");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NetworkProtocols)
			soap_pop_block(soap, soap_blist_NetworkProtocols);
		if (a->__sizeNetworkProtocols)
			a->NetworkProtocols = (struct tt__NetworkProtocol *)soap_save_block(soap, soap_blist_NetworkProtocols, NULL, 1);
		else
		{	
			a->NetworkProtocols = NULL;
			if (soap_blist_NetworkProtocols)
				soap_end_block(soap, soap_blist_NetworkProtocols);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetNetworkProtocolsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkProtocolsResponse, 0, sizeof(struct _tds__GetNetworkProtocolsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNetworkProtocolsResponse(struct soap *soap, const struct _tds__GetNetworkProtocolsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetNetworkProtocolsResponse);
	if (soap_out__tds__GetNetworkProtocolsResponse(soap, tag?tag:"tds:GetNetworkProtocolsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkProtocolsResponse * SOAP_FMAC4 soap_get__tds__GetNetworkProtocolsResponse(struct soap *soap, struct _tds__GetNetworkProtocolsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkProtocolsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNetworkProtocols(struct soap *soap, struct _tds__GetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNetworkProtocols(struct soap *soap, const struct _tds__GetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkProtocols(struct soap *soap, const char *tag, int id, const struct _tds__GetNetworkProtocols *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkProtocols), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNetworkProtocols * SOAP_FMAC4 soap_in__tds__GetNetworkProtocols(struct soap *soap, const char *tag, struct _tds__GetNetworkProtocols *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetNetworkProtocols *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkProtocols, sizeof(struct _tds__GetNetworkProtocols), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__GetNetworkProtocols(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{
		a = (struct _tds__GetNetworkProtocols *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkProtocols, 0, sizeof(struct _tds__GetNetworkProtocols), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNetworkProtocols(struct soap *soap, const struct _tds__GetNetworkProtocols *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetNetworkProtocols);
	if (soap_out__tds__GetNetworkProtocols(soap, tag?tag:"tds:GetNetworkProtocols", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkProtocols * SOAP_FMAC4 soap_get__tds__GetNetworkProtocols(struct soap *soap, struct _tds__GetNetworkProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkProtocolType(struct soap *soap, enum tt__NetworkProtocolType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__NetworkProtocolType
	*a = SOAP_DEFAULT_tt__NetworkProtocolType;
#else
	*a = (enum tt__NetworkProtocolType)0;
#endif
}

static const struct soap_code_map soap_codes_tt__NetworkProtocolType[] =
{	
	{ (long)tt__NetworkProtocolType__HTTP, "HTTP" },
	{ (long)tt__NetworkProtocolType__HTTPS, "HTTPS" },
	{ (long)tt__NetworkProtocolType__RTSP, "RTSP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__NetworkProtocolType2s(struct soap *soap, enum tt__NetworkProtocolType n)
{	
	const char *s = soap_code_str(soap_codes_tt__NetworkProtocolType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkProtocolType(struct soap *soap, const char *tag, int id, const enum tt__NetworkProtocolType *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkProtocolType), type) || soap_send(soap, soap_tt__NetworkProtocolType2s(soap, *a)))
	return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__NetworkProtocolType(struct soap *soap, const char *s, enum tt__NetworkProtocolType *a)
{
	const struct soap_code_map *map;
	if (s == NULL)
		return soap->error;
	map = soap_code(soap_codes_tt__NetworkProtocolType, s);
	if (map)
		*a = (enum tt__NetworkProtocolType)map->code;
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__NetworkProtocolType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__NetworkProtocolType * SOAP_FMAC4 soap_in_tt__NetworkProtocolType(struct soap *soap, const char *tag, enum tt__NetworkProtocolType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	return NULL;
	a = (enum tt__NetworkProtocolType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkProtocolType, sizeof(enum tt__NetworkProtocolType), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	if (soap->body && !*soap->href)
	{	
		if (!a || soap_s2tt__NetworkProtocolType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (enum tt__NetworkProtocolType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkProtocolType, 0, sizeof(enum tt__NetworkProtocolType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkProtocolType(struct soap *soap, const enum tt__NetworkProtocolType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkProtocolType);
	if (soap_out_tt__NetworkProtocolType(soap, tag?tag:"tt:NetworkProtocolType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__NetworkProtocolType * SOAP_FMAC4 soap_get_tt__NetworkProtocolType(struct soap *soap, enum tt__NetworkProtocolType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkProtocolType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkProtocolExtension(struct soap *soap, struct tt__NetworkProtocolExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkProtocolExtension))
		soap_serialize_tt__NetworkProtocolExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkProtocolExtension(struct soap *soap, const char *tag, int id, struct tt__NetworkProtocolExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkProtocolExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkProtocolExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkProtocolExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkProtocolExtension(struct soap *soap, const char *tag, struct tt__NetworkProtocolExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__NetworkProtocolExtension **)soap_malloc(soap, sizeof(struct tt__NetworkProtocolExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkProtocolExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__NetworkProtocolExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkProtocolExtension, sizeof(struct tt__NetworkProtocolExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkProtocolExtension(struct soap *soap, struct tt__NetworkProtocolExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkProtocolExtension);
	if (soap_out_PointerTott__NetworkProtocolExtension(soap, tag?tag:"tt:NetworkProtocolExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkProtocolExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkProtocolExtension(struct soap *soap, struct tt__NetworkProtocolExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkProtocolExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkProtocolExtension(struct soap *soap, struct tt__NetworkProtocolExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkProtocolExtension(struct soap *soap, const struct tt__NetworkProtocolExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkProtocolExtension(struct soap *soap, const char *tag, int id, const struct tt__NetworkProtocolExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkProtocolExtension), type))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkProtocolExtension * SOAP_FMAC4 soap_in_tt__NetworkProtocolExtension(struct soap *soap, const char *tag, struct tt__NetworkProtocolExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkProtocolExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkProtocolExtension, sizeof(struct tt__NetworkProtocolExtension), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__NetworkProtocolExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__NetworkProtocolExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkProtocolExtension, 0, sizeof(struct tt__NetworkProtocolExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkProtocolExtension(struct soap *soap, const struct tt__NetworkProtocolExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkProtocolExtension);
	if (soap_out_tt__NetworkProtocolExtension(soap, tag?tag:"tt:NetworkProtocolExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkProtocolExtension * SOAP_FMAC4 soap_get_tt__NetworkProtocolExtension(struct soap *soap, struct tt__NetworkProtocolExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkProtocolExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetDNS(struct soap *soap, struct __tds__SetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetDNS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetDNS(struct soap *soap, const struct __tds__SetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetDNS(soap, &a->tds__SetDNS);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetDNS(struct soap *soap, const char *tag, int id, const struct __tds__SetDNS *a, const char *type)
{
	if (soap_out_PointerTo_tds__SetDNS(soap, "tds:SetDNS", -1, &a->tds__SetDNS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDNS * SOAP_FMAC4 soap_in___tds__SetDNS(struct soap *soap, const char *tag, struct __tds__SetDNS *a, const char *type)
{
	size_t soap_flag_tds__SetDNS = 1;
	short soap_flag;
	a = (struct __tds__SetDNS *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetDNS, sizeof(struct __tds__SetDNS), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___tds__SetDNS(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__SetDNS && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__SetDNS(soap, "tds:SetDNS", &a->tds__SetDNS, ""))
			{	
				soap_flag_tds__SetDNS--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetDNS(struct soap *soap, const struct __tds__SetDNS *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetDNS(soap, tag?tag:"-tds:SetDNS", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDNS * SOAP_FMAC4 soap_get___tds__SetDNS(struct soap *soap, struct __tds__SetDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDNS(struct soap *soap, struct __tds__GetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDNS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDNS(struct soap *soap, const struct __tds__GetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetDNS(soap, &a->tds__GetDNS);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDNS(struct soap *soap, const char *tag, int id, const struct __tds__GetDNS *a, const char *type)
{
	if (soap_out_PointerTo_tds__GetDNS(soap, "tds:GetDNS", -1, &a->tds__GetDNS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDNS * SOAP_FMAC4 soap_in___tds__GetDNS(struct soap *soap, const char *tag, struct __tds__GetDNS *a, const char *type)
{
	size_t soap_flag_tds__GetDNS = 1;
	short soap_flag;
	a = (struct __tds__GetDNS *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDNS, sizeof(struct __tds__GetDNS), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___tds__GetDNS(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__GetDNS && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__GetDNS(soap, "tds:GetDNS", &a->tds__GetDNS, ""))
			{	
				soap_flag_tds__GetDNS--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDNS(struct soap *soap, const struct __tds__GetDNS *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetDNS(soap, tag?tag:"-tds:GetDNS", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDNS * SOAP_FMAC4 soap_get___tds__GetDNS(struct soap *soap, struct __tds__GetDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDNSResponse(struct soap *soap, struct _tds__SetDNSResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDNSResponse))
		soap_serialize__tds__SetDNSResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDNSResponse(struct soap *soap, const char *tag, int id, struct _tds__SetDNSResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDNSResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetDNSResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetDNSResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDNSResponse(struct soap *soap, const char *tag, struct _tds__SetDNSResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetDNSResponse **)soap_malloc(soap, sizeof(struct _tds__SetDNSResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in__tds__SetDNSResponse(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct _tds__SetDNSResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDNSResponse, sizeof(struct _tds__SetDNSResponse), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDNSResponse(struct soap *soap, struct _tds__SetDNSResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDNSResponse);
	if (soap_out_PointerTo_tds__SetDNSResponse(soap, tag?tag:"tds:SetDNSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDNSResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDNSResponse(struct soap *soap, struct _tds__SetDNSResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDNS(struct soap *soap, struct _tds__SetDNS *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDNS))
		soap_serialize__tds__SetDNS(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDNS(struct soap *soap, const char *tag, int id, struct _tds__SetDNS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDNS);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetDNS(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetDNS ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDNS(struct soap *soap, const char *tag, struct _tds__SetDNS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetDNS **)soap_malloc(soap, sizeof(struct _tds__SetDNS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in__tds__SetDNS(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct _tds__SetDNS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDNS, sizeof(struct _tds__SetDNS), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDNS(struct soap *soap, struct _tds__SetDNS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDNS);
	if (soap_out_PointerTo_tds__SetDNS(soap, tag?tag:"tds:SetDNS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDNS ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDNS(struct soap *soap, struct _tds__SetDNS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDNSResponse(struct soap *soap, struct _tds__GetDNSResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDNSResponse))
		soap_serialize__tds__GetDNSResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDNSResponse(struct soap *soap, const char *tag, int id, struct _tds__GetDNSResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDNSResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDNSResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDNSResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDNSResponse(struct soap *soap, const char *tag, struct _tds__GetDNSResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__GetDNSResponse **)soap_malloc(soap, sizeof(struct _tds__GetDNSResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__GetDNSResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetDNSResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDNSResponse, sizeof(struct _tds__GetDNSResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDNSResponse(struct soap *soap, struct _tds__GetDNSResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDNSResponse);
	if (soap_out_PointerTo_tds__GetDNSResponse(soap, tag?tag:"tds:GetDNSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDNSResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDNSResponse(struct soap *soap, struct _tds__GetDNSResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDNS(struct soap *soap, struct _tds__GetDNS *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDNS))
		soap_serialize__tds__GetDNS(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDNS(struct soap *soap, const char *tag, int id, struct _tds__GetDNS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDNS);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDNS(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDNS ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDNS(struct soap *soap, const char *tag, struct _tds__GetDNS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__GetDNS **)soap_malloc(soap, sizeof(struct _tds__GetDNS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__GetDNS(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetDNS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDNS, sizeof(struct _tds__GetDNS), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDNS(struct soap *soap, struct _tds__GetDNS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDNS);
	if (soap_out_PointerTo_tds__GetDNS(soap, tag?tag:"tds:GetDNS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDNS ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDNS(struct soap *soap, struct _tds__GetDNS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDNSResponse(struct soap *soap, struct _tds__SetDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDNSResponse(struct soap *soap, const struct _tds__SetDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDNSResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetDNSResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDNSResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDNSResponse * SOAP_FMAC4 soap_in__tds__SetDNSResponse(struct soap *soap, const char *tag, struct _tds__SetDNSResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetDNSResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDNSResponse, sizeof(struct _tds__SetDNSResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__SetDNSResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDNSResponse, 0, sizeof(struct _tds__SetDNSResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDNSResponse(struct soap *soap, const struct _tds__SetDNSResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetDNSResponse);
	if (soap_out__tds__SetDNSResponse(soap, tag?tag:"tds:SetDNSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDNSResponse * SOAP_FMAC4 soap_get__tds__SetDNSResponse(struct soap *soap, struct _tds__SetDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}



SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDNS(struct soap *soap, struct _tds__SetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->FromDHCP);
	a->__sizeSearchDomain = 0;
	a->SearchDomain = NULL;
	a->__sizeDNSManual = 0;
	a->DNSManual = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDNS(struct soap *soap, const struct _tds__SetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->FromDHCP, SOAP_TYPE_xsd__boolean_);
	if (a->SearchDomain)
	{	
		int i;
		for (i = 0; i < a->__sizeSearchDomain; i++)
		{
			soap_serialize_xsd__token(soap, a->SearchDomain + i);
		}
	}
	if (a->DNSManual)
	{	
		int i;
		for (i = 0; i < a->__sizeDNSManual; i++)
		{
			soap_embedded(soap, a->DNSManual + i, SOAP_TYPE_tt__IPAddress);
			soap_serialize_tt__IPAddress(soap, a->DNSManual + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDNS(struct soap *soap, const char *tag, int id, const struct _tds__SetDNS *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDNS), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tds:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	if (a->SearchDomain)
	{	
		int i;
		for (i = 0; i < a->__sizeSearchDomain; i++)
			if (soap_out_xsd__token(soap, "tds:SearchDomain", -1, a->SearchDomain + i, ""))
				return soap->error;
	}
	if (a->DNSManual)
	{	
		int i;
		for (i = 0; i < a->__sizeDNSManual; i++)
			if (soap_out_tt__IPAddress(soap, "tds:DNSManual", -1, a->DNSManual + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDNS * SOAP_FMAC4 soap_in__tds__SetDNS(struct soap *soap, const char *tag, struct _tds__SetDNS *a, const char *type)
{
	size_t soap_flag_FromDHCP = 1;
	struct soap_blist *soap_blist_SearchDomain = NULL;
	struct soap_blist *soap_blist_DNSManual = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetDNS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDNS, sizeof(struct _tds__SetDNS), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__SetDNS(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tds:FromDHCP", &a->FromDHCP, "xsd:boolean"))
				{	
					soap_flag_FromDHCP--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:SearchDomain", 1, NULL))
				{	
					if (a->SearchDomain == NULL)
					{	
						if (soap_blist_SearchDomain == NULL)
							soap_blist_SearchDomain = soap_new_block(soap);
						a->SearchDomain = (char **)soap_push_block(soap, soap_blist_SearchDomain, sizeof(char *));
						if (a->SearchDomain == NULL)
							return NULL;
						*a->SearchDomain = NULL;
					}
					soap_revert(soap);
					if (soap_in_xsd__token(soap, "tds:SearchDomain", a->SearchDomain, "xsd:token"))
					{	
						a->__sizeSearchDomain++;
						a->SearchDomain = NULL;
						continue;
					}
				}
				if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:DNSManual", 1, NULL))
				{	
					if (a->DNSManual == NULL)
					{	
						if (soap_blist_DNSManual == NULL)
							soap_blist_DNSManual = soap_new_block(soap);
						a->DNSManual = (struct tt__IPAddress *)soap_push_block(soap, soap_blist_DNSManual, sizeof(struct tt__IPAddress));
						if (a->DNSManual == NULL)
							return NULL;
						soap_default_tt__IPAddress(soap, a->DNSManual);
					}
					soap_revert(soap);
					if (soap_in_tt__IPAddress(soap, "tds:DNSManual", a->DNSManual, "tt:IPAddress"))
					{	
						a->__sizeDNSManual++;
						a->DNSManual = NULL;
						continue;
					}
				}
				if (soap->error == SOAP_TAG_MISMATCH)
					soap->error = soap_ignore_element(soap);
				if (soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
		}
		if (a->SearchDomain)
			soap_pop_block(soap, soap_blist_SearchDomain);
		if (a->__sizeSearchDomain)
			a->SearchDomain = (char **)soap_save_block(soap, soap_blist_SearchDomain, NULL, 1);
		else
		{	
			a->SearchDomain = NULL;
			if (soap_blist_SearchDomain)
				soap_end_block(soap, soap_blist_SearchDomain);
		}
		if (a->DNSManual)
			soap_pop_block(soap, soap_blist_DNSManual);
		if (a->__sizeDNSManual)
			a->DNSManual = (struct tt__IPAddress *)soap_save_block(soap, soap_blist_DNSManual, NULL, 1);
		else
		{	
			a->DNSManual = NULL;
			if (soap_blist_DNSManual)
				soap_end_block(soap, soap_blist_DNSManual);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDNS, 0, sizeof(struct _tds__SetDNS), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDNS(struct soap *soap, const struct _tds__SetDNS *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetDNS);
	if (soap_out__tds__SetDNS(soap, tag?tag:"tds:SetDNS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDNS * SOAP_FMAC4 soap_get__tds__SetDNS(struct soap *soap, struct _tds__SetDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DNSInformation(struct soap *soap, struct tt__DNSInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->FromDHCP);
	a->__sizeSearchDomain = 0;
	a->SearchDomain = NULL;
	a->__sizeDNSFromDHCP = 0;
	a->DNSFromDHCP = NULL;
	a->__sizeDNSManual = 0;
	a->DNSManual = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DNSInformation(struct soap *soap, const struct tt__DNSInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->FromDHCP, SOAP_TYPE_xsd__boolean_);
	if (a->SearchDomain)
	{	
		int i;
		for (i = 0; i < a->__sizeSearchDomain; i++)
		{
			soap_serialize_xsd__token(soap, a->SearchDomain + i);
		}
	}
	if (a->DNSFromDHCP)
	{	
		int i;
		for (i = 0; i < a->__sizeDNSFromDHCP; i++)
		{
			soap_embedded(soap, a->DNSFromDHCP + i, SOAP_TYPE_tt__IPAddress);
			soap_serialize_tt__IPAddress(soap, a->DNSFromDHCP + i);
		}
	}
	if (a->DNSManual)
	{	
		int i;
		for (i = 0; i < a->__sizeDNSManual; i++)
		{
			soap_embedded(soap, a->DNSManual + i, SOAP_TYPE_tt__IPAddress);
			soap_serialize_tt__IPAddress(soap, a->DNSManual + i);
		}
	}
	soap_serialize_PointerTott__DNSInformationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DNSInformation(struct soap *soap, const char *tag, int id, const struct tt__DNSInformation *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DNSInformation), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	if (a->SearchDomain)
	{	
		int i;
		for (i = 0; i < a->__sizeSearchDomain; i++)
			if (soap_out_xsd__token(soap, "tt:SearchDomain", -1, a->SearchDomain + i, ""))
				return soap->error;
	}
	if (a->DNSFromDHCP)
	{	
		int i;
		for (i = 0; i < a->__sizeDNSFromDHCP; i++)
			if (soap_out_tt__IPAddress(soap, "tt:DNSFromDHCP", -1, a->DNSFromDHCP + i, ""))
				return soap->error;
	}
	if (a->DNSManual)
	{	
		int i;
		for (i = 0; i < a->__sizeDNSManual; i++)
			if (soap_out_tt__IPAddress(soap, "tt:DNSManual", -1, a->DNSManual + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__DNSInformationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DNSInformation * SOAP_FMAC4 soap_in_tt__DNSInformation(struct soap *soap, const char *tag, struct tt__DNSInformation *a, const char *type)
{
	size_t soap_flag_FromDHCP = 1;
	struct soap_blist *soap_blist_SearchDomain = NULL;
	struct soap_blist *soap_blist_DNSFromDHCP = NULL;
	struct soap_blist *soap_blist_DNSManual = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DNSInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DNSInformation, sizeof(struct tt__DNSInformation), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__DNSInformation(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:FromDHCP", &a->FromDHCP, "xsd:boolean"))
				{	
					soap_flag_FromDHCP--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SearchDomain", 1, NULL))
				{	
					if (a->SearchDomain == NULL)
					{	
						if (soap_blist_SearchDomain == NULL)
							soap_blist_SearchDomain = soap_new_block(soap);
						a->SearchDomain = (char **)soap_push_block(soap, soap_blist_SearchDomain, sizeof(char *));
						if (a->SearchDomain == NULL)
							return NULL;
						*a->SearchDomain = NULL;
					}
					soap_revert(soap);
					if (soap_in_xsd__token(soap, "tt:SearchDomain", a->SearchDomain, "xsd:token"))
					{	
						a->__sizeSearchDomain++;
						a->SearchDomain = NULL;
						continue;
					}
				}
				if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:DNSFromDHCP", 1, NULL))
				{	
					if (a->DNSFromDHCP == NULL)
					{	
						if (soap_blist_DNSFromDHCP == NULL)
							soap_blist_DNSFromDHCP = soap_new_block(soap);
						a->DNSFromDHCP = (struct tt__IPAddress *)soap_push_block(soap, soap_blist_DNSFromDHCP, sizeof(struct tt__IPAddress));
						if (a->DNSFromDHCP == NULL)
							return NULL;
						soap_default_tt__IPAddress(soap, a->DNSFromDHCP);
					}
					soap_revert(soap);
					if (soap_in_tt__IPAddress(soap, "tt:DNSFromDHCP", a->DNSFromDHCP, "tt:IPAddress"))
					{	
						a->__sizeDNSFromDHCP++;
						a->DNSFromDHCP = NULL;
						continue;
					}
				}
				if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:DNSManual", 1, NULL))
				{	
					if (a->DNSManual == NULL)
					{	
						if (soap_blist_DNSManual == NULL)
							soap_blist_DNSManual = soap_new_block(soap);
						a->DNSManual = (struct tt__IPAddress *)soap_push_block(soap, soap_blist_DNSManual, sizeof(struct tt__IPAddress));
						if (a->DNSManual == NULL)
							return NULL;
						soap_default_tt__IPAddress(soap, a->DNSManual);
					}
					soap_revert(soap);
					if (soap_in_tt__IPAddress(soap, "tt:DNSManual", a->DNSManual, "tt:IPAddress"))
					{	
						a->__sizeDNSManual++;
						a->DNSManual = NULL;
						continue;
					}
				}
				if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__DNSInformationExtension(soap, "tt:Extension", &a->Extension, "tt:DNSInformationExtension"))
					{	
						soap_flag_Extension--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH)
						soap->error = soap_ignore_element(soap);
					if (soap->error == SOAP_NO_TAG)
						break;
					if (soap->error)
						return NULL;
		}
		if (a->SearchDomain)
			soap_pop_block(soap, soap_blist_SearchDomain);
		if (a->__sizeSearchDomain)
			a->SearchDomain = (char **)soap_save_block(soap, soap_blist_SearchDomain, NULL, 1);
		else
		{
			a->SearchDomain = NULL;
			if (soap_blist_SearchDomain)
				soap_end_block(soap, soap_blist_SearchDomain);
		}
		if (a->DNSFromDHCP)
			soap_pop_block(soap, soap_blist_DNSFromDHCP);
		if (a->__sizeDNSFromDHCP)
			a->DNSFromDHCP = (struct tt__IPAddress *)soap_save_block(soap, soap_blist_DNSFromDHCP, NULL, 1);
		else
		{	
			a->DNSFromDHCP = NULL;
			if (soap_blist_DNSFromDHCP)
				soap_end_block(soap, soap_blist_DNSFromDHCP);
		}
		if (a->DNSManual)
			soap_pop_block(soap, soap_blist_DNSManual);
		if (a->__sizeDNSManual)
			a->DNSManual = (struct tt__IPAddress *)soap_save_block(soap, soap_blist_DNSManual, NULL, 1);
		else
		{	
			a->DNSManual = NULL;
			if (soap_blist_DNSManual)
				soap_end_block(soap, soap_blist_DNSManual);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__DNSInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DNSInformation, 0, sizeof(struct tt__DNSInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DNSInformation(struct soap *soap, const struct tt__DNSInformation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__DNSInformation);
	if (soap_out_tt__DNSInformation(soap, tag?tag:"tt:DNSInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DNSInformation * SOAP_FMAC4 soap_get_tt__DNSInformation(struct soap *soap, struct tt__DNSInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDNSResponse(struct soap *soap, struct _tds__GetDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DNSInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDNSResponse(struct soap *soap, const struct _tds__GetDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__DNSInformation(soap, &a->DNSInformation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDNSResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDNSResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDNSResponse), type))
		return soap->error;
	if (a->DNSInformation)
		soap_element_result(soap, "tds:DNSInformation");
	if (a->DNSInformation)
	{	
		if (soap_out_PointerTott__DNSInformation(soap, "tds:DNSInformation", -1, &a->DNSInformation, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:DNSInformation"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDNSResponse * SOAP_FMAC4 soap_in__tds__GetDNSResponse(struct soap *soap, const char *tag, struct _tds__GetDNSResponse *a, const char *type)
{
	size_t soap_flag_DNSInformation = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDNSResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDNSResponse, sizeof(struct _tds__GetDNSResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__GetDNSResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DNSInformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DNSInformation(soap, "tds:DNSInformation", &a->DNSInformation, "tt:DNSInformation"))
				{	
					soap_flag_DNSInformation--;
					continue;
				}
				soap_check_result(soap, "tds:DNSInformation");
				if (soap->error == SOAP_TAG_MISMATCH)
					soap->error = soap_ignore_element(soap);
				if (soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDNSResponse, 0, sizeof(struct _tds__GetDNSResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DNSInformation > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDNSResponse(struct soap *soap, const struct _tds__GetDNSResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDNSResponse);
	if (soap_out__tds__GetDNSResponse(soap, tag?tag:"tds:GetDNSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDNSResponse * SOAP_FMAC4 soap_get__tds__GetDNSResponse(struct soap *soap, struct _tds__GetDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDNS(struct soap *soap, struct _tds__GetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDNS(struct soap *soap, const struct _tds__GetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDNS(struct soap *soap, const char *tag, int id, const struct _tds__GetDNS *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDNS), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDNS * SOAP_FMAC4 soap_in__tds__GetDNS(struct soap *soap, const char *tag, struct _tds__GetDNS *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDNS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDNS, sizeof(struct _tds__GetDNS), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__GetDNS(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDNS, 0, sizeof(struct _tds__GetDNS), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDNS(struct soap *soap, const struct _tds__GetDNS *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDNS);
	if (soap_out__tds__GetDNS(soap, tag?tag:"tds:GetDNS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDNS * SOAP_FMAC4 soap_get__tds__GetDNS(struct soap *soap, struct _tds__GetDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DNSInformationExtension(struct soap *soap, struct tt__DNSInformationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DNSInformationExtension))
		soap_serialize_tt__DNSInformationExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DNSInformationExtension(struct soap *soap, const char *tag, int id, struct tt__DNSInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DNSInformationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DNSInformationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DNSInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__DNSInformationExtension(struct soap *soap, const char *tag, struct tt__DNSInformationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__DNSInformationExtension **)soap_malloc(soap, sizeof(struct tt__DNSInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__DNSInformationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{
		a = (struct tt__DNSInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DNSInformationExtension, sizeof(struct tt__DNSInformationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DNSInformationExtension(struct soap *soap, struct tt__DNSInformationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__DNSInformationExtension);
	if (soap_out_PointerTott__DNSInformationExtension(soap, tag?tag:"tt:DNSInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DNSInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__DNSInformationExtension(struct soap *soap, struct tt__DNSInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DNSInformation(struct soap *soap, struct tt__DNSInformation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DNSInformation))
		soap_serialize_tt__DNSInformation(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DNSInformation(struct soap *soap, const char *tag, int id, struct tt__DNSInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DNSInformation);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DNSInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DNSInformation ** SOAP_FMAC4 soap_in_PointerTott__DNSInformation(struct soap *soap, const char *tag, struct tt__DNSInformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__DNSInformation **)soap_malloc(soap, sizeof(struct tt__DNSInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__DNSInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__DNSInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DNSInformation, sizeof(struct tt__DNSInformation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DNSInformation(struct soap *soap, struct tt__DNSInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__DNSInformation);
	if (soap_out_PointerTott__DNSInformation(soap, tag?tag:"tt:DNSInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DNSInformation ** SOAP_FMAC4 soap_get_PointerTott__DNSInformation(struct soap *soap, struct tt__DNSInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DNSInformationExtension(struct soap *soap, struct tt__DNSInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DNSInformationExtension(struct soap *soap, const struct tt__DNSInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DNSInformationExtension(struct soap *soap, const char *tag, int id, const struct tt__DNSInformationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DNSInformationExtension), type))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DNSInformationExtension * SOAP_FMAC4 soap_in_tt__DNSInformationExtension(struct soap *soap, const char *tag, struct tt__DNSInformationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DNSInformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DNSInformationExtension, sizeof(struct tt__DNSInformationExtension), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__DNSInformationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__DNSInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DNSInformationExtension, 0, sizeof(struct tt__DNSInformationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DNSInformationExtension(struct soap *soap, const struct tt__DNSInformationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__DNSInformationExtension);
	if (soap_out_tt__DNSInformationExtension(soap, tag?tag:"tt:DNSInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DNSInformationExtension * SOAP_FMAC4 soap_get_tt__DNSInformationExtension(struct soap *soap, struct tt__DNSInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetNetworkDefaultGateway(struct soap *soap, struct __tds__SetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetNetworkDefaultGateway = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetNetworkDefaultGateway(struct soap *soap, const struct __tds__SetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetNetworkDefaultGateway(soap, &a->tds__SetNetworkDefaultGateway);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, const struct __tds__SetNetworkDefaultGateway *a, const char *type)
{
	if (soap_out_PointerTo_tds__SetNetworkDefaultGateway(soap, "tds:SetNetworkDefaultGateway", -1, &a->tds__SetNetworkDefaultGateway, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkDefaultGateway * SOAP_FMAC4 soap_in___tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, struct __tds__SetNetworkDefaultGateway *a, const char *type)
{
	size_t soap_flag_tds__SetNetworkDefaultGateway = 1;
	short soap_flag;
	a = (struct __tds__SetNetworkDefaultGateway *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetNetworkDefaultGateway, sizeof(struct __tds__SetNetworkDefaultGateway), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___tds__SetNetworkDefaultGateway(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__SetNetworkDefaultGateway && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__SetNetworkDefaultGateway(soap, "tds:SetNetworkDefaultGateway", &a->tds__SetNetworkDefaultGateway, ""))
			{	
				soap_flag_tds__SetNetworkDefaultGateway--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetNetworkDefaultGateway(struct soap *soap, const struct __tds__SetNetworkDefaultGateway *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetNetworkDefaultGateway(soap, tag?tag:"-tds:SetNetworkDefaultGateway", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkDefaultGateway * SOAP_FMAC4 soap_get___tds__SetNetworkDefaultGateway(struct soap *soap, struct __tds__SetNetworkDefaultGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetNetworkDefaultGateway(struct soap *soap, struct __tds__GetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetNetworkDefaultGateway = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetNetworkDefaultGateway(struct soap *soap, const struct __tds__GetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetNetworkDefaultGateway(soap, &a->tds__GetNetworkDefaultGateway);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, const struct __tds__GetNetworkDefaultGateway *a, const char *type)
{
	if (soap_out_PointerTo_tds__GetNetworkDefaultGateway(soap, "tds:GetNetworkDefaultGateway", -1, &a->tds__GetNetworkDefaultGateway, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkDefaultGateway * SOAP_FMAC4 soap_in___tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, struct __tds__GetNetworkDefaultGateway *a, const char *type)
{
	size_t soap_flag_tds__GetNetworkDefaultGateway = 1;
	short soap_flag;
	a = (struct __tds__GetNetworkDefaultGateway *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetNetworkDefaultGateway, sizeof(struct __tds__GetNetworkDefaultGateway), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___tds__GetNetworkDefaultGateway(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__GetNetworkDefaultGateway && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__GetNetworkDefaultGateway(soap, "tds:GetNetworkDefaultGateway", &a->tds__GetNetworkDefaultGateway, ""))
			{	
				soap_flag_tds__GetNetworkDefaultGateway--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetNetworkDefaultGateway(struct soap *soap, const struct __tds__GetNetworkDefaultGateway *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetNetworkDefaultGateway(soap, tag?tag:"-tds:GetNetworkDefaultGateway", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkDefaultGateway * SOAP_FMAC4 soap_get___tds__GetNetworkDefaultGateway(struct soap *soap, struct __tds__GetNetworkDefaultGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__SetNetworkDefaultGatewayResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse))
		soap_serialize__tds__SetNetworkDefaultGatewayResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, int id, struct _tds__SetNetworkDefaultGatewayResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetNetworkDefaultGatewayResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGatewayResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, struct _tds__SetNetworkDefaultGatewayResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetNetworkDefaultGatewayResponse **)soap_malloc(soap, sizeof(struct _tds__SetNetworkDefaultGatewayResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
	if (!(*a = soap_in__tds__SetNetworkDefaultGatewayResponse(soap, tag, *a, type)))
		return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkDefaultGatewayResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, sizeof(struct _tds__SetNetworkDefaultGatewayResponse), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__SetNetworkDefaultGatewayResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNetworkDefaultGatewayResponse);
	if (soap_out_PointerTo_tds__SetNetworkDefaultGatewayResponse(soap, tag?tag:"tds:SetNetworkDefaultGatewayResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGatewayResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__SetNetworkDefaultGatewayResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkDefaultGatewayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, struct _tds__SetNetworkDefaultGateway *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkDefaultGateway))
		soap_serialize__tds__SetNetworkDefaultGateway(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, struct _tds__SetNetworkDefaultGateway *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkDefaultGateway);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetNetworkDefaultGateway(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGateway ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, struct _tds__SetNetworkDefaultGateway **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__SetNetworkDefaultGateway **)soap_malloc(soap, sizeof(struct _tds__SetNetworkDefaultGateway *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__SetNetworkDefaultGateway(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetNetworkDefaultGateway **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkDefaultGateway, sizeof(struct _tds__SetNetworkDefaultGateway), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, struct _tds__SetNetworkDefaultGateway *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNetworkDefaultGateway);
	if (soap_out_PointerTo_tds__SetNetworkDefaultGateway(soap, tag?tag:"tds:SetNetworkDefaultGateway", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGateway ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, struct _tds__SetNetworkDefaultGateway **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__GetNetworkDefaultGatewayResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse))
		soap_serialize__tds__GetNetworkDefaultGatewayResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, int id, struct _tds__GetNetworkDefaultGatewayResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetNetworkDefaultGatewayResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGatewayResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, struct _tds__GetNetworkDefaultGatewayResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__GetNetworkDefaultGatewayResponse **)soap_malloc(soap, sizeof(struct _tds__GetNetworkDefaultGatewayResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{
		soap_revert(soap);
		if (!(*a = soap_in__tds__GetNetworkDefaultGatewayResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetNetworkDefaultGatewayResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, sizeof(struct _tds__GetNetworkDefaultGatewayResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__GetNetworkDefaultGatewayResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNetworkDefaultGatewayResponse);
	if (soap_out_PointerTo_tds__GetNetworkDefaultGatewayResponse(soap, tag?tag:"tds:GetNetworkDefaultGatewayResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGatewayResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__GetNetworkDefaultGatewayResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkDefaultGatewayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, struct _tds__GetNetworkDefaultGateway *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkDefaultGateway))
		soap_serialize__tds__GetNetworkDefaultGateway(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, struct _tds__GetNetworkDefaultGateway *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkDefaultGateway);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetNetworkDefaultGateway(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGateway ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, struct _tds__GetNetworkDefaultGateway **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__GetNetworkDefaultGateway **)soap_malloc(soap, sizeof(struct _tds__GetNetworkDefaultGateway *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__GetNetworkDefaultGateway(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetNetworkDefaultGateway **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkDefaultGateway, sizeof(struct _tds__GetNetworkDefaultGateway), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, struct _tds__GetNetworkDefaultGateway *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNetworkDefaultGateway);
	if (soap_out_PointerTo_tds__GetNetworkDefaultGateway(soap, tag?tag:"tds:GetNetworkDefaultGateway", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGateway ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, struct _tds__GetNetworkDefaultGateway **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__SetNetworkDefaultGatewayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const struct _tds__SetNetworkDefaultGatewayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetNetworkDefaultGatewayResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_in__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, struct _tds__SetNetworkDefaultGatewayResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetNetworkDefaultGatewayResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, sizeof(struct _tds__SetNetworkDefaultGatewayResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__SetNetworkDefaultGatewayResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetNetworkDefaultGatewayResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, 0, sizeof(struct _tds__SetNetworkDefaultGatewayResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const struct _tds__SetNetworkDefaultGatewayResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse);
	if (soap_out__tds__SetNetworkDefaultGatewayResponse(soap, tag?tag:"tds:SetNetworkDefaultGatewayResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_get__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__SetNetworkDefaultGatewayResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkDefaultGatewayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNetworkDefaultGateway(struct soap *soap, struct _tds__SetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeIPv4Address = 0;
	a->IPv4Address = NULL;
	a->__sizeIPv6Address = 0;
	a->IPv6Address = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNetworkDefaultGateway(struct soap *soap, const struct _tds__SetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->IPv4Address)
	{	
		int i;
		for (i = 0; i < a->__sizeIPv4Address; i++)
		{
			soap_serialize_tt__IPv4Address(soap, a->IPv4Address + i);
		}
	}
	if (a->IPv6Address)
	{	
		int i;
		for (i = 0; i < a->__sizeIPv6Address; i++)
		{
			soap_serialize_tt__IPv6Address(soap, a->IPv6Address + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, const struct _tds__SetNetworkDefaultGateway *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkDefaultGateway), type))
		return soap->error;
	if (a->IPv4Address)
	{	
		int i;
		for (i = 0; i < a->__sizeIPv4Address; i++)
			if (soap_out_tt__IPv4Address(soap, "tds:IPv4Address", -1, a->IPv4Address + i, ""))
				return soap->error;
	}
	if (a->IPv6Address)
	{	
		int i;
		for (i = 0; i < a->__sizeIPv6Address; i++)
			if (soap_out_tt__IPv6Address(soap, "tds:IPv6Address", -1, a->IPv6Address + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGateway * SOAP_FMAC4 soap_in__tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, struct _tds__SetNetworkDefaultGateway *a, const char *type)
{
	struct soap_blist *soap_blist_IPv4Address = NULL;
	struct soap_blist *soap_blist_IPv6Address = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetNetworkDefaultGateway *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkDefaultGateway, sizeof(struct _tds__SetNetworkDefaultGateway), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__SetNetworkDefaultGateway(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:IPv4Address", 1, NULL))
			{	
				if (a->IPv4Address == NULL)
				{	
					if (soap_blist_IPv4Address == NULL)
						soap_blist_IPv4Address = soap_new_block(soap);
					a->IPv4Address = (char **)soap_push_block(soap, soap_blist_IPv4Address, sizeof(char *));
					if (a->IPv4Address == NULL)
						return NULL;
					*a->IPv4Address = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__IPv4Address(soap, "tds:IPv4Address", a->IPv4Address, "tt:IPv4Address"))
				{	
					a->__sizeIPv4Address++;
					a->IPv4Address = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:IPv6Address", 1, NULL))
			{	
				if (a->IPv6Address == NULL)
				{	
					if (soap_blist_IPv6Address == NULL)
						soap_blist_IPv6Address = soap_new_block(soap);
					a->IPv6Address = (char **)soap_push_block(soap, soap_blist_IPv6Address, sizeof(char *));
					if (a->IPv6Address == NULL)
						return NULL;
					*a->IPv6Address = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__IPv6Address(soap, "tds:IPv6Address", a->IPv6Address, "tt:IPv6Address"))
				{	
					a->__sizeIPv6Address++;
					a->IPv6Address = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->IPv4Address)
			soap_pop_block(soap, soap_blist_IPv4Address);
		if (a->__sizeIPv4Address)
			a->IPv4Address = (char **)soap_save_block(soap, soap_blist_IPv4Address, NULL, 1);
		else
		{	
			a->IPv4Address = NULL;
			if (soap_blist_IPv4Address)
				soap_end_block(soap, soap_blist_IPv4Address);
		}
		if (a->IPv6Address)
			soap_pop_block(soap, soap_blist_IPv6Address);
		if (a->__sizeIPv6Address)
			a->IPv6Address = (char **)soap_save_block(soap, soap_blist_IPv6Address, NULL, 1);
		else
		{	
			a->IPv6Address = NULL;
			if (soap_blist_IPv6Address)
				soap_end_block(soap, soap_blist_IPv6Address);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetNetworkDefaultGateway *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkDefaultGateway, 0, sizeof(struct _tds__SetNetworkDefaultGateway), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNetworkDefaultGateway(struct soap *soap, const struct _tds__SetNetworkDefaultGateway *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetNetworkDefaultGateway);
	if (soap_out__tds__SetNetworkDefaultGateway(soap, tag?tag:"tds:SetNetworkDefaultGateway", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGateway * SOAP_FMAC4 soap_get__tds__SetNetworkDefaultGateway(struct soap *soap, struct _tds__SetNetworkDefaultGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkGateway(struct soap *soap, struct tt__NetworkGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeIPv4Address = 0;
	a->IPv4Address = NULL;
	a->__sizeIPv6Address = 0;
	a->IPv6Address = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkGateway(struct soap *soap, const struct tt__NetworkGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->IPv4Address)
	{	
		int i;
		for (i = 0; i < a->__sizeIPv4Address; i++)
		{
			soap_serialize_tt__IPv4Address(soap, a->IPv4Address + i);
		}
	}
	if (a->IPv6Address)
	{	
		int i;
		for (i = 0; i < a->__sizeIPv6Address; i++)
		{
			soap_serialize_tt__IPv6Address(soap, a->IPv6Address + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkGateway(struct soap *soap, const char *tag, int id, const struct tt__NetworkGateway *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkGateway), type))
		return soap->error;
	if (a->IPv4Address)
	{	
		int i;
		for (i = 0; i < a->__sizeIPv4Address; i++)
			if (soap_out_tt__IPv4Address(soap, "tt:IPv4Address", -1, a->IPv4Address + i, ""))
				return soap->error;
	}
	if (a->IPv6Address)
	{	
		int i;
		for (i = 0; i < a->__sizeIPv6Address; i++)
			if (soap_out_tt__IPv6Address(soap, "tt:IPv6Address", -1, a->IPv6Address + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkGateway * SOAP_FMAC4 soap_in_tt__NetworkGateway(struct soap *soap, const char *tag, struct tt__NetworkGateway *a, const char *type)
{
	struct soap_blist *soap_blist_IPv4Address = NULL;
	struct soap_blist *soap_blist_IPv6Address = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkGateway *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkGateway, sizeof(struct tt__NetworkGateway), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__NetworkGateway(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IPv4Address", 1, NULL))
			{	
				if (a->IPv4Address == NULL)
				{	
					if (soap_blist_IPv4Address == NULL)
						soap_blist_IPv4Address = soap_new_block(soap);
					a->IPv4Address = (char **)soap_push_block(soap, soap_blist_IPv4Address, sizeof(char *));
					if (a->IPv4Address == NULL)
						return NULL;
					*a->IPv4Address = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__IPv4Address(soap, "tt:IPv4Address", a->IPv4Address, "tt:IPv4Address"))
				{	
					a->__sizeIPv4Address++;
					a->IPv4Address = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IPv6Address", 1, NULL))
			{	
				if (a->IPv6Address == NULL)
				{	
					if (soap_blist_IPv6Address == NULL)
						soap_blist_IPv6Address = soap_new_block(soap);
					a->IPv6Address = (char **)soap_push_block(soap, soap_blist_IPv6Address, sizeof(char *));
					if (a->IPv6Address == NULL)
						return NULL;
					*a->IPv6Address = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__IPv6Address(soap, "tt:IPv6Address", a->IPv6Address, "tt:IPv6Address"))
				{	
					a->__sizeIPv6Address++;
					a->IPv6Address = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->IPv4Address)
			soap_pop_block(soap, soap_blist_IPv4Address);
		if (a->__sizeIPv4Address)
			a->IPv4Address = (char **)soap_save_block(soap, soap_blist_IPv4Address, NULL, 1);
		else
		{	
			a->IPv4Address = NULL;
			if (soap_blist_IPv4Address)
				soap_end_block(soap, soap_blist_IPv4Address);
		}
		if (a->IPv6Address)
			soap_pop_block(soap, soap_blist_IPv6Address);
		if (a->__sizeIPv6Address)
			a->IPv6Address = (char **)soap_save_block(soap, soap_blist_IPv6Address, NULL, 1);
		else
		{	
			a->IPv6Address = NULL;
			if (soap_blist_IPv6Address)
				soap_end_block(soap, soap_blist_IPv6Address);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__NetworkGateway *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkGateway, 0, sizeof(struct tt__NetworkGateway), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}	
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkGateway(struct soap *soap, const struct tt__NetworkGateway *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkGateway);
	if (soap_out_tt__NetworkGateway(soap, tag?tag:"tt:NetworkGateway", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkGateway * SOAP_FMAC4 soap_get_tt__NetworkGateway(struct soap *soap, struct tt__NetworkGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__GetNetworkDefaultGatewayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->NetworkGateway = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const struct _tds__GetNetworkDefaultGatewayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__NetworkGateway(soap, &a->NetworkGateway);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetNetworkDefaultGatewayResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse), type))
		return soap->error;
	if (a->NetworkGateway)
		soap_element_result(soap, "tds:NetworkGateway");
	if (a->NetworkGateway)
	{	
		if (soap_out_PointerTott__NetworkGateway(soap, "tds:NetworkGateway", -1, &a->NetworkGateway, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:NetworkGateway"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_in__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, struct _tds__GetNetworkDefaultGatewayResponse *a, const char *type)
{
	size_t soap_flag_NetworkGateway = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetNetworkDefaultGatewayResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, sizeof(struct _tds__GetNetworkDefaultGatewayResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__GetNetworkDefaultGatewayResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NetworkGateway && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkGateway(soap, "tds:NetworkGateway", &a->NetworkGateway, "tt:NetworkGateway"))
				{	
					soap_flag_NetworkGateway--;
					continue;
				}
				soap_check_result(soap, "tds:NetworkGateway");
				if (soap->error == SOAP_TAG_MISMATCH)
					soap->error = soap_ignore_element(soap);
				if (soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetNetworkDefaultGatewayResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, 0, sizeof(struct _tds__GetNetworkDefaultGatewayResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_NetworkGateway > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const struct _tds__GetNetworkDefaultGatewayResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse);
	if (soap_out__tds__GetNetworkDefaultGatewayResponse(soap, tag?tag:"tds:GetNetworkDefaultGatewayResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_get__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__GetNetworkDefaultGatewayResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkDefaultGatewayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNetworkDefaultGateway(struct soap *soap, struct _tds__GetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNetworkDefaultGateway(struct soap *soap, const struct _tds__GetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, const struct _tds__GetNetworkDefaultGateway *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkDefaultGateway), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGateway * SOAP_FMAC4 soap_in__tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, struct _tds__GetNetworkDefaultGateway *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetNetworkDefaultGateway *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkDefaultGateway, sizeof(struct _tds__GetNetworkDefaultGateway), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__GetNetworkDefaultGateway(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetNetworkDefaultGateway *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkDefaultGateway, 0, sizeof(struct _tds__GetNetworkDefaultGateway), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNetworkDefaultGateway(struct soap *soap, const struct _tds__GetNetworkDefaultGateway *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetNetworkDefaultGateway);
	if (soap_out__tds__GetNetworkDefaultGateway(soap, tag?tag:"tds:GetNetworkDefaultGateway", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGateway * SOAP_FMAC4 soap_get__tds__GetNetworkDefaultGateway(struct soap *soap, struct _tds__GetNetworkDefaultGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkGateway(struct soap *soap, struct tt__NetworkGateway *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkGateway))
		soap_serialize_tt__NetworkGateway(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkGateway(struct soap *soap, const char *tag, int id, struct tt__NetworkGateway *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkGateway);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkGateway(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkGateway ** SOAP_FMAC4 soap_in_PointerTott__NetworkGateway(struct soap *soap, const char *tag, struct tt__NetworkGateway **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__NetworkGateway **)soap_malloc(soap, sizeof(struct tt__NetworkGateway *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkGateway(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__NetworkGateway **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkGateway, sizeof(struct tt__NetworkGateway), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkGateway(struct soap *soap, struct tt__NetworkGateway *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkGateway);
	if (soap_out_PointerTott__NetworkGateway(soap, tag?tag:"tt:NetworkGateway", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkGateway ** SOAP_FMAC4 soap_get_PointerTott__NetworkGateway(struct soap *soap, struct tt__NetworkGateway **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetNTP(struct soap *soap, struct __tds__SetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetNTP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetNTP(struct soap *soap, const struct __tds__SetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetNTP(soap, &a->tds__SetNTP);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetNTP(struct soap *soap, const char *tag, int id, const struct __tds__SetNTP *a, const char *type)
{
	if (soap_out_PointerTo_tds__SetNTP(soap, "tds:SetNTP", -1, &a->tds__SetNTP, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNTP * SOAP_FMAC4 soap_in___tds__SetNTP(struct soap *soap, const char *tag, struct __tds__SetNTP *a, const char *type)
{
	size_t soap_flag_tds__SetNTP = 1;
	short soap_flag;
	a = (struct __tds__SetNTP *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetNTP, sizeof(struct __tds__SetNTP), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___tds__SetNTP(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__SetNTP && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__SetNTP(soap, "tds:SetNTP", &a->tds__SetNTP, ""))
			{	
				soap_flag_tds__SetNTP--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetNTP(struct soap *soap, const struct __tds__SetNTP *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetNTP(soap, tag?tag:"-tds:SetNTP", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNTP * SOAP_FMAC4 soap_get___tds__SetNTP(struct soap *soap, struct __tds__SetNTP *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetNTP(struct soap *soap, struct __tds__GetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetNTP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetNTP(struct soap *soap, const struct __tds__GetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetNTP(soap, &a->tds__GetNTP);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetNTP(struct soap *soap, const char *tag, int id, const struct __tds__GetNTP *a, const char *type)
{
	if (soap_out_PointerTo_tds__GetNTP(soap, "tds:GetNTP", -1, &a->tds__GetNTP, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNTP * SOAP_FMAC4 soap_in___tds__GetNTP(struct soap *soap, const char *tag, struct __tds__GetNTP *a, const char *type)
{
	size_t soap_flag_tds__GetNTP = 1;
	short soap_flag;
	a = (struct __tds__GetNTP *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetNTP, sizeof(struct __tds__GetNTP), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___tds__GetNTP(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__GetNTP && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__GetNTP(soap, "tds:GetNTP", &a->tds__GetNTP, ""))
			{	
				soap_flag_tds__GetNTP--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetNTP(struct soap *soap, const struct __tds__GetNTP *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetNTP(soap, tag?tag:"-tds:GetNTP", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNTP * SOAP_FMAC4 soap_get___tds__GetNTP(struct soap *soap, struct __tds__GetNTP *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNTPResponse(struct soap *soap, struct _tds__SetNTPResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNTPResponse))
		soap_serialize__tds__SetNTPResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNTPResponse(struct soap *soap, const char *tag, int id, struct _tds__SetNTPResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNTPResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetNTPResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetNTPResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNTPResponse(struct soap *soap, const char *tag, struct _tds__SetNTPResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__SetNTPResponse **)soap_malloc(soap, sizeof(struct _tds__SetNTPResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__SetNTPResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetNTPResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNTPResponse, sizeof(struct _tds__SetNTPResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNTPResponse(struct soap *soap, struct _tds__SetNTPResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNTPResponse);
	if (soap_out_PointerTo_tds__SetNTPResponse(soap, tag?tag:"tds:SetNTPResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNTPResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNTPResponse(struct soap *soap, struct _tds__SetNTPResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNTPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNTP(struct soap *soap, struct _tds__SetNTP *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNTP))
		soap_serialize__tds__SetNTP(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNTP(struct soap *soap, const char *tag, int id, struct _tds__SetNTP *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNTP);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetNTP(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetNTP ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNTP(struct soap *soap, const char *tag, struct _tds__SetNTP **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__SetNTP **)soap_malloc(soap, sizeof(struct _tds__SetNTP *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__SetNTP(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetNTP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNTP, sizeof(struct _tds__SetNTP), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNTP(struct soap *soap, struct _tds__SetNTP *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNTP);
	if (soap_out_PointerTo_tds__SetNTP(soap, tag?tag:"tds:SetNTP", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNTP ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNTP(struct soap *soap, struct _tds__SetNTP **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNTPResponse(struct soap *soap, struct _tds__GetNTPResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNTPResponse))
		soap_serialize__tds__GetNTPResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNTPResponse(struct soap *soap, const char *tag, int id, struct _tds__GetNTPResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNTPResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetNTPResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetNTPResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNTPResponse(struct soap *soap, const char *tag, struct _tds__GetNTPResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__GetNTPResponse **)soap_malloc(soap, sizeof(struct _tds__GetNTPResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__GetNTPResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetNTPResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNTPResponse, sizeof(struct _tds__GetNTPResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNTPResponse(struct soap *soap, struct _tds__GetNTPResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNTPResponse);
	if (soap_out_PointerTo_tds__GetNTPResponse(soap, tag?tag:"tds:GetNTPResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNTPResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNTPResponse(struct soap *soap, struct _tds__GetNTPResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNTPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNTP(struct soap *soap, struct _tds__GetNTP *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNTP))
		soap_serialize__tds__GetNTP(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNTP(struct soap *soap, const char *tag, int id, struct _tds__GetNTP *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNTP);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetNTP(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetNTP ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNTP(struct soap *soap, const char *tag, struct _tds__GetNTP **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__GetNTP **)soap_malloc(soap, sizeof(struct _tds__GetNTP *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__GetNTP(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetNTP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNTP, sizeof(struct _tds__GetNTP), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNTP(struct soap *soap, struct _tds__GetNTP *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNTP);
	if (soap_out_PointerTo_tds__GetNTP(soap, tag?tag:"tds:GetNTP", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNTP ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNTP(struct soap *soap, struct _tds__GetNTP **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNTPResponse(struct soap *soap, struct _tds__SetNTPResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNTPResponse(struct soap *soap, const struct _tds__SetNTPResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNTPResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetNTPResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNTPResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNTPResponse * SOAP_FMAC4 soap_in__tds__SetNTPResponse(struct soap *soap, const char *tag, struct _tds__SetNTPResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetNTPResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNTPResponse, sizeof(struct _tds__SetNTPResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__SetNTPResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetNTPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNTPResponse, 0, sizeof(struct _tds__SetNTPResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNTPResponse(struct soap *soap, const struct _tds__SetNTPResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetNTPResponse);
	if (soap_out__tds__SetNTPResponse(soap, tag?tag:"tds:SetNTPResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNTPResponse * SOAP_FMAC4 soap_get__tds__SetNTPResponse(struct soap *soap, struct _tds__SetNTPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNTPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNTP(struct soap *soap, struct _tds__SetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->FromDHCP);
	a->__sizeNTPManual = 0;
	a->NTPManual = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNTP(struct soap *soap, const struct _tds__SetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->FromDHCP, SOAP_TYPE_xsd__boolean_);
	if (a->NTPManual)
	{	
		int i;
		for (i = 0; i < a->__sizeNTPManual; i++)
		{
			soap_embedded(soap, a->NTPManual + i, SOAP_TYPE_tt__NetworkHost);
			soap_serialize_tt__NetworkHost(soap, a->NTPManual + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNTP(struct soap *soap, const char *tag, int id, const struct _tds__SetNTP *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNTP), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tds:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	if (a->NTPManual)
	{	
		int i;
		for (i = 0; i < a->__sizeNTPManual; i++)
			if (soap_out_tt__NetworkHost(soap, "tds:NTPManual", -1, a->NTPManual + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNTP * SOAP_FMAC4 soap_in__tds__SetNTP(struct soap *soap, const char *tag, struct _tds__SetNTP *a, const char *type)
{
	size_t soap_flag_FromDHCP = 1;
	struct soap_blist *soap_blist_NTPManual = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetNTP *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNTP, sizeof(struct _tds__SetNTP), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__SetNTP(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tds:FromDHCP", &a->FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP--;
			continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NTPManual", 1, NULL))
			{	
				if (a->NTPManual == NULL)
				{	
					if (soap_blist_NTPManual == NULL)
						soap_blist_NTPManual = soap_new_block(soap);
					a->NTPManual = (struct tt__NetworkHost *)soap_push_block(soap, soap_blist_NTPManual, sizeof(struct tt__NetworkHost));
					if (a->NTPManual == NULL)
						return NULL;
					soap_default_tt__NetworkHost(soap, a->NTPManual);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkHost(soap, "tds:NTPManual", a->NTPManual, "tt:NetworkHost"))
				{	
					a->__sizeNTPManual++;
					a->NTPManual = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NTPManual)
			soap_pop_block(soap, soap_blist_NTPManual);
		if (a->__sizeNTPManual)
			a->NTPManual = (struct tt__NetworkHost *)soap_save_block(soap, soap_blist_NTPManual, NULL, 1);
		else
		{	
			a->NTPManual = NULL;
			if (soap_blist_NTPManual)
				soap_end_block(soap, soap_blist_NTPManual);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetNTP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNTP, 0, sizeof(struct _tds__SetNTP), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNTP(struct soap *soap, const struct _tds__SetNTP *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetNTP);
	if (soap_out__tds__SetNTP(soap, tag?tag:"tds:SetNTP", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNTP * SOAP_FMAC4 soap_get__tds__SetNTP(struct soap *soap, struct _tds__SetNTP *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NTPInformation(struct soap *soap, struct tt__NTPInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->FromDHCP);
	a->__sizeNTPFromDHCP = 0;
	a->NTPFromDHCP = NULL;
	a->__sizeNTPManual = 0;
	a->NTPManual = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NTPInformation(struct soap *soap, const struct tt__NTPInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->FromDHCP, SOAP_TYPE_xsd__boolean_);
	if (a->NTPFromDHCP)
	{	
		int i;
		for (i = 0; i < a->__sizeNTPFromDHCP; i++)
		{
			soap_embedded(soap, a->NTPFromDHCP + i, SOAP_TYPE_tt__NetworkHost);
			soap_serialize_tt__NetworkHost(soap, a->NTPFromDHCP + i);
		}
	}
	if (a->NTPManual)
	{	
		int i;
		for (i = 0; i < a->__sizeNTPManual; i++)
		{
			soap_embedded(soap, a->NTPManual + i, SOAP_TYPE_tt__NetworkHost);
			soap_serialize_tt__NetworkHost(soap, a->NTPManual + i);
		}
	}
	soap_serialize_PointerTott__NTPInformationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NTPInformation(struct soap *soap, const char *tag, int id, const struct tt__NTPInformation *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NTPInformation), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	if (a->NTPFromDHCP)
	{	
		int i;
		for (i = 0; i < a->__sizeNTPFromDHCP; i++)
			if (soap_out_tt__NetworkHost(soap, "tt:NTPFromDHCP", -1, a->NTPFromDHCP + i, ""))
				return soap->error;
	}
	if (a->NTPManual)
	{	
		int i;
		for (i = 0; i < a->__sizeNTPManual; i++)
			if (soap_out_tt__NetworkHost(soap, "tt:NTPManual", -1, a->NTPManual + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__NTPInformationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NTPInformation * SOAP_FMAC4 soap_in_tt__NTPInformation(struct soap *soap, const char *tag, struct tt__NTPInformation *a, const char *type)
{
	size_t soap_flag_FromDHCP = 1;
	struct soap_blist *soap_blist_NTPFromDHCP = NULL;
	struct soap_blist *soap_blist_NTPManual = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NTPInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NTPInformation, sizeof(struct tt__NTPInformation), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__NTPInformation(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:FromDHCP", &a->FromDHCP, "xsd:boolean"))
				{	
					soap_flag_FromDHCP--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:NTPFromDHCP", 1, NULL))
				{	
					if (a->NTPFromDHCP == NULL)
					{	
						if (soap_blist_NTPFromDHCP == NULL)
							soap_blist_NTPFromDHCP = soap_new_block(soap);
						a->NTPFromDHCP = (struct tt__NetworkHost *)soap_push_block(soap, soap_blist_NTPFromDHCP, sizeof(struct tt__NetworkHost));
						if (a->NTPFromDHCP == NULL)
							return NULL;
						soap_default_tt__NetworkHost(soap, a->NTPFromDHCP);
					}
					soap_revert(soap);
					if (soap_in_tt__NetworkHost(soap, "tt:NTPFromDHCP", a->NTPFromDHCP, "tt:NetworkHost"))
					{	
						a->__sizeNTPFromDHCP++;
						a->NTPFromDHCP = NULL;
						continue;
					}
				}
				if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:NTPManual", 1, NULL))
				{	
					if (a->NTPManual == NULL)
					{	
						if (soap_blist_NTPManual == NULL)
							soap_blist_NTPManual = soap_new_block(soap);
						a->NTPManual = (struct tt__NetworkHost *)soap_push_block(soap, soap_blist_NTPManual, sizeof(struct tt__NetworkHost));
						if (a->NTPManual == NULL)
							return NULL;
						soap_default_tt__NetworkHost(soap, a->NTPManual);
					}
					soap_revert(soap);
					if (soap_in_tt__NetworkHost(soap, "tt:NTPManual", a->NTPManual, "tt:NetworkHost"))
					{	
						a->__sizeNTPManual++;
						a->NTPManual = NULL;
						continue;
					}
				}
				if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__NTPInformationExtension(soap, "tt:Extension", &a->Extension, "tt:NTPInformationExtension"))
					{	
						soap_flag_Extension--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH)
						soap->error = soap_ignore_element(soap);
					if (soap->error == SOAP_NO_TAG)
						break;
					if (soap->error)
						return NULL;
		}
		if (a->NTPFromDHCP)
			soap_pop_block(soap, soap_blist_NTPFromDHCP);
		if (a->__sizeNTPFromDHCP)
			a->NTPFromDHCP = (struct tt__NetworkHost *)soap_save_block(soap, soap_blist_NTPFromDHCP, NULL, 1);
		else
		{	
			a->NTPFromDHCP = NULL;
			if (soap_blist_NTPFromDHCP)
				soap_end_block(soap, soap_blist_NTPFromDHCP);
		}
		if (a->NTPManual)
			soap_pop_block(soap, soap_blist_NTPManual);
		if (a->__sizeNTPManual)
			a->NTPManual = (struct tt__NetworkHost *)soap_save_block(soap, soap_blist_NTPManual, NULL, 1);
		else
		{	
			a->NTPManual = NULL;
			if (soap_blist_NTPManual)
				soap_end_block(soap, soap_blist_NTPManual);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__NTPInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NTPInformation, 0, sizeof(struct tt__NTPInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NTPInformation(struct soap *soap, const struct tt__NTPInformation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NTPInformation);
	if (soap_out_tt__NTPInformation(soap, tag?tag:"tt:NTPInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NTPInformation * SOAP_FMAC4 soap_get_tt__NTPInformation(struct soap *soap, struct tt__NTPInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NTPInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNTPResponse(struct soap *soap, struct _tds__GetNTPResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->NTPInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNTPResponse(struct soap *soap, const struct _tds__GetNTPResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__NTPInformation(soap, &a->NTPInformation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNTPResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetNTPResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNTPResponse), type))
		return soap->error;
	if (a->NTPInformation)
		soap_element_result(soap, "tds:NTPInformation");
	if (a->NTPInformation)
	{	
		if (soap_out_PointerTott__NTPInformation(soap, "tds:NTPInformation", -1, &a->NTPInformation, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:NTPInformation"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNTPResponse * SOAP_FMAC4 soap_in__tds__GetNTPResponse(struct soap *soap, const char *tag, struct _tds__GetNTPResponse *a, const char *type)
{
	size_t soap_flag_NTPInformation = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetNTPResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNTPResponse, sizeof(struct _tds__GetNTPResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__GetNTPResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NTPInformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NTPInformation(soap, "tds:NTPInformation", &a->NTPInformation, "tt:NTPInformation"))
				{	
					soap_flag_NTPInformation--;
					continue;
				}
				soap_check_result(soap, "tds:NTPInformation");
				if (soap->error == SOAP_TAG_MISMATCH)
					soap->error = soap_ignore_element(soap);
				if (soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetNTPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNTPResponse, 0, sizeof(struct _tds__GetNTPResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_NTPInformation > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNTPResponse(struct soap *soap, const struct _tds__GetNTPResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetNTPResponse);
	if (soap_out__tds__GetNTPResponse(soap, tag?tag:"tds:GetNTPResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNTPResponse * SOAP_FMAC4 soap_get__tds__GetNTPResponse(struct soap *soap, struct _tds__GetNTPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNTPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNTP(struct soap *soap, struct _tds__GetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNTP(struct soap *soap, const struct _tds__GetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNTP(struct soap *soap, const char *tag, int id, const struct _tds__GetNTP *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNTP), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNTP * SOAP_FMAC4 soap_in__tds__GetNTP(struct soap *soap, const char *tag, struct _tds__GetNTP *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetNTP *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNTP, sizeof(struct _tds__GetNTP), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__GetNTP(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetNTP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNTP, 0, sizeof(struct _tds__GetNTP), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNTP(struct soap *soap, const struct _tds__GetNTP *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetNTP);
	if (soap_out__tds__GetNTP(soap, tag?tag:"tds:GetNTP", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNTP * SOAP_FMAC4 soap_get__tds__GetNTP(struct soap *soap, struct _tds__GetNTP *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NTPInformationExtension(struct soap *soap, struct tt__NTPInformationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NTPInformationExtension))
		soap_serialize_tt__NTPInformationExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NTPInformationExtension(struct soap *soap, const char *tag, int id, struct tt__NTPInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NTPInformationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NTPInformationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NTPInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__NTPInformationExtension(struct soap *soap, const char *tag, struct tt__NTPInformationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__NTPInformationExtension **)soap_malloc(soap, sizeof(struct tt__NTPInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__NTPInformationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__NTPInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NTPInformationExtension, sizeof(struct tt__NTPInformationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NTPInformationExtension(struct soap *soap, struct tt__NTPInformationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NTPInformationExtension);
	if (soap_out_PointerTott__NTPInformationExtension(soap, tag?tag:"tt:NTPInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NTPInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__NTPInformationExtension(struct soap *soap, struct tt__NTPInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NTPInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NTPInformation(struct soap *soap, struct tt__NTPInformation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NTPInformation))
		soap_serialize_tt__NTPInformation(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NTPInformation(struct soap *soap, const char *tag, int id, struct tt__NTPInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NTPInformation);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NTPInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NTPInformation ** SOAP_FMAC4 soap_in_PointerTott__NTPInformation(struct soap *soap, const char *tag, struct tt__NTPInformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__NTPInformation **)soap_malloc(soap, sizeof(struct tt__NTPInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__NTPInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__NTPInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NTPInformation, sizeof(struct tt__NTPInformation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NTPInformation(struct soap *soap, struct tt__NTPInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NTPInformation);
	if (soap_out_PointerTott__NTPInformation(soap, tag?tag:"tt:NTPInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NTPInformation ** SOAP_FMAC4 soap_get_PointerTott__NTPInformation(struct soap *soap, struct tt__NTPInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NTPInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NTPInformationExtension(struct soap *soap, struct tt__NTPInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NTPInformationExtension(struct soap *soap, const struct tt__NTPInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NTPInformationExtension(struct soap *soap, const char *tag, int id, const struct tt__NTPInformationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NTPInformationExtension), type))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NTPInformationExtension * SOAP_FMAC4 soap_in_tt__NTPInformationExtension(struct soap *soap, const char *tag, struct tt__NTPInformationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NTPInformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NTPInformationExtension, sizeof(struct tt__NTPInformationExtension), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__NTPInformationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__NTPInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NTPInformationExtension, 0, sizeof(struct tt__NTPInformationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NTPInformationExtension(struct soap *soap, const struct tt__NTPInformationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NTPInformationExtension);
	if (soap_out_tt__NTPInformationExtension(soap, tag?tag:"tt:NTPInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NTPInformationExtension * SOAP_FMAC4 soap_get_tt__NTPInformationExtension(struct soap *soap, struct tt__NTPInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NTPInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetDynamicDNS(struct soap *soap, struct __tds__SetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetDynamicDNS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetDynamicDNS(struct soap *soap, const struct __tds__SetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetDynamicDNS(soap, &a->tds__SetDynamicDNS);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetDynamicDNS(struct soap *soap, const char *tag, int id, const struct __tds__SetDynamicDNS *a, const char *type)
{
	if (soap_out_PointerTo_tds__SetDynamicDNS(soap, "tds:SetDynamicDNS", -1, &a->tds__SetDynamicDNS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDynamicDNS * SOAP_FMAC4 soap_in___tds__SetDynamicDNS(struct soap *soap, const char *tag, struct __tds__SetDynamicDNS *a, const char *type)
{
	size_t soap_flag_tds__SetDynamicDNS = 1;
	short soap_flag;
	a = (struct __tds__SetDynamicDNS *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetDynamicDNS, sizeof(struct __tds__SetDynamicDNS), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___tds__SetDynamicDNS(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__SetDynamicDNS && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__SetDynamicDNS(soap, "tds:SetDynamicDNS", &a->tds__SetDynamicDNS, ""))
			{	
				soap_flag_tds__SetDynamicDNS--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetDynamicDNS(struct soap *soap, const struct __tds__SetDynamicDNS *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetDynamicDNS(soap, tag?tag:"-tds:SetDynamicDNS", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDynamicDNS * SOAP_FMAC4 soap_get___tds__SetDynamicDNS(struct soap *soap, struct __tds__SetDynamicDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDynamicDNS(struct soap *soap, struct __tds__GetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDynamicDNS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDynamicDNS(struct soap *soap, const struct __tds__GetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetDynamicDNS(soap, &a->tds__GetDynamicDNS);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDynamicDNS(struct soap *soap, const char *tag, int id, const struct __tds__GetDynamicDNS *a, const char *type)
{
	if (soap_out_PointerTo_tds__GetDynamicDNS(soap, "tds:GetDynamicDNS", -1, &a->tds__GetDynamicDNS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDynamicDNS * SOAP_FMAC4 soap_in___tds__GetDynamicDNS(struct soap *soap, const char *tag, struct __tds__GetDynamicDNS *a, const char *type)
{
	size_t soap_flag_tds__GetDynamicDNS = 1;
	short soap_flag;
	a = (struct __tds__GetDynamicDNS *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDynamicDNS, sizeof(struct __tds__GetDynamicDNS), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___tds__GetDynamicDNS(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__GetDynamicDNS && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__GetDynamicDNS(soap, "tds:GetDynamicDNS", &a->tds__GetDynamicDNS, ""))
			{	
				soap_flag_tds__GetDynamicDNS--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDynamicDNS(struct soap *soap, const struct __tds__GetDynamicDNS *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetDynamicDNS(soap, tag?tag:"-tds:GetDynamicDNS", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDynamicDNS * SOAP_FMAC4 soap_get___tds__GetDynamicDNS(struct soap *soap, struct __tds__GetDynamicDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDynamicDNSResponse(struct soap *soap, struct _tds__SetDynamicDNSResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDynamicDNSResponse))
		soap_serialize__tds__SetDynamicDNSResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDynamicDNSResponse(struct soap *soap, const char *tag, int id, struct _tds__SetDynamicDNSResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDynamicDNSResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetDynamicDNSResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetDynamicDNSResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDynamicDNSResponse(struct soap *soap, const char *tag, struct _tds__SetDynamicDNSResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__SetDynamicDNSResponse **)soap_malloc(soap, sizeof(struct _tds__SetDynamicDNSResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__SetDynamicDNSResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetDynamicDNSResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDynamicDNSResponse, sizeof(struct _tds__SetDynamicDNSResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDynamicDNSResponse(struct soap *soap, struct _tds__SetDynamicDNSResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDynamicDNSResponse);
	if (soap_out_PointerTo_tds__SetDynamicDNSResponse(soap, tag?tag:"tds:SetDynamicDNSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDynamicDNSResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDynamicDNSResponse(struct soap *soap, struct _tds__SetDynamicDNSResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDynamicDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDynamicDNS(struct soap *soap, struct _tds__SetDynamicDNS *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDynamicDNS))
		soap_serialize__tds__SetDynamicDNS(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDynamicDNS(struct soap *soap, const char *tag, int id, struct _tds__SetDynamicDNS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDynamicDNS);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetDynamicDNS(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetDynamicDNS ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDynamicDNS(struct soap *soap, const char *tag, struct _tds__SetDynamicDNS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__SetDynamicDNS **)soap_malloc(soap, sizeof(struct _tds__SetDynamicDNS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__SetDynamicDNS(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetDynamicDNS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDynamicDNS, sizeof(struct _tds__SetDynamicDNS), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDynamicDNS(struct soap *soap, struct _tds__SetDynamicDNS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDynamicDNS);
	if (soap_out_PointerTo_tds__SetDynamicDNS(soap, tag?tag:"tds:SetDynamicDNS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDynamicDNS ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDynamicDNS(struct soap *soap, struct _tds__SetDynamicDNS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDynamicDNSResponse(struct soap *soap, struct _tds__GetDynamicDNSResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDynamicDNSResponse))
		soap_serialize__tds__GetDynamicDNSResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDynamicDNSResponse(struct soap *soap, const char *tag, int id, struct _tds__GetDynamicDNSResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDynamicDNSResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDynamicDNSResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDynamicDNSResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDynamicDNSResponse(struct soap *soap, const char *tag, struct _tds__GetDynamicDNSResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__GetDynamicDNSResponse **)soap_malloc(soap, sizeof(struct _tds__GetDynamicDNSResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__GetDynamicDNSResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetDynamicDNSResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDynamicDNSResponse, sizeof(struct _tds__GetDynamicDNSResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDynamicDNSResponse(struct soap *soap, struct _tds__GetDynamicDNSResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDynamicDNSResponse);
	if (soap_out_PointerTo_tds__GetDynamicDNSResponse(soap, tag?tag:"tds:GetDynamicDNSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDynamicDNSResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDynamicDNSResponse(struct soap *soap, struct _tds__GetDynamicDNSResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDynamicDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDynamicDNS(struct soap *soap, struct _tds__GetDynamicDNS *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDynamicDNS))
		soap_serialize__tds__GetDynamicDNS(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDynamicDNS(struct soap *soap, const char *tag, int id, struct _tds__GetDynamicDNS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDynamicDNS);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDynamicDNS(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDynamicDNS ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDynamicDNS(struct soap *soap, const char *tag, struct _tds__GetDynamicDNS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__GetDynamicDNS **)soap_malloc(soap, sizeof(struct _tds__GetDynamicDNS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__GetDynamicDNS(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetDynamicDNS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDynamicDNS, sizeof(struct _tds__GetDynamicDNS), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDynamicDNS(struct soap *soap, struct _tds__GetDynamicDNS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDynamicDNS);
	if (soap_out_PointerTo_tds__GetDynamicDNS(soap, tag?tag:"tds:GetDynamicDNS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDynamicDNS ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDynamicDNS(struct soap *soap, struct _tds__GetDynamicDNS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDynamicDNSResponse(struct soap *soap, struct _tds__SetDynamicDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDynamicDNSResponse(struct soap *soap, const struct _tds__SetDynamicDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDynamicDNSResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetDynamicDNSResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDynamicDNSResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDynamicDNSResponse * SOAP_FMAC4 soap_in__tds__SetDynamicDNSResponse(struct soap *soap, const char *tag, struct _tds__SetDynamicDNSResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetDynamicDNSResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDynamicDNSResponse, sizeof(struct _tds__SetDynamicDNSResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__SetDynamicDNSResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetDynamicDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDynamicDNSResponse, 0, sizeof(struct _tds__SetDynamicDNSResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDynamicDNSResponse(struct soap *soap, const struct _tds__SetDynamicDNSResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetDynamicDNSResponse);
	if (soap_out__tds__SetDynamicDNSResponse(soap, tag?tag:"tds:SetDynamicDNSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDynamicDNSResponse * SOAP_FMAC4 soap_get__tds__SetDynamicDNSResponse(struct soap *soap, struct _tds__SetDynamicDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDynamicDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDynamicDNS(struct soap *soap, struct _tds__SetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__DynamicDNSType(soap, &a->Type);
	a->Name = NULL;
	soap_default_string(soap, &a->TTL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDynamicDNS(struct soap *soap, const struct _tds__SetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__DNSName(soap, &a->Name);
	soap_serialize_string(soap, &a->TTL);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDynamicDNS(struct soap *soap, const char *tag, int id, const struct _tds__SetDynamicDNS *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDynamicDNS), type))
		return soap->error;
	if (soap_out_tt__DynamicDNSType(soap, "tds:Type", -1, &a->Type, ""))
		return soap->error;
	if (soap_out_PointerTott__DNSName(soap, "tds:Name", -1, &a->Name, ""))
		return soap->error;
	if (soap_out_string(soap, "tds:TTL", -1, &a->TTL, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDynamicDNS * SOAP_FMAC4 soap_in__tds__SetDynamicDNS(struct soap *soap, const char *tag, struct _tds__SetDynamicDNS *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_Name = 1;
	size_t soap_flag_TTL = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetDynamicDNS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDynamicDNS, sizeof(struct _tds__SetDynamicDNS), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__SetDynamicDNS(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__DynamicDNSType(soap, "tds:Type", &a->Type, "tt:DynamicDNSType"))
				{	
					soap_flag_Type--;
					continue;
				}
				if (soap_flag_Name && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__DNSName(soap, "tds:Name", &a->Name, "tt:DNSName"))
					{	
						soap_flag_Name--;
						continue;
					}
					if (soap_flag_TTL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
						if (soap_in_string(soap, "tds:TTL", &a->TTL, "xsd:string"))
						{	
							soap_flag_TTL--;
							continue;
						}
						if (soap->error == SOAP_TAG_MISMATCH)
							soap->error = soap_ignore_element(soap);
						if (soap->error == SOAP_NO_TAG)
							break;
						if (soap->error)
							return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetDynamicDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDynamicDNS, 0, sizeof(struct _tds__SetDynamicDNS), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDynamicDNS(struct soap *soap, const struct _tds__SetDynamicDNS *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetDynamicDNS);
	if (soap_out__tds__SetDynamicDNS(soap, tag?tag:"tds:SetDynamicDNS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDynamicDNS * SOAP_FMAC4 soap_get__tds__SetDynamicDNS(struct soap *soap, struct _tds__SetDynamicDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DynamicDNSInformation(struct soap *soap, struct tt__DynamicDNSInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__DynamicDNSType(soap, &a->Type);
	a->Name = NULL;
	soap_default_string(soap, &a->TTL);
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DynamicDNSInformation(struct soap *soap, const struct tt__DynamicDNSInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__DNSName(soap, &a->Name);
	soap_serialize_string(soap, &a->TTL);
	soap_serialize_PointerTott__DynamicDNSInformationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DynamicDNSInformation(struct soap *soap, const char *tag, int id, const struct tt__DynamicDNSInformation *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DynamicDNSInformation), type))
		return soap->error;
	if (soap_out_tt__DynamicDNSType(soap, "tt:Type", -1, &a->Type, ""))
		return soap->error;
	if (soap_out_PointerTott__DNSName(soap, "tt:Name", -1, &a->Name, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:TTL", -1, &a->TTL, ""))
		return soap->error;
	if (soap_out_PointerTott__DynamicDNSInformationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DynamicDNSInformation * SOAP_FMAC4 soap_in_tt__DynamicDNSInformation(struct soap *soap, const char *tag, struct tt__DynamicDNSInformation *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_Name = 1;
	size_t soap_flag_TTL = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DynamicDNSInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DynamicDNSInformation, sizeof(struct tt__DynamicDNSInformation), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__DynamicDNSInformation(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__DynamicDNSType(soap, "tt:Type", &a->Type, "tt:DynamicDNSType"))
				{	
					soap_flag_Type--;
					continue;
				}
				if (soap_flag_Name && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__DNSName(soap, "tt:Name", &a->Name, "tt:DNSName"))
					{	
						soap_flag_Name--;
						continue;
					}
					if (soap_flag_TTL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
						if (soap_in_string(soap, "tt:TTL", &a->TTL, "xsd:string"))
						{	
							soap_flag_TTL--;
							continue;
						}
						if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_PointerTott__DynamicDNSInformationExtension(soap, "tt:Extension", &a->Extension, "tt:DynamicDNSInformationExtension"))
							{	
								soap_flag_Extension--;
								continue;
							}
							if (soap->error == SOAP_TAG_MISMATCH)
								soap->error = soap_ignore_element(soap);
							if (soap->error == SOAP_NO_TAG)
								break;
							if (soap->error)
								return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{
		a = (struct tt__DynamicDNSInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DynamicDNSInformation, 0, sizeof(struct tt__DynamicDNSInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DynamicDNSInformation(struct soap *soap, const struct tt__DynamicDNSInformation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__DynamicDNSInformation);
	if (soap_out_tt__DynamicDNSInformation(soap, tag?tag:"tt:DynamicDNSInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DynamicDNSInformation * SOAP_FMAC4 soap_get_tt__DynamicDNSInformation(struct soap *soap, struct tt__DynamicDNSInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DynamicDNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDynamicDNSResponse(struct soap *soap, struct _tds__GetDynamicDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DynamicDNSInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDynamicDNSResponse(struct soap *soap, const struct _tds__GetDynamicDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__DynamicDNSInformation(soap, &a->DynamicDNSInformation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDynamicDNSResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDynamicDNSResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDynamicDNSResponse), type))
		return soap->error;
	if (a->DynamicDNSInformation)
		soap_element_result(soap, "tds:DynamicDNSInformation");
	if (a->DynamicDNSInformation)
	{	
		if (soap_out_PointerTott__DynamicDNSInformation(soap, "tds:DynamicDNSInformation", -1, &a->DynamicDNSInformation, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:DynamicDNSInformation"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDynamicDNSResponse * SOAP_FMAC4 soap_in__tds__GetDynamicDNSResponse(struct soap *soap, const char *tag, struct _tds__GetDynamicDNSResponse *a, const char *type)
{
	size_t soap_flag_DynamicDNSInformation = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDynamicDNSResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDynamicDNSResponse, sizeof(struct _tds__GetDynamicDNSResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__GetDynamicDNSResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DynamicDNSInformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DynamicDNSInformation(soap, "tds:DynamicDNSInformation", &a->DynamicDNSInformation, "tt:DynamicDNSInformation"))
				{	
					soap_flag_DynamicDNSInformation--;
					continue;
				}
				soap_check_result(soap, "tds:DynamicDNSInformation");
				if (soap->error == SOAP_TAG_MISMATCH)
					soap->error = soap_ignore_element(soap);
				if (soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetDynamicDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDynamicDNSResponse, 0, sizeof(struct _tds__GetDynamicDNSResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DynamicDNSInformation > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDynamicDNSResponse(struct soap *soap, const struct _tds__GetDynamicDNSResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDynamicDNSResponse);
	if (soap_out__tds__GetDynamicDNSResponse(soap, tag?tag:"tds:GetDynamicDNSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDynamicDNSResponse * SOAP_FMAC4 soap_get__tds__GetDynamicDNSResponse(struct soap *soap, struct _tds__GetDynamicDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDynamicDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDynamicDNS(struct soap *soap, struct _tds__GetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDynamicDNS(struct soap *soap, const struct _tds__GetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDynamicDNS(struct soap *soap, const char *tag, int id, const struct _tds__GetDynamicDNS *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDynamicDNS), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDynamicDNS * SOAP_FMAC4 soap_in__tds__GetDynamicDNS(struct soap *soap, const char *tag, struct _tds__GetDynamicDNS *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDynamicDNS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDynamicDNS, sizeof(struct _tds__GetDynamicDNS), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__GetDynamicDNS(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{
		a = (struct _tds__GetDynamicDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDynamicDNS, 0, sizeof(struct _tds__GetDynamicDNS), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDynamicDNS(struct soap *soap, const struct _tds__GetDynamicDNS *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDynamicDNS);
	if (soap_out__tds__GetDynamicDNS(soap, tag?tag:"tds:GetDynamicDNS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDynamicDNS * SOAP_FMAC4 soap_get__tds__GetDynamicDNS(struct soap *soap, struct _tds__GetDynamicDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DynamicDNSType(struct soap *soap, enum tt__DynamicDNSType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__DynamicDNSType
	*a = SOAP_DEFAULT_tt__DynamicDNSType;
#else
	*a = (enum tt__DynamicDNSType)0;
#endif
}

static const struct soap_code_map soap_codes_tt__DynamicDNSType[] =
{	
	{ (long)tt__DynamicDNSType__NoUpdate, "NoUpdate" },
	{ (long)tt__DynamicDNSType__ClientUpdates, "ClientUpdates" },
	{ (long)tt__DynamicDNSType__ServerUpdates, "ServerUpdates" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__DynamicDNSType2s(struct soap *soap, enum tt__DynamicDNSType n)
{	
	const char *s = soap_code_str(soap_codes_tt__DynamicDNSType, (long)n);
	if (s != NULL)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DynamicDNSType(struct soap *soap, const char *tag, int id, const enum tt__DynamicDNSType *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DynamicDNSType), type) || soap_send(soap, soap_tt__DynamicDNSType2s(soap, *a)))
	return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__DynamicDNSType(struct soap *soap, const char *s, enum tt__DynamicDNSType *a)
{
	const struct soap_code_map *map;
	if (s == NULL)
		return soap->error;
	map = soap_code(soap_codes_tt__DynamicDNSType, s);
	if (map)
		*a = (enum tt__DynamicDNSType)map->code;
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__DynamicDNSType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__DynamicDNSType * SOAP_FMAC4 soap_in_tt__DynamicDNSType(struct soap *soap, const char *tag, enum tt__DynamicDNSType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	return NULL;
	a = (enum tt__DynamicDNSType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DynamicDNSType, sizeof(enum tt__DynamicDNSType), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	if (soap->body && !*soap->href)
	{	
		if (!a || soap_s2tt__DynamicDNSType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (enum tt__DynamicDNSType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DynamicDNSType, 0, sizeof(enum tt__DynamicDNSType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DynamicDNSType(struct soap *soap, const enum tt__DynamicDNSType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__DynamicDNSType);
	if (soap_out_tt__DynamicDNSType(soap, tag?tag:"tt:DynamicDNSType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__DynamicDNSType * SOAP_FMAC4 soap_get_tt__DynamicDNSType(struct soap *soap, enum tt__DynamicDNSType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DynamicDNSType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DNSName(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DNSName))
		soap_serialize_tt__DNSName(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DNSName(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DNSName);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DNSName(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTott__DNSName(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__DNSName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DNSName, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DNSName(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__DNSName);
	if (soap_out_PointerTott__DNSName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTott__DNSName(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DNSName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DynamicDNSInformation(struct soap *soap, struct tt__DynamicDNSInformation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DynamicDNSInformation))
		soap_serialize_tt__DynamicDNSInformation(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DynamicDNSInformation(struct soap *soap, const char *tag, int id, struct tt__DynamicDNSInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DynamicDNSInformation);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DynamicDNSInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DynamicDNSInformation ** SOAP_FMAC4 soap_in_PointerTott__DynamicDNSInformation(struct soap *soap, const char *tag, struct tt__DynamicDNSInformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__DynamicDNSInformation **)soap_malloc(soap, sizeof(struct tt__DynamicDNSInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__DynamicDNSInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__DynamicDNSInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DynamicDNSInformation, sizeof(struct tt__DynamicDNSInformation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DynamicDNSInformation(struct soap *soap, struct tt__DynamicDNSInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__DynamicDNSInformation);
	if (soap_out_PointerTott__DynamicDNSInformation(soap, tag?tag:"tt:DynamicDNSInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DynamicDNSInformation ** SOAP_FMAC4 soap_get_PointerTott__DynamicDNSInformation(struct soap *soap, struct tt__DynamicDNSInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DynamicDNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DynamicDNSInformationExtension(struct soap *soap, struct tt__DynamicDNSInformationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DynamicDNSInformationExtension))
		soap_serialize_tt__DynamicDNSInformationExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DynamicDNSInformationExtension(struct soap *soap, const char *tag, int id, struct tt__DynamicDNSInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DynamicDNSInformationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DynamicDNSInformationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DynamicDNSInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__DynamicDNSInformationExtension(struct soap *soap, const char *tag, struct tt__DynamicDNSInformationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__DynamicDNSInformationExtension **)soap_malloc(soap, sizeof(struct tt__DynamicDNSInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__DynamicDNSInformationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__DynamicDNSInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DynamicDNSInformationExtension, sizeof(struct tt__DynamicDNSInformationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DynamicDNSInformationExtension(struct soap *soap, struct tt__DynamicDNSInformationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__DynamicDNSInformationExtension);
	if (soap_out_PointerTott__DynamicDNSInformationExtension(soap, tag?tag:"tt:DynamicDNSInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DynamicDNSInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__DynamicDNSInformationExtension(struct soap *soap, struct tt__DynamicDNSInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DynamicDNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DynamicDNSInformationExtension(struct soap *soap, struct tt__DynamicDNSInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DynamicDNSInformationExtension(struct soap *soap, const struct tt__DynamicDNSInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DynamicDNSInformationExtension(struct soap *soap, const char *tag, int id, const struct tt__DynamicDNSInformationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DynamicDNSInformationExtension), type))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DynamicDNSInformationExtension * SOAP_FMAC4 soap_in_tt__DynamicDNSInformationExtension(struct soap *soap, const char *tag, struct tt__DynamicDNSInformationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DynamicDNSInformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DynamicDNSInformationExtension, sizeof(struct tt__DynamicDNSInformationExtension), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__DynamicDNSInformationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__DynamicDNSInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DynamicDNSInformationExtension, 0, sizeof(struct tt__DynamicDNSInformationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DynamicDNSInformationExtension(struct soap *soap, const struct tt__DynamicDNSInformationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__DynamicDNSInformationExtension);
	if (soap_out_tt__DynamicDNSInformationExtension(soap, tag?tag:"tt:DynamicDNSInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DynamicDNSInformationExtension * SOAP_FMAC4 soap_get_tt__DynamicDNSInformationExtension(struct soap *soap, struct tt__DynamicDNSInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DynamicDNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetHostnameFromDHCP(struct soap *soap, struct __tds__SetHostnameFromDHCP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetHostnameFromDHCP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetHostnameFromDHCP(struct soap *soap, const struct __tds__SetHostnameFromDHCP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetHostnameFromDHCP(soap, &a->tds__SetHostnameFromDHCP);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, int id, const struct __tds__SetHostnameFromDHCP *a, const char *type)
{
	if (soap_out_PointerTo_tds__SetHostnameFromDHCP(soap, "tds:SetHostnameFromDHCP", -1, &a->tds__SetHostnameFromDHCP, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_in___tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, struct __tds__SetHostnameFromDHCP *a, const char *type)
{
	size_t soap_flag_tds__SetHostnameFromDHCP = 1;
	short soap_flag;
	a = (struct __tds__SetHostnameFromDHCP *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetHostnameFromDHCP, sizeof(struct __tds__SetHostnameFromDHCP), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___tds__SetHostnameFromDHCP(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__SetHostnameFromDHCP && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__SetHostnameFromDHCP(soap, "tds:SetHostnameFromDHCP", &a->tds__SetHostnameFromDHCP, ""))
			{	
				soap_flag_tds__SetHostnameFromDHCP--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetHostnameFromDHCP(struct soap *soap, const struct __tds__SetHostnameFromDHCP *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetHostnameFromDHCP(soap, tag?tag:"-tds:SetHostnameFromDHCP", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_get___tds__SetHostnameFromDHCP(struct soap *soap, struct __tds__SetHostnameFromDHCP *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetHostnameFromDHCP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetHostname(struct soap *soap, struct __tds__SetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetHostname = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetHostname(struct soap *soap, const struct __tds__SetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetHostname(soap, &a->tds__SetHostname);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetHostname(struct soap *soap, const char *tag, int id, const struct __tds__SetHostname *a, const char *type)
{
	if (soap_out_PointerTo_tds__SetHostname(soap, "tds:SetHostname", -1, &a->tds__SetHostname, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetHostname * SOAP_FMAC4 soap_in___tds__SetHostname(struct soap *soap, const char *tag, struct __tds__SetHostname *a, const char *type)
{
	size_t soap_flag_tds__SetHostname = 1;
	short soap_flag;
	a = (struct __tds__SetHostname *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetHostname, sizeof(struct __tds__SetHostname), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___tds__SetHostname(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__SetHostname && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__SetHostname(soap, "tds:SetHostname", &a->tds__SetHostname, ""))
			{	
				soap_flag_tds__SetHostname--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetHostname(struct soap *soap, const struct __tds__SetHostname *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetHostname(soap, tag?tag:"-tds:SetHostname", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetHostname * SOAP_FMAC4 soap_get___tds__SetHostname(struct soap *soap, struct __tds__SetHostname *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetHostname(struct soap *soap, struct __tds__GetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetHostname = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetHostname(struct soap *soap, const struct __tds__GetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetHostname(soap, &a->tds__GetHostname);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetHostname(struct soap *soap, const char *tag, int id, const struct __tds__GetHostname *a, const char *type)
{
	if (soap_out_PointerTo_tds__GetHostname(soap, "tds:GetHostname", -1, &a->tds__GetHostname, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetHostname * SOAP_FMAC4 soap_in___tds__GetHostname(struct soap *soap, const char *tag, struct __tds__GetHostname *a, const char *type)
{
	size_t soap_flag_tds__GetHostname = 1;
	short soap_flag;
	a = (struct __tds__GetHostname *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetHostname, sizeof(struct __tds__GetHostname), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___tds__GetHostname(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__GetHostname && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__GetHostname(soap, "tds:GetHostname", &a->tds__GetHostname, ""))
			{	
				soap_flag_tds__GetHostname--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetHostname(struct soap *soap, const struct __tds__GetHostname *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetHostname(soap, tag?tag:"-tds:GetHostname", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetHostname * SOAP_FMAC4 soap_get___tds__GetHostname(struct soap *soap, struct __tds__GetHostname *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetHostnameFromDHCPResponse(struct soap *soap, struct _tds__SetHostnameFromDHCPResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetHostnameFromDHCPResponse))
		soap_serialize__tds__SetHostnameFromDHCPResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetHostnameFromDHCPResponse(struct soap *soap, const char *tag, int id, struct _tds__SetHostnameFromDHCPResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetHostnameFromDHCPResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetHostnameFromDHCPResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCPResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetHostnameFromDHCPResponse(struct soap *soap, const char *tag, struct _tds__SetHostnameFromDHCPResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__SetHostnameFromDHCPResponse **)soap_malloc(soap, sizeof(struct _tds__SetHostnameFromDHCPResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__SetHostnameFromDHCPResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetHostnameFromDHCPResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, sizeof(struct _tds__SetHostnameFromDHCPResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetHostnameFromDHCPResponse(struct soap *soap, struct _tds__SetHostnameFromDHCPResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetHostnameFromDHCPResponse);
	if (soap_out_PointerTo_tds__SetHostnameFromDHCPResponse(soap, tag?tag:"tds:SetHostnameFromDHCPResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCPResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetHostnameFromDHCPResponse(struct soap *soap, struct _tds__SetHostnameFromDHCPResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetHostnameFromDHCPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, struct _tds__SetHostnameFromDHCP *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetHostnameFromDHCP))
		soap_serialize__tds__SetHostnameFromDHCP(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, int id, struct _tds__SetHostnameFromDHCP *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetHostnameFromDHCP);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetHostnameFromDHCP(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCP ** SOAP_FMAC4 soap_in_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, struct _tds__SetHostnameFromDHCP **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__SetHostnameFromDHCP **)soap_malloc(soap, sizeof(struct _tds__SetHostnameFromDHCP *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{
		soap_revert(soap);
		if (!(*a = soap_in__tds__SetHostnameFromDHCP(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetHostnameFromDHCP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetHostnameFromDHCP, sizeof(struct _tds__SetHostnameFromDHCP), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, struct _tds__SetHostnameFromDHCP *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetHostnameFromDHCP);
	if (soap_out_PointerTo_tds__SetHostnameFromDHCP(soap, tag?tag:"tds:SetHostnameFromDHCP", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCP ** SOAP_FMAC4 soap_get_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, struct _tds__SetHostnameFromDHCP **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetHostnameFromDHCP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetHostnameResponse(struct soap *soap, struct _tds__SetHostnameResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetHostnameResponse))
		soap_serialize__tds__SetHostnameResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetHostnameResponse(struct soap *soap, const char *tag, int id, struct _tds__SetHostnameResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetHostnameResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetHostnameResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetHostnameResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetHostnameResponse(struct soap *soap, const char *tag, struct _tds__SetHostnameResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__SetHostnameResponse **)soap_malloc(soap, sizeof(struct _tds__SetHostnameResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__SetHostnameResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetHostnameResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetHostnameResponse, sizeof(struct _tds__SetHostnameResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetHostnameResponse(struct soap *soap, struct _tds__SetHostnameResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetHostnameResponse);
	if (soap_out_PointerTo_tds__SetHostnameResponse(soap, tag?tag:"tds:SetHostnameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetHostnameResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetHostnameResponse(struct soap *soap, struct _tds__SetHostnameResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetHostnameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetHostname(struct soap *soap, struct _tds__SetHostname *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetHostname))
		soap_serialize__tds__SetHostname(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetHostname(struct soap *soap, const char *tag, int id, struct _tds__SetHostname *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetHostname);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetHostname(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetHostname ** SOAP_FMAC4 soap_in_PointerTo_tds__SetHostname(struct soap *soap, const char *tag, struct _tds__SetHostname **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__SetHostname **)soap_malloc(soap, sizeof(struct _tds__SetHostname *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__SetHostname(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetHostname **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetHostname, sizeof(struct _tds__SetHostname), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetHostname(struct soap *soap, struct _tds__SetHostname *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetHostname);
	if (soap_out_PointerTo_tds__SetHostname(soap, tag?tag:"tds:SetHostname", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetHostname ** SOAP_FMAC4 soap_get_PointerTo_tds__SetHostname(struct soap *soap, struct _tds__SetHostname **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetHostnameResponse(struct soap *soap, struct _tds__GetHostnameResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetHostnameResponse))
		soap_serialize__tds__GetHostnameResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetHostnameResponse(struct soap *soap, const char *tag, int id, struct _tds__GetHostnameResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetHostnameResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetHostnameResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetHostnameResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetHostnameResponse(struct soap *soap, const char *tag, struct _tds__GetHostnameResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__GetHostnameResponse **)soap_malloc(soap, sizeof(struct _tds__GetHostnameResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__GetHostnameResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetHostnameResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetHostnameResponse, sizeof(struct _tds__GetHostnameResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetHostnameResponse(struct soap *soap, struct _tds__GetHostnameResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetHostnameResponse);
	if (soap_out_PointerTo_tds__GetHostnameResponse(soap, tag?tag:"tds:GetHostnameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetHostnameResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetHostnameResponse(struct soap *soap, struct _tds__GetHostnameResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetHostnameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetHostname(struct soap *soap, struct _tds__GetHostname *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetHostname))
		soap_serialize__tds__GetHostname(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetHostname(struct soap *soap, const char *tag, int id, struct _tds__GetHostname *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetHostname);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetHostname(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetHostname ** SOAP_FMAC4 soap_in_PointerTo_tds__GetHostname(struct soap *soap, const char *tag, struct _tds__GetHostname **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__GetHostname **)soap_malloc(soap, sizeof(struct _tds__GetHostname *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__GetHostname(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetHostname **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetHostname, sizeof(struct _tds__GetHostname), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetHostname(struct soap *soap, struct _tds__GetHostname *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetHostname);
	if (soap_out_PointerTo_tds__GetHostname(soap, tag?tag:"tds:GetHostname", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetHostname ** SOAP_FMAC4 soap_get_PointerTo_tds__GetHostname(struct soap *soap, struct _tds__GetHostname **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetHostnameFromDHCPResponse(struct soap *soap, struct _tds__SetHostnameFromDHCPResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->RebootNeeded);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetHostnameFromDHCPResponse(struct soap *soap, const struct _tds__SetHostnameFromDHCPResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->RebootNeeded, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostnameFromDHCPResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetHostnameFromDHCPResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostnameFromDHCPResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:RebootNeeded");
	if (soap_out_xsd__boolean_(soap, "tds:RebootNeeded", -1, &a->RebootNeeded, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCPResponse * SOAP_FMAC4 soap_in__tds__SetHostnameFromDHCPResponse(struct soap *soap, const char *tag, struct _tds__SetHostnameFromDHCPResponse *a, const char *type)
{
	size_t soap_flag_RebootNeeded = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetHostnameFromDHCPResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, sizeof(struct _tds__SetHostnameFromDHCPResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__SetHostnameFromDHCPResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RebootNeeded && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tds:RebootNeeded", &a->RebootNeeded, "xsd:boolean"))
				{	
					soap_flag_RebootNeeded--;
					continue;
				}
				soap_check_result(soap, "tds:RebootNeeded");
				if (soap->error == SOAP_TAG_MISMATCH)
					soap->error = soap_ignore_element(soap);
				if (soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetHostnameFromDHCPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, 0, sizeof(struct _tds__SetHostnameFromDHCPResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RebootNeeded > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetHostnameFromDHCPResponse(struct soap *soap, const struct _tds__SetHostnameFromDHCPResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetHostnameFromDHCPResponse);
	if (soap_out__tds__SetHostnameFromDHCPResponse(soap, tag?tag:"tds:SetHostnameFromDHCPResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCPResponse * SOAP_FMAC4 soap_get__tds__SetHostnameFromDHCPResponse(struct soap *soap, struct _tds__SetHostnameFromDHCPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostnameFromDHCPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetHostnameFromDHCP(struct soap *soap, struct _tds__SetHostnameFromDHCP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->FromDHCP);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetHostnameFromDHCP(struct soap *soap, const struct _tds__SetHostnameFromDHCP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->FromDHCP, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, int id, const struct _tds__SetHostnameFromDHCP *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostnameFromDHCP), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tds:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_in__tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, struct _tds__SetHostnameFromDHCP *a, const char *type)
{
	size_t soap_flag_FromDHCP = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetHostnameFromDHCP *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostnameFromDHCP, sizeof(struct _tds__SetHostnameFromDHCP), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__SetHostnameFromDHCP(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tds:FromDHCP", &a->FromDHCP, "xsd:boolean"))
				{	
					soap_flag_FromDHCP--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH)
					soap->error = soap_ignore_element(soap);
				if (soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetHostnameFromDHCP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostnameFromDHCP, 0, sizeof(struct _tds__SetHostnameFromDHCP), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetHostnameFromDHCP(struct soap *soap, const struct _tds__SetHostnameFromDHCP *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetHostnameFromDHCP);
	if (soap_out__tds__SetHostnameFromDHCP(soap, tag?tag:"tds:SetHostnameFromDHCP", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_get__tds__SetHostnameFromDHCP(struct soap *soap, struct _tds__SetHostnameFromDHCP *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostnameFromDHCP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetHostnameResponse(struct soap *soap, struct _tds__SetHostnameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetHostnameResponse(struct soap *soap, const struct _tds__SetHostnameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostnameResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetHostnameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostnameResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetHostnameResponse * SOAP_FMAC4 soap_in__tds__SetHostnameResponse(struct soap *soap, const char *tag, struct _tds__SetHostnameResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetHostnameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostnameResponse, sizeof(struct _tds__SetHostnameResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__SetHostnameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetHostnameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostnameResponse, 0, sizeof(struct _tds__SetHostnameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetHostnameResponse(struct soap *soap, const struct _tds__SetHostnameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetHostnameResponse);
	if (soap_out__tds__SetHostnameResponse(soap, tag?tag:"tds:SetHostnameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetHostnameResponse * SOAP_FMAC4 soap_get__tds__SetHostnameResponse(struct soap *soap, struct _tds__SetHostnameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostnameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetHostname(struct soap *soap, struct _tds__SetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->Name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetHostname(struct soap *soap, const struct _tds__SetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__token(soap, &a->Name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostname(struct soap *soap, const char *tag, int id, const struct _tds__SetHostname *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostname), type))
		return soap->error;
	if (a->Name)
	{	
		if (soap_out_xsd__token(soap, "tds:Name", -1, &a->Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Name"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetHostname * SOAP_FMAC4 soap_in__tds__SetHostname(struct soap *soap, const char *tag, struct _tds__SetHostname *a, const char *type)
{
	size_t soap_flag_Name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetHostname *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostname, sizeof(struct _tds__SetHostname), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__SetHostname(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tds:Name", &a->Name, "xsd:token"))
				{	
					soap_flag_Name--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH)
					soap->error = soap_ignore_element(soap);
				if (soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetHostname *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostname, 0, sizeof(struct _tds__SetHostname), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetHostname(struct soap *soap, const struct _tds__SetHostname *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetHostname);
	if (soap_out__tds__SetHostname(soap, tag?tag:"tds:SetHostname", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetHostname * SOAP_FMAC4 soap_get__tds__SetHostname(struct soap *soap, struct _tds__SetHostname *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__HostnameInformation(struct soap *soap, struct tt__HostnameInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->FromDHCP);
	soap_default_xsd__token(soap, &a->Name);
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__HostnameInformation(struct soap *soap, const struct tt__HostnameInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->FromDHCP, SOAP_TYPE_xsd__boolean_);
	soap_serialize_xsd__token(soap, &a->Name);
	soap_serialize_PointerTott__HostnameInformationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__HostnameInformation(struct soap *soap, const char *tag, int id, const struct tt__HostnameInformation *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__HostnameInformation), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:Name", -1, &a->Name, ""))
		return soap->error;
	if (soap_out_PointerTott__HostnameInformationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__HostnameInformation * SOAP_FMAC4 soap_in_tt__HostnameInformation(struct soap *soap, const char *tag, struct tt__HostnameInformation *a, const char *type)
{
	size_t soap_flag_FromDHCP = 1;
	size_t soap_flag_Name = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__HostnameInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__HostnameInformation, sizeof(struct tt__HostnameInformation), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__HostnameInformation(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:FromDHCP", &a->FromDHCP, "xsd:boolean"))
				{	
					soap_flag_FromDHCP--;
					continue;
				}
				if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
					if (soap_in_xsd__token(soap, "tt:Name", &a->Name, "xsd:token"))
					{	
						soap_flag_Name--;
						continue;
					}
					if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTott__HostnameInformationExtension(soap, "tt:Extension", &a->Extension, "tt:HostnameInformationExtension"))
						{	
							soap_flag_Extension--;
							continue;
						}
						if (soap->error == SOAP_TAG_MISMATCH)
							soap->error = soap_ignore_element(soap);
						if (soap->error == SOAP_NO_TAG)
							break;
						if (soap->error)
							return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__HostnameInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__HostnameInformation, 0, sizeof(struct tt__HostnameInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__HostnameInformation(struct soap *soap, const struct tt__HostnameInformation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__HostnameInformation);
	if (soap_out_tt__HostnameInformation(soap, tag?tag:"tt:HostnameInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__HostnameInformation * SOAP_FMAC4 soap_get_tt__HostnameInformation(struct soap *soap, struct tt__HostnameInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__HostnameInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetHostnameResponse(struct soap *soap, struct _tds__GetHostnameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->HostnameInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetHostnameResponse(struct soap *soap, const struct _tds__GetHostnameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__HostnameInformation(soap, &a->HostnameInformation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetHostnameResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetHostnameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetHostnameResponse), type))
		return soap->error;
	if (a->HostnameInformation)
		soap_element_result(soap, "tds:HostnameInformation");
	if (a->HostnameInformation)
	{	
		if (soap_out_PointerTott__HostnameInformation(soap, "tds:HostnameInformation", -1, &a->HostnameInformation, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:HostnameInformation"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetHostnameResponse * SOAP_FMAC4 soap_in__tds__GetHostnameResponse(struct soap *soap, const char *tag, struct _tds__GetHostnameResponse *a, const char *type)
{
	size_t soap_flag_HostnameInformation = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetHostnameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetHostnameResponse, sizeof(struct _tds__GetHostnameResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__GetHostnameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HostnameInformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__HostnameInformation(soap, "tds:HostnameInformation", &a->HostnameInformation, "tt:HostnameInformation"))
				{	
					soap_flag_HostnameInformation--;
					continue;
				}
				soap_check_result(soap, "tds:HostnameInformation");
				if (soap->error == SOAP_TAG_MISMATCH)
					soap->error = soap_ignore_element(soap);
				if (soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetHostnameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetHostnameResponse, 0, sizeof(struct _tds__GetHostnameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_HostnameInformation > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetHostnameResponse(struct soap *soap, const struct _tds__GetHostnameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetHostnameResponse);
	if (soap_out__tds__GetHostnameResponse(soap, tag?tag:"tds:GetHostnameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetHostnameResponse * SOAP_FMAC4 soap_get__tds__GetHostnameResponse(struct soap *soap, struct _tds__GetHostnameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetHostnameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetHostname(struct soap *soap, struct _tds__GetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetHostname(struct soap *soap, const struct _tds__GetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetHostname(struct soap *soap, const char *tag, int id, const struct _tds__GetHostname *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetHostname), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetHostname * SOAP_FMAC4 soap_in__tds__GetHostname(struct soap *soap, const char *tag, struct _tds__GetHostname *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetHostname *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetHostname, sizeof(struct _tds__GetHostname), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__GetHostname(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetHostname *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetHostname, 0, sizeof(struct _tds__GetHostname), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetHostname(struct soap *soap, const struct _tds__GetHostname *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetHostname);
	if (soap_out__tds__GetHostname(soap, tag?tag:"tds:GetHostname", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetHostname * SOAP_FMAC4 soap_get__tds__GetHostname(struct soap *soap, struct _tds__GetHostname *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__HostnameInformationExtension(struct soap *soap, struct tt__HostnameInformationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__HostnameInformationExtension))
		soap_serialize_tt__HostnameInformationExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__HostnameInformationExtension(struct soap *soap, const char *tag, int id, struct tt__HostnameInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__HostnameInformationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__HostnameInformationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__HostnameInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__HostnameInformationExtension(struct soap *soap, const char *tag, struct tt__HostnameInformationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__HostnameInformationExtension **)soap_malloc(soap, sizeof(struct tt__HostnameInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__HostnameInformationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__HostnameInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__HostnameInformationExtension, sizeof(struct tt__HostnameInformationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__HostnameInformationExtension(struct soap *soap, struct tt__HostnameInformationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__HostnameInformationExtension);
	if (soap_out_PointerTott__HostnameInformationExtension(soap, tag?tag:"tt:HostnameInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__HostnameInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__HostnameInformationExtension(struct soap *soap, struct tt__HostnameInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__HostnameInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__HostnameInformation(struct soap *soap, struct tt__HostnameInformation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__HostnameInformation))
		soap_serialize_tt__HostnameInformation(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__HostnameInformation(struct soap *soap, const char *tag, int id, struct tt__HostnameInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__HostnameInformation);
	if (id < 0)
		return soap->error;
	return soap_out_tt__HostnameInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__HostnameInformation ** SOAP_FMAC4 soap_in_PointerTott__HostnameInformation(struct soap *soap, const char *tag, struct tt__HostnameInformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__HostnameInformation **)soap_malloc(soap, sizeof(struct tt__HostnameInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__HostnameInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__HostnameInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__HostnameInformation, sizeof(struct tt__HostnameInformation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__HostnameInformation(struct soap *soap, struct tt__HostnameInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__HostnameInformation);
	if (soap_out_PointerTott__HostnameInformation(soap, tag?tag:"tt:HostnameInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__HostnameInformation ** SOAP_FMAC4 soap_get_PointerTott__HostnameInformation(struct soap *soap, struct tt__HostnameInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__HostnameInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__HostnameInformationExtension(struct soap *soap, struct tt__HostnameInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__HostnameInformationExtension(struct soap *soap, const struct tt__HostnameInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__HostnameInformationExtension(struct soap *soap, const char *tag, int id, const struct tt__HostnameInformationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__HostnameInformationExtension), type))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__HostnameInformationExtension * SOAP_FMAC4 soap_in_tt__HostnameInformationExtension(struct soap *soap, const char *tag, struct tt__HostnameInformationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__HostnameInformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__HostnameInformationExtension, sizeof(struct tt__HostnameInformationExtension), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__HostnameInformationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__HostnameInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__HostnameInformationExtension, 0, sizeof(struct tt__HostnameInformationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__HostnameInformationExtension(struct soap *soap, const struct tt__HostnameInformationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__HostnameInformationExtension);
	if (soap_out_tt__HostnameInformationExtension(soap, tag?tag:"tt:HostnameInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__HostnameInformationExtension * SOAP_FMAC4 soap_get_tt__HostnameInformationExtension(struct soap *soap, struct tt__HostnameInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__HostnameInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

//ip filter
SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__RemoveIPAddressFilter(struct soap *soap, struct __tds__RemoveIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__RemoveIPAddressFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__RemoveIPAddressFilter(struct soap *soap, const struct __tds__RemoveIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__RemoveIPAddressFilter(soap, &a->tds__RemoveIPAddressFilter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, int id, const struct __tds__RemoveIPAddressFilter *a, const char *type)
{
	if (soap_out_PointerTo_tds__RemoveIPAddressFilter(soap, "tds:RemoveIPAddressFilter", -1, &a->tds__RemoveIPAddressFilter, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__RemoveIPAddressFilter * SOAP_FMAC4 soap_in___tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, struct __tds__RemoveIPAddressFilter *a, const char *type)
{
	size_t soap_flag_tds__RemoveIPAddressFilter = 1;
	short soap_flag;
	a = (struct __tds__RemoveIPAddressFilter *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__RemoveIPAddressFilter, sizeof(struct __tds__RemoveIPAddressFilter), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___tds__RemoveIPAddressFilter(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__RemoveIPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__RemoveIPAddressFilter(soap, "tds:RemoveIPAddressFilter", &a->tds__RemoveIPAddressFilter, ""))
			{	
				soap_flag_tds__RemoveIPAddressFilter--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__RemoveIPAddressFilter(struct soap *soap, const struct __tds__RemoveIPAddressFilter *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__RemoveIPAddressFilter(soap, tag?tag:"-tds:RemoveIPAddressFilter", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__RemoveIPAddressFilter * SOAP_FMAC4 soap_get___tds__RemoveIPAddressFilter(struct soap *soap, struct __tds__RemoveIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__RemoveIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__AddIPAddressFilter(struct soap *soap, struct __tds__AddIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__AddIPAddressFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__AddIPAddressFilter(struct soap *soap, const struct __tds__AddIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__AddIPAddressFilter(soap, &a->tds__AddIPAddressFilter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__AddIPAddressFilter(struct soap *soap, const char *tag, int id, const struct __tds__AddIPAddressFilter *a, const char *type)
{
	if (soap_out_PointerTo_tds__AddIPAddressFilter(soap, "tds:AddIPAddressFilter", -1, &a->tds__AddIPAddressFilter, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__AddIPAddressFilter * SOAP_FMAC4 soap_in___tds__AddIPAddressFilter(struct soap *soap, const char *tag, struct __tds__AddIPAddressFilter *a, const char *type)
{
	size_t soap_flag_tds__AddIPAddressFilter = 1;
	short soap_flag;
	a = (struct __tds__AddIPAddressFilter *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__AddIPAddressFilter, sizeof(struct __tds__AddIPAddressFilter), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___tds__AddIPAddressFilter(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__AddIPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__AddIPAddressFilter(soap, "tds:AddIPAddressFilter", &a->tds__AddIPAddressFilter, ""))
			{	
				soap_flag_tds__AddIPAddressFilter--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__AddIPAddressFilter(struct soap *soap, const struct __tds__AddIPAddressFilter *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__AddIPAddressFilter(soap, tag?tag:"-tds:AddIPAddressFilter", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__AddIPAddressFilter * SOAP_FMAC4 soap_get___tds__AddIPAddressFilter(struct soap *soap, struct __tds__AddIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__AddIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetIPAddressFilter(struct soap *soap, struct __tds__SetIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetIPAddressFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetIPAddressFilter(struct soap *soap, const struct __tds__SetIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetIPAddressFilter(soap, &a->tds__SetIPAddressFilter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetIPAddressFilter(struct soap *soap, const char *tag, int id, const struct __tds__SetIPAddressFilter *a, const char *type)
{
	if (soap_out_PointerTo_tds__SetIPAddressFilter(soap, "tds:SetIPAddressFilter", -1, &a->tds__SetIPAddressFilter, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetIPAddressFilter * SOAP_FMAC4 soap_in___tds__SetIPAddressFilter(struct soap *soap, const char *tag, struct __tds__SetIPAddressFilter *a, const char *type)
{
	size_t soap_flag_tds__SetIPAddressFilter = 1;
	short soap_flag;
	a = (struct __tds__SetIPAddressFilter *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetIPAddressFilter, sizeof(struct __tds__SetIPAddressFilter), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___tds__SetIPAddressFilter(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__SetIPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__SetIPAddressFilter(soap, "tds:SetIPAddressFilter", &a->tds__SetIPAddressFilter, ""))
			{	
				soap_flag_tds__SetIPAddressFilter--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetIPAddressFilter(struct soap *soap, const struct __tds__SetIPAddressFilter *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetIPAddressFilter(soap, tag?tag:"-tds:SetIPAddressFilter", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetIPAddressFilter * SOAP_FMAC4 soap_get___tds__SetIPAddressFilter(struct soap *soap, struct __tds__SetIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetIPAddressFilter(struct soap *soap, struct __tds__GetIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetIPAddressFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetIPAddressFilter(struct soap *soap, const struct __tds__GetIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetIPAddressFilter(soap, &a->tds__GetIPAddressFilter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetIPAddressFilter(struct soap *soap, const char *tag, int id, const struct __tds__GetIPAddressFilter *a, const char *type)
{
	if (soap_out_PointerTo_tds__GetIPAddressFilter(soap, "tds:GetIPAddressFilter", -1, &a->tds__GetIPAddressFilter, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetIPAddressFilter * SOAP_FMAC4 soap_in___tds__GetIPAddressFilter(struct soap *soap, const char *tag, struct __tds__GetIPAddressFilter *a, const char *type)
{
	size_t soap_flag_tds__GetIPAddressFilter = 1;
	short soap_flag;
	a = (struct __tds__GetIPAddressFilter *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetIPAddressFilter, sizeof(struct __tds__GetIPAddressFilter), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default___tds__GetIPAddressFilter(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__GetIPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__GetIPAddressFilter(soap, "tds:GetIPAddressFilter", &a->tds__GetIPAddressFilter, ""))
			{	
				soap_flag_tds__GetIPAddressFilter--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetIPAddressFilter(struct soap *soap, const struct __tds__GetIPAddressFilter *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetIPAddressFilter(soap, tag?tag:"-tds:GetIPAddressFilter", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetIPAddressFilter * SOAP_FMAC4 soap_get___tds__GetIPAddressFilter(struct soap *soap, struct __tds__GetIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__RemoveIPAddressFilterResponse(struct soap *soap, struct _tds__RemoveIPAddressFilterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__RemoveIPAddressFilterResponse))
		soap_serialize__tds__RemoveIPAddressFilterResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__RemoveIPAddressFilterResponse(struct soap *soap, const char *tag, int id, struct _tds__RemoveIPAddressFilterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__RemoveIPAddressFilterResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__RemoveIPAddressFilterResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__RemoveIPAddressFilterResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__RemoveIPAddressFilterResponse(struct soap *soap, const char *tag, struct _tds__RemoveIPAddressFilterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__RemoveIPAddressFilterResponse **)soap_malloc(soap, sizeof(struct _tds__RemoveIPAddressFilterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__RemoveIPAddressFilterResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__RemoveIPAddressFilterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, sizeof(struct _tds__RemoveIPAddressFilterResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__RemoveIPAddressFilterResponse(struct soap *soap, struct _tds__RemoveIPAddressFilterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__RemoveIPAddressFilterResponse);
	if (soap_out_PointerTo_tds__RemoveIPAddressFilterResponse(soap, tag?tag:"tds:RemoveIPAddressFilterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RemoveIPAddressFilterResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__RemoveIPAddressFilterResponse(struct soap *soap, struct _tds__RemoveIPAddressFilterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__RemoveIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, struct _tds__RemoveIPAddressFilter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__RemoveIPAddressFilter))
		soap_serialize__tds__RemoveIPAddressFilter(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, int id, struct _tds__RemoveIPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__RemoveIPAddressFilter);
	if (id < 0)
		return soap->error;
	return soap_out__tds__RemoveIPAddressFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__RemoveIPAddressFilter ** SOAP_FMAC4 soap_in_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, struct _tds__RemoveIPAddressFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__RemoveIPAddressFilter **)soap_malloc(soap, sizeof(struct _tds__RemoveIPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__RemoveIPAddressFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__RemoveIPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RemoveIPAddressFilter, sizeof(struct _tds__RemoveIPAddressFilter), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, struct _tds__RemoveIPAddressFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__RemoveIPAddressFilter);
	if (soap_out_PointerTo_tds__RemoveIPAddressFilter(soap, tag?tag:"tds:RemoveIPAddressFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RemoveIPAddressFilter ** SOAP_FMAC4 soap_get_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, struct _tds__RemoveIPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__RemoveIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__AddIPAddressFilterResponse(struct soap *soap, struct _tds__AddIPAddressFilterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__AddIPAddressFilterResponse))
		soap_serialize__tds__AddIPAddressFilterResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__AddIPAddressFilterResponse(struct soap *soap, const char *tag, int id, struct _tds__AddIPAddressFilterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__AddIPAddressFilterResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__AddIPAddressFilterResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__AddIPAddressFilterResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__AddIPAddressFilterResponse(struct soap *soap, const char *tag, struct _tds__AddIPAddressFilterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__AddIPAddressFilterResponse **)soap_malloc(soap, sizeof(struct _tds__AddIPAddressFilterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__AddIPAddressFilterResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__AddIPAddressFilterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__AddIPAddressFilterResponse, sizeof(struct _tds__AddIPAddressFilterResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__AddIPAddressFilterResponse(struct soap *soap, struct _tds__AddIPAddressFilterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__AddIPAddressFilterResponse);
	if (soap_out_PointerTo_tds__AddIPAddressFilterResponse(soap, tag?tag:"tds:AddIPAddressFilterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__AddIPAddressFilterResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__AddIPAddressFilterResponse(struct soap *soap, struct _tds__AddIPAddressFilterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__AddIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__AddIPAddressFilter(struct soap *soap, struct _tds__AddIPAddressFilter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__AddIPAddressFilter))
		soap_serialize__tds__AddIPAddressFilter(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__AddIPAddressFilter(struct soap *soap, const char *tag, int id, struct _tds__AddIPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__AddIPAddressFilter);
	if (id < 0)
		return soap->error;
	return soap_out__tds__AddIPAddressFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__AddIPAddressFilter ** SOAP_FMAC4 soap_in_PointerTo_tds__AddIPAddressFilter(struct soap *soap, const char *tag, struct _tds__AddIPAddressFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__AddIPAddressFilter **)soap_malloc(soap, sizeof(struct _tds__AddIPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__AddIPAddressFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__AddIPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__AddIPAddressFilter, sizeof(struct _tds__AddIPAddressFilter), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__AddIPAddressFilter(struct soap *soap, struct _tds__AddIPAddressFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__AddIPAddressFilter);
	if (soap_out_PointerTo_tds__AddIPAddressFilter(soap, tag?tag:"tds:AddIPAddressFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__AddIPAddressFilter ** SOAP_FMAC4 soap_get_PointerTo_tds__AddIPAddressFilter(struct soap *soap, struct _tds__AddIPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__AddIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetIPAddressFilterResponse(struct soap *soap, struct _tds__SetIPAddressFilterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetIPAddressFilterResponse))
		soap_serialize__tds__SetIPAddressFilterResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetIPAddressFilterResponse(struct soap *soap, const char *tag, int id, struct _tds__SetIPAddressFilterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetIPAddressFilterResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetIPAddressFilterResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetIPAddressFilterResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetIPAddressFilterResponse(struct soap *soap, const char *tag, struct _tds__SetIPAddressFilterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__SetIPAddressFilterResponse **)soap_malloc(soap, sizeof(struct _tds__SetIPAddressFilterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__SetIPAddressFilterResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetIPAddressFilterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetIPAddressFilterResponse, sizeof(struct _tds__SetIPAddressFilterResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetIPAddressFilterResponse(struct soap *soap, struct _tds__SetIPAddressFilterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetIPAddressFilterResponse);
	if (soap_out_PointerTo_tds__SetIPAddressFilterResponse(soap, tag?tag:"tds:SetIPAddressFilterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetIPAddressFilterResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetIPAddressFilterResponse(struct soap *soap, struct _tds__SetIPAddressFilterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetIPAddressFilter(struct soap *soap, struct _tds__SetIPAddressFilter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetIPAddressFilter))
		soap_serialize__tds__SetIPAddressFilter(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetIPAddressFilter(struct soap *soap, const char *tag, int id, struct _tds__SetIPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetIPAddressFilter);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetIPAddressFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetIPAddressFilter ** SOAP_FMAC4 soap_in_PointerTo_tds__SetIPAddressFilter(struct soap *soap, const char *tag, struct _tds__SetIPAddressFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__SetIPAddressFilter **)soap_malloc(soap, sizeof(struct _tds__SetIPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__SetIPAddressFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetIPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetIPAddressFilter, sizeof(struct _tds__SetIPAddressFilter), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetIPAddressFilter(struct soap *soap, struct _tds__SetIPAddressFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetIPAddressFilter);
	if (soap_out_PointerTo_tds__SetIPAddressFilter(soap, tag?tag:"tds:SetIPAddressFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetIPAddressFilter ** SOAP_FMAC4 soap_get_PointerTo_tds__SetIPAddressFilter(struct soap *soap, struct _tds__SetIPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetIPAddressFilterResponse(struct soap *soap, struct _tds__GetIPAddressFilterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetIPAddressFilterResponse))
		soap_serialize__tds__GetIPAddressFilterResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetIPAddressFilterResponse(struct soap *soap, const char *tag, int id, struct _tds__GetIPAddressFilterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetIPAddressFilterResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetIPAddressFilterResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetIPAddressFilterResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetIPAddressFilterResponse(struct soap *soap, const char *tag, struct _tds__GetIPAddressFilterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__GetIPAddressFilterResponse **)soap_malloc(soap, sizeof(struct _tds__GetIPAddressFilterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__GetIPAddressFilterResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetIPAddressFilterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetIPAddressFilterResponse, sizeof(struct _tds__GetIPAddressFilterResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetIPAddressFilterResponse(struct soap *soap, struct _tds__GetIPAddressFilterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetIPAddressFilterResponse);
	if (soap_out_PointerTo_tds__GetIPAddressFilterResponse(soap, tag?tag:"tds:GetIPAddressFilterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetIPAddressFilterResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetIPAddressFilterResponse(struct soap *soap, struct _tds__GetIPAddressFilterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetIPAddressFilter(struct soap *soap, struct _tds__GetIPAddressFilter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetIPAddressFilter))
		soap_serialize__tds__GetIPAddressFilter(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetIPAddressFilter(struct soap *soap, const char *tag, int id, struct _tds__GetIPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetIPAddressFilter);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetIPAddressFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetIPAddressFilter ** SOAP_FMAC4 soap_in_PointerTo_tds__GetIPAddressFilter(struct soap *soap, const char *tag, struct _tds__GetIPAddressFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct _tds__GetIPAddressFilter **)soap_malloc(soap, sizeof(struct _tds__GetIPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__tds__GetIPAddressFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetIPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetIPAddressFilter, sizeof(struct _tds__GetIPAddressFilter), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetIPAddressFilter(struct soap *soap, struct _tds__GetIPAddressFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetIPAddressFilter);
	if (soap_out_PointerTo_tds__GetIPAddressFilter(soap, tag?tag:"tds:GetIPAddressFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetIPAddressFilter ** SOAP_FMAC4 soap_get_PointerTo_tds__GetIPAddressFilter(struct soap *soap, struct _tds__GetIPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__RemoveIPAddressFilterResponse(struct soap *soap, struct _tds__RemoveIPAddressFilterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__RemoveIPAddressFilterResponse(struct soap *soap, const struct _tds__RemoveIPAddressFilterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RemoveIPAddressFilterResponse(struct soap *soap, const char *tag, int id, const struct _tds__RemoveIPAddressFilterResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RemoveIPAddressFilterResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__RemoveIPAddressFilterResponse * SOAP_FMAC4 soap_in__tds__RemoveIPAddressFilterResponse(struct soap *soap, const char *tag, struct _tds__RemoveIPAddressFilterResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__RemoveIPAddressFilterResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, sizeof(struct _tds__RemoveIPAddressFilterResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__RemoveIPAddressFilterResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{
		a = (struct _tds__RemoveIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, 0, sizeof(struct _tds__RemoveIPAddressFilterResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__RemoveIPAddressFilterResponse(struct soap *soap, const struct _tds__RemoveIPAddressFilterResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__RemoveIPAddressFilterResponse);
	if (soap_out__tds__RemoveIPAddressFilterResponse(soap, tag?tag:"tds:RemoveIPAddressFilterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RemoveIPAddressFilterResponse * SOAP_FMAC4 soap_get__tds__RemoveIPAddressFilterResponse(struct soap *soap, struct _tds__RemoveIPAddressFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RemoveIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__RemoveIPAddressFilter(struct soap *soap, struct _tds__RemoveIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->IPAddressFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__RemoveIPAddressFilter(struct soap *soap, const struct _tds__RemoveIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IPAddressFilter(soap, &a->IPAddressFilter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, int id, const struct _tds__RemoveIPAddressFilter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RemoveIPAddressFilter), type))
		return soap->error;
	if (a->IPAddressFilter)
	{	
		if (soap_out_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", -1, &a->IPAddressFilter, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:IPAddressFilter"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__RemoveIPAddressFilter * SOAP_FMAC4 soap_in__tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, struct _tds__RemoveIPAddressFilter *a, const char *type)
{
	size_t soap_flag_IPAddressFilter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__RemoveIPAddressFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveIPAddressFilter, sizeof(struct _tds__RemoveIPAddressFilter), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__RemoveIPAddressFilter(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", &a->IPAddressFilter, "tt:IPAddressFilter"))
				{	
					soap_flag_IPAddressFilter--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH)
					soap->error = soap_ignore_element(soap);
				if (soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__RemoveIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveIPAddressFilter, 0, sizeof(struct _tds__RemoveIPAddressFilter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_IPAddressFilter > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__RemoveIPAddressFilter(struct soap *soap, const struct _tds__RemoveIPAddressFilter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__RemoveIPAddressFilter);
	if (soap_out__tds__RemoveIPAddressFilter(soap, tag?tag:"tds:RemoveIPAddressFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RemoveIPAddressFilter * SOAP_FMAC4 soap_get__tds__RemoveIPAddressFilter(struct soap *soap, struct _tds__RemoveIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RemoveIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__AddIPAddressFilterResponse(struct soap *soap, struct _tds__AddIPAddressFilterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__AddIPAddressFilterResponse(struct soap *soap, const struct _tds__AddIPAddressFilterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__AddIPAddressFilterResponse(struct soap *soap, const char *tag, int id, const struct _tds__AddIPAddressFilterResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__AddIPAddressFilterResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__AddIPAddressFilterResponse * SOAP_FMAC4 soap_in__tds__AddIPAddressFilterResponse(struct soap *soap, const char *tag, struct _tds__AddIPAddressFilterResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__AddIPAddressFilterResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddIPAddressFilterResponse, sizeof(struct _tds__AddIPAddressFilterResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__AddIPAddressFilterResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__AddIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddIPAddressFilterResponse, 0, sizeof(struct _tds__AddIPAddressFilterResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__AddIPAddressFilterResponse(struct soap *soap, const struct _tds__AddIPAddressFilterResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__AddIPAddressFilterResponse);
	if (soap_out__tds__AddIPAddressFilterResponse(soap, tag?tag:"tds:AddIPAddressFilterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__AddIPAddressFilterResponse * SOAP_FMAC4 soap_get__tds__AddIPAddressFilterResponse(struct soap *soap, struct _tds__AddIPAddressFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__AddIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__AddIPAddressFilter(struct soap *soap, struct _tds__AddIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->IPAddressFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__AddIPAddressFilter(struct soap *soap, const struct _tds__AddIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IPAddressFilter(soap, &a->IPAddressFilter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__AddIPAddressFilter(struct soap *soap, const char *tag, int id, const struct _tds__AddIPAddressFilter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__AddIPAddressFilter), type))
		return soap->error;
	if (a->IPAddressFilter)
	{	
		if (soap_out_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", -1, &a->IPAddressFilter, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:IPAddressFilter"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__AddIPAddressFilter * SOAP_FMAC4 soap_in__tds__AddIPAddressFilter(struct soap *soap, const char *tag, struct _tds__AddIPAddressFilter *a, const char *type)
{
	size_t soap_flag_IPAddressFilter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__AddIPAddressFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddIPAddressFilter, sizeof(struct _tds__AddIPAddressFilter), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__AddIPAddressFilter(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", &a->IPAddressFilter, "tt:IPAddressFilter"))
				{	
					soap_flag_IPAddressFilter--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH)
					soap->error = soap_ignore_element(soap);
				if (soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__AddIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddIPAddressFilter, 0, sizeof(struct _tds__AddIPAddressFilter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_IPAddressFilter > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__AddIPAddressFilter(struct soap *soap, const struct _tds__AddIPAddressFilter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__AddIPAddressFilter);
	if (soap_out__tds__AddIPAddressFilter(soap, tag?tag:"tds:AddIPAddressFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__AddIPAddressFilter * SOAP_FMAC4 soap_get__tds__AddIPAddressFilter(struct soap *soap, struct _tds__AddIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__AddIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetIPAddressFilterResponse(struct soap *soap, struct _tds__SetIPAddressFilterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetIPAddressFilterResponse(struct soap *soap, const struct _tds__SetIPAddressFilterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetIPAddressFilterResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetIPAddressFilterResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetIPAddressFilterResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetIPAddressFilterResponse * SOAP_FMAC4 soap_in__tds__SetIPAddressFilterResponse(struct soap *soap, const char *tag, struct _tds__SetIPAddressFilterResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetIPAddressFilterResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetIPAddressFilterResponse, sizeof(struct _tds__SetIPAddressFilterResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__SetIPAddressFilterResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetIPAddressFilterResponse, 0, sizeof(struct _tds__SetIPAddressFilterResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetIPAddressFilterResponse(struct soap *soap, const struct _tds__SetIPAddressFilterResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetIPAddressFilterResponse);
	if (soap_out__tds__SetIPAddressFilterResponse(soap, tag?tag:"tds:SetIPAddressFilterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetIPAddressFilterResponse * SOAP_FMAC4 soap_get__tds__SetIPAddressFilterResponse(struct soap *soap, struct _tds__SetIPAddressFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetIPAddressFilter(struct soap *soap, struct _tds__SetIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->IPAddressFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetIPAddressFilter(struct soap *soap, const struct _tds__SetIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IPAddressFilter(soap, &a->IPAddressFilter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetIPAddressFilter(struct soap *soap, const char *tag, int id, const struct _tds__SetIPAddressFilter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetIPAddressFilter), type))
		return soap->error;
	if (a->IPAddressFilter)
	{	
		if (soap_out_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", -1, &a->IPAddressFilter, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:IPAddressFilter"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetIPAddressFilter * SOAP_FMAC4 soap_in__tds__SetIPAddressFilter(struct soap *soap, const char *tag, struct _tds__SetIPAddressFilter *a, const char *type)
{
	size_t soap_flag_IPAddressFilter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetIPAddressFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetIPAddressFilter, sizeof(struct _tds__SetIPAddressFilter), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__SetIPAddressFilter(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", &a->IPAddressFilter, "tt:IPAddressFilter"))
				{	
					soap_flag_IPAddressFilter--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH)
					soap->error = soap_ignore_element(soap);
				if (soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__SetIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetIPAddressFilter, 0, sizeof(struct _tds__SetIPAddressFilter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_IPAddressFilter > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetIPAddressFilter(struct soap *soap, const struct _tds__SetIPAddressFilter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetIPAddressFilter);
	if (soap_out__tds__SetIPAddressFilter(soap, tag?tag:"tds:SetIPAddressFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetIPAddressFilter * SOAP_FMAC4 soap_get__tds__SetIPAddressFilter(struct soap *soap, struct _tds__SetIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPAddressFilter(struct soap *soap, struct tt__IPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__IPAddressFilterType(soap, &a->Type);
	a->__sizeIPv4Address = 0;
	a->IPv4Address = NULL;
	a->__sizeIPv6Address = 0;
	a->IPv6Address = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPAddressFilter(struct soap *soap, const struct tt__IPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->IPv4Address)
	{	
		int i;
		for (i = 0; i < a->__sizeIPv4Address; i++)
		{
			soap_embedded(soap, a->IPv4Address + i, SOAP_TYPE_tt__PrefixedIPv4Address);
			soap_serialize_tt__PrefixedIPv4Address(soap, a->IPv4Address + i);
		}
	}
	if (a->IPv6Address)
	{	
		int i;
		for (i = 0; i < a->__sizeIPv6Address; i++)
		{
			soap_embedded(soap, a->IPv6Address + i, SOAP_TYPE_tt__PrefixedIPv6Address);
			soap_serialize_tt__PrefixedIPv6Address(soap, a->IPv6Address + i);
		}
	}
	soap_serialize_PointerTott__IPAddressFilterExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddressFilter(struct soap *soap, const char *tag, int id, const struct tt__IPAddressFilter *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPAddressFilter), type))
		return soap->error;
	if (soap_out_tt__IPAddressFilterType(soap, "tt:Type", -1, &a->Type, ""))
		return soap->error;
	if (a->IPv4Address)
	{	
		int i;
		for (i = 0; i < a->__sizeIPv4Address; i++)
			if (soap_out_tt__PrefixedIPv4Address(soap, "tt:IPv4Address", -1, a->IPv4Address + i, ""))
				return soap->error;
	}
	if (a->IPv6Address)
	{	
		int i;
		for (i = 0; i < a->__sizeIPv6Address; i++)
			if (soap_out_tt__PrefixedIPv6Address(soap, "tt:IPv6Address", -1, a->IPv6Address + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__IPAddressFilterExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPAddressFilter * SOAP_FMAC4 soap_in_tt__IPAddressFilter(struct soap *soap, const char *tag, struct tt__IPAddressFilter *a, const char *type)
{
	size_t soap_flag_Type = 1;
	struct soap_blist *soap_blist_IPv4Address = NULL;
	struct soap_blist *soap_blist_IPv6Address = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IPAddressFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddressFilter, sizeof(struct tt__IPAddressFilter), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__IPAddressFilter(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__IPAddressFilterType(soap, "tt:Type", &a->Type, "tt:IPAddressFilterType"))
				{	soap_flag_Type--;
			continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IPv4Address", 1, NULL))
			{	
				if (a->IPv4Address == NULL)
				{	
					if (soap_blist_IPv4Address == NULL)
						soap_blist_IPv4Address = soap_new_block(soap);
					a->IPv4Address = (struct tt__PrefixedIPv4Address *)soap_push_block(soap, soap_blist_IPv4Address, sizeof(struct tt__PrefixedIPv4Address));
					if (a->IPv4Address == NULL)
						return NULL;
					soap_default_tt__PrefixedIPv4Address(soap, a->IPv4Address);
				}
				soap_revert(soap);
				if (soap_in_tt__PrefixedIPv4Address(soap, "tt:IPv4Address", a->IPv4Address, "tt:PrefixedIPv4Address"))
				{	
					a->__sizeIPv4Address++;
					a->IPv4Address = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IPv6Address", 1, NULL))
			{	
				if (a->IPv6Address == NULL)
				{	
					if (soap_blist_IPv6Address == NULL)
						soap_blist_IPv6Address = soap_new_block(soap);
					a->IPv6Address = (struct tt__PrefixedIPv6Address *)soap_push_block(soap, soap_blist_IPv6Address, sizeof(struct tt__PrefixedIPv6Address));
					if (a->IPv6Address == NULL)
						return NULL;
					soap_default_tt__PrefixedIPv6Address(soap, a->IPv6Address);
				}
				soap_revert(soap);
				if (soap_in_tt__PrefixedIPv6Address(soap, "tt:IPv6Address", a->IPv6Address, "tt:PrefixedIPv6Address"))
				{	
					a->__sizeIPv6Address++;
					a->IPv6Address = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPAddressFilterExtension(soap, "tt:Extension", &a->Extension, "tt:IPAddressFilterExtension"))
				{	
					soap_flag_Extension--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH)
					soap->error = soap_ignore_element(soap);
				if (soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
		}
		if (a->IPv4Address)
			soap_pop_block(soap, soap_blist_IPv4Address);
		if (a->__sizeIPv4Address)
			a->IPv4Address = (struct tt__PrefixedIPv4Address *)soap_save_block(soap, soap_blist_IPv4Address, NULL, 1);
		else
		{	
			a->IPv4Address = NULL;
			if (soap_blist_IPv4Address)
				soap_end_block(soap, soap_blist_IPv4Address);
		}
		if (a->IPv6Address)
			soap_pop_block(soap, soap_blist_IPv6Address);
		if (a->__sizeIPv6Address)
			a->IPv6Address = (struct tt__PrefixedIPv6Address *)soap_save_block(soap, soap_blist_IPv6Address, NULL, 1);
		else
		{	
			a->IPv6Address = NULL;
			if (soap_blist_IPv6Address)
				soap_end_block(soap, soap_blist_IPv6Address);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__IPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddressFilter, 0, sizeof(struct tt__IPAddressFilter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPAddressFilter(struct soap *soap, const struct tt__IPAddressFilter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPAddressFilter);
	if (soap_out_tt__IPAddressFilter(soap, tag?tag:"tt:IPAddressFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPAddressFilter * SOAP_FMAC4 soap_get_tt__IPAddressFilter(struct soap *soap, struct tt__IPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetIPAddressFilterResponse(struct soap *soap, struct _tds__GetIPAddressFilterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->IPAddressFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetIPAddressFilterResponse(struct soap *soap, const struct _tds__GetIPAddressFilterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IPAddressFilter(soap, &a->IPAddressFilter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetIPAddressFilterResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetIPAddressFilterResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetIPAddressFilterResponse), type))
		return soap->error;
	if (a->IPAddressFilter)
		soap_element_result(soap, "tds:IPAddressFilter");
	if (a->IPAddressFilter)
	{	
		if (soap_out_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", -1, &a->IPAddressFilter, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:IPAddressFilter"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetIPAddressFilterResponse * SOAP_FMAC4 soap_in__tds__GetIPAddressFilterResponse(struct soap *soap, const char *tag, struct _tds__GetIPAddressFilterResponse *a, const char *type)
{
	size_t soap_flag_IPAddressFilter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetIPAddressFilterResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetIPAddressFilterResponse, sizeof(struct _tds__GetIPAddressFilterResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__GetIPAddressFilterResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", &a->IPAddressFilter, "tt:IPAddressFilter"))
				{	
					soap_flag_IPAddressFilter--;
					continue;
				}
				soap_check_result(soap, "tds:IPAddressFilter");
				if (soap->error == SOAP_TAG_MISMATCH)
					soap->error = soap_ignore_element(soap);
				if (soap->error == SOAP_NO_TAG)
					break;
				if (soap->error)
					return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetIPAddressFilterResponse, 0, sizeof(struct _tds__GetIPAddressFilterResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_IPAddressFilter > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetIPAddressFilterResponse(struct soap *soap, const struct _tds__GetIPAddressFilterResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetIPAddressFilterResponse);
	if (soap_out__tds__GetIPAddressFilterResponse(soap, tag?tag:"tds:GetIPAddressFilterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetIPAddressFilterResponse * SOAP_FMAC4 soap_get__tds__GetIPAddressFilterResponse(struct soap *soap, struct _tds__GetIPAddressFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetIPAddressFilter(struct soap *soap, struct _tds__GetIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetIPAddressFilter(struct soap *soap, const struct _tds__GetIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetIPAddressFilter(struct soap *soap, const char *tag, int id, const struct _tds__GetIPAddressFilter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetIPAddressFilter), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetIPAddressFilter * SOAP_FMAC4 soap_in__tds__GetIPAddressFilter(struct soap *soap, const char *tag, struct _tds__GetIPAddressFilter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetIPAddressFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetIPAddressFilter, sizeof(struct _tds__GetIPAddressFilter), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default__tds__GetIPAddressFilter(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _tds__GetIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetIPAddressFilter, 0, sizeof(struct _tds__GetIPAddressFilter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetIPAddressFilter(struct soap *soap, const struct _tds__GetIPAddressFilter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetIPAddressFilter);
	if (soap_out__tds__GetIPAddressFilter(soap, tag?tag:"tds:GetIPAddressFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetIPAddressFilter * SOAP_FMAC4 soap_get__tds__GetIPAddressFilter(struct soap *soap, struct _tds__GetIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPAddressFilter(struct soap *soap, struct tt__IPAddressFilter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPAddressFilter))
		soap_serialize_tt__IPAddressFilter(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPAddressFilter(struct soap *soap, const char *tag, int id, struct tt__IPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPAddressFilter);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPAddressFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPAddressFilter ** SOAP_FMAC4 soap_in_PointerTott__IPAddressFilter(struct soap *soap, const char *tag, struct tt__IPAddressFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__IPAddressFilter **)soap_malloc(soap, sizeof(struct tt__IPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__IPAddressFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__IPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPAddressFilter, sizeof(struct tt__IPAddressFilter), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPAddressFilter(struct soap *soap, struct tt__IPAddressFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPAddressFilter);
	if (soap_out_PointerTott__IPAddressFilter(soap, tag?tag:"tt:IPAddressFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPAddressFilter ** SOAP_FMAC4 soap_get_PointerTott__IPAddressFilter(struct soap *soap, struct tt__IPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPAddressFilterExtension(struct soap *soap, struct tt__IPAddressFilterExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPAddressFilterExtension))
		soap_serialize_tt__IPAddressFilterExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPAddressFilterExtension(struct soap *soap, const char *tag, int id, struct tt__IPAddressFilterExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPAddressFilterExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPAddressFilterExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPAddressFilterExtension ** SOAP_FMAC4 soap_in_PointerTott__IPAddressFilterExtension(struct soap *soap, const char *tag, struct tt__IPAddressFilterExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
		if (!(a = (struct tt__IPAddressFilterExtension **)soap_malloc(soap, sizeof(struct tt__IPAddressFilterExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__IPAddressFilterExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	
		a = (struct tt__IPAddressFilterExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPAddressFilterExtension, sizeof(struct tt__IPAddressFilterExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPAddressFilterExtension(struct soap *soap, struct tt__IPAddressFilterExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPAddressFilterExtension);
	if (soap_out_PointerTott__IPAddressFilterExtension(soap, tag?tag:"tt:IPAddressFilterExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPAddressFilterExtension ** SOAP_FMAC4 soap_get_PointerTott__IPAddressFilterExtension(struct soap *soap, struct tt__IPAddressFilterExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPAddressFilterExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPAddressFilterExtension(struct soap *soap, struct tt__IPAddressFilterExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPAddressFilterExtension(struct soap *soap, const struct tt__IPAddressFilterExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddressFilterExtension(struct soap *soap, const char *tag, int id, const struct tt__IPAddressFilterExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPAddressFilterExtension), type))
		return soap->error;
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPAddressFilterExtension * SOAP_FMAC4 soap_in_tt__IPAddressFilterExtension(struct soap *soap, const char *tag, struct tt__IPAddressFilterExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IPAddressFilterExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddressFilterExtension, sizeof(struct tt__IPAddressFilterExtension), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	soap_default_tt__IPAddressFilterExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__IPAddressFilterExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddressFilterExtension, 0, sizeof(struct tt__IPAddressFilterExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPAddressFilterExtension(struct soap *soap, const struct tt__IPAddressFilterExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPAddressFilterExtension);
	if (soap_out_tt__IPAddressFilterExtension(soap, tag?tag:"tt:IPAddressFilterExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPAddressFilterExtension * SOAP_FMAC4 soap_get_tt__IPAddressFilterExtension(struct soap *soap, struct tt__IPAddressFilterExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddressFilterExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPAddressFilterType(struct soap *soap, enum tt__IPAddressFilterType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__IPAddressFilterType
	*a = SOAP_DEFAULT_tt__IPAddressFilterType;
#else
	*a = (enum tt__IPAddressFilterType)0;
#endif
}

static const struct soap_code_map soap_codes_tt__IPAddressFilterType[] =
{	
	{ (long)tt__IPAddressFilterType__Allow, "Allow" },
	{ (long)tt__IPAddressFilterType__Deny, "Deny" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__IPAddressFilterType2s(struct soap *soap, enum tt__IPAddressFilterType n)
{	
	const char *s = soap_code_str(soap_codes_tt__IPAddressFilterType, (long)n);
	if (s != NULL)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddressFilterType(struct soap *soap, const char *tag, int id, const enum tt__IPAddressFilterType *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPAddressFilterType), type) || soap_send(soap, soap_tt__IPAddressFilterType2s(soap, *a)))
	return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__IPAddressFilterType(struct soap *soap, const char *s, enum tt__IPAddressFilterType *a)
{
	const struct soap_code_map *map;
	if (s == NULL)
		return soap->error;
	map = soap_code(soap_codes_tt__IPAddressFilterType, s);
	if (map)
		*a = (enum tt__IPAddressFilterType)map->code;
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum tt__IPAddressFilterType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__IPAddressFilterType * SOAP_FMAC4 soap_in_tt__IPAddressFilterType(struct soap *soap, const char *tag, enum tt__IPAddressFilterType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	return NULL;
	a = (enum tt__IPAddressFilterType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddressFilterType, sizeof(enum tt__IPAddressFilterType), 0, NULL, NULL, NULL);
	if (a == NULL)
		return NULL;
	if (soap->body && !*soap->href)
	{	
		if (!a || soap_s2tt__IPAddressFilterType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (enum tt__IPAddressFilterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddressFilterType, 0, sizeof(enum tt__IPAddressFilterType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPAddressFilterType(struct soap *soap, const enum tt__IPAddressFilterType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPAddressFilterType);
	if (soap_out_tt__IPAddressFilterType(soap, tag?tag:"tt:IPAddressFilterType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IPAddressFilterType * SOAP_FMAC4 soap_get_tt__IPAddressFilterType(struct soap *soap, enum tt__IPAddressFilterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddressFilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

//device configuration
//get profiles
SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetProfilesResponse(struct soap *soap, struct _trt__GetProfilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeProfiles = 0;
	a->Profiles = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetProfilesResponse(struct soap *soap, const struct _trt__GetProfilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Profiles != NULL)
	{	
		int i;
		for (i = 0; i < a->__sizeProfiles; i++)
		{
			soap_embedded(soap, a->Profiles + i, SOAP_TYPE_tt__Profile);
			soap_serialize_tt__Profile(soap, a->Profiles + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetProfilesResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetProfilesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetProfilesResponse), type))
	{
		return soap->error;
	}
	soap_element_result(soap, "-sizeProfiles");
	if (a->Profiles != NULL)
	{	
		int i;
		for (i = 0; i < a->__sizeProfiles; i++)
		{
			if (soap_out_tt__Profile(soap, "trt:Profiles", -1, a->Profiles + i, ""))
			{
				return soap->error;
			}
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetProfilesResponse * SOAP_FMAC4 soap_in__trt__GetProfilesResponse(struct soap *soap, const char *tag, struct _trt__GetProfilesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Profiles = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct _trt__GetProfilesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetProfilesResponse, sizeof(struct _trt__GetProfilesResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default__trt__GetProfilesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Profiles", 1, NULL))
			{	
				if (a->Profiles == NULL)
				{	
					if (soap_blist_Profiles == NULL)
					{
						soap_blist_Profiles = soap_new_block(soap);
					}
					a->Profiles = (struct tt__Profile *)soap_push_block(soap, soap_blist_Profiles, sizeof(struct tt__Profile));
					if (a->Profiles == NULL)
					{
						return NULL;
					}
					soap_default_tt__Profile(soap, a->Profiles);
				}
				soap_revert(soap);
				if (soap_in_tt__Profile(soap, "trt:Profiles", a->Profiles, "tt:Profile"))
				{	
					a->__sizeProfiles++;
					a->Profiles = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeProfiles");
			if (soap->error == SOAP_TAG_MISMATCH)
			{
				soap->error = soap_ignore_element(soap);
			}
			if (soap->error == SOAP_NO_TAG)
			{
				break;
			}
			if (soap->error)
			{
				return NULL;
			}
		}
		if (a->Profiles != NULL)
		{
			soap_pop_block(soap, soap_blist_Profiles);
		}
		if (a->__sizeProfiles)
		{
			a->Profiles = (struct tt__Profile *)soap_save_block(soap, soap_blist_Profiles, NULL, 1);
		}
		else
		{	
			a->Profiles = NULL;
			if (soap_blist_Profiles)
			{
				soap_end_block(soap, soap_blist_Profiles);
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__GetProfilesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetProfilesResponse, 0, sizeof(struct _trt__GetProfilesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetProfilesResponse(struct soap *soap, const struct _trt__GetProfilesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetProfilesResponse);
	if (soap_out__trt__GetProfilesResponse(soap, tag?tag:"trt:GetProfilesResponse", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetProfilesResponse * SOAP_FMAC4 soap_get__trt__GetProfilesResponse(struct soap *soap, struct _trt__GetProfilesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetProfilesResponse(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetProfiles(struct soap *soap, struct _trt__GetProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetProfiles(struct soap *soap, const struct _trt__GetProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetProfiles(struct soap *soap, const char *tag, int id, const struct _trt__GetProfiles *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetProfiles), type))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetProfiles * SOAP_FMAC4 soap_in__trt__GetProfiles(struct soap *soap, const char *tag, struct _trt__GetProfiles *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct _trt__GetProfiles *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetProfiles, sizeof(struct _trt__GetProfiles), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default__trt__GetProfiles(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{
				soap->error = soap_ignore_element(soap);
			}
			if (soap->error == SOAP_NO_TAG)
			{
				break;
			}
			if (soap->error)
			{
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__GetProfiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetProfiles, 0, sizeof(struct _trt__GetProfiles), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetProfiles(struct soap *soap, const struct _trt__GetProfiles *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetProfiles);
	if (soap_out__trt__GetProfiles(soap, tag?tag:"trt:GetProfiles", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetProfiles * SOAP_FMAC4 soap_get__trt__GetProfiles(struct soap *soap, struct _trt__GetProfiles *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetProfiles(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetProfilesResponse(struct soap *soap, struct _trt__GetProfilesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetProfilesResponse))
	{
		soap_serialize__trt__GetProfilesResponse(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetProfilesResponse(struct soap *soap, const char *tag, int id, struct _trt__GetProfilesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetProfilesResponse);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out__trt__GetProfilesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetProfilesResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetProfilesResponse(struct soap *soap, const char *tag, struct _trt__GetProfilesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct _trt__GetProfilesResponse **)soap_malloc(soap, sizeof(struct _trt__GetProfilesResponse *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in__trt__GetProfilesResponse(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__GetProfilesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetProfilesResponse, sizeof(struct _trt__GetProfilesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetProfilesResponse(struct soap *soap, struct _trt__GetProfilesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetProfilesResponse);
	if (soap_out_PointerTo_trt__GetProfilesResponse(soap, tag?tag:"trt:GetProfilesResponse", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetProfilesResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetProfilesResponse(struct soap *soap, struct _trt__GetProfilesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetProfilesResponse(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetProfiles(struct soap *soap, struct _trt__GetProfiles *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetProfiles))
	{
		soap_serialize__trt__GetProfiles(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetProfiles(struct soap *soap, const char *tag, int id, struct _trt__GetProfiles *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetProfiles);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out__trt__GetProfiles(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetProfiles ** SOAP_FMAC4 soap_in_PointerTo_trt__GetProfiles(struct soap *soap, const char *tag, struct _trt__GetProfiles **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct _trt__GetProfiles **)soap_malloc(soap, sizeof(struct _trt__GetProfiles *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if ((*a = soap_in__trt__GetProfiles(soap, tag, *a, type)) == NULL)
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__GetProfiles **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetProfiles, sizeof(struct _trt__GetProfiles), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetProfiles(struct soap *soap, struct _trt__GetProfiles *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetProfiles);
	if (soap_out_PointerTo_trt__GetProfiles(soap, tag?tag:"trt:GetProfiles", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetProfiles ** SOAP_FMAC4 soap_get_PointerTo_trt__GetProfiles(struct soap *soap, struct _trt__GetProfiles **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetProfiles(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetProfiles(struct soap *soap, struct __trt__GetProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetProfiles = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetProfiles(struct soap *soap, const struct __trt__GetProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetProfiles(soap, &a->trt__GetProfiles);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetProfiles(struct soap *soap, const char *tag, int id, const struct __trt__GetProfiles *a, const char *type)
{
	if (soap_out_PointerTo_trt__GetProfiles(soap, "trt:GetProfiles", -1, &a->trt__GetProfiles, ""))
	{
		return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetProfiles * SOAP_FMAC4 soap_in___trt__GetProfiles(struct soap *soap, const char *tag, struct __trt__GetProfiles *a, const char *type)
{
	size_t soap_flag_trt__GetProfiles = 1;
	short soap_flag;
	a = (struct __trt__GetProfiles *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetProfiles, sizeof(struct __trt__GetProfiles), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default___trt__GetProfiles(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_trt__GetProfiles && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_trt__GetProfiles(soap, "trt:GetProfiles", &a->trt__GetProfiles, ""))
			{	
				soap_flag_trt__GetProfiles--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{
					return NULL;
				}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetProfiles(struct soap *soap, const struct __trt__GetProfiles *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetProfiles(soap, tag?tag:"-trt:GetProfiles", id, a, type))
	{
		return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetProfiles * SOAP_FMAC4 soap_get___trt__GetProfiles(struct soap *soap, struct __trt__GetProfiles *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetProfiles(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Profile(struct soap *soap, struct tt__Profile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	a->VideoSourceConfiguration = NULL;
	a->AudioSourceConfiguration = NULL;
	a->VideoEncoderConfiguration = NULL;
	a->AudioEncoderConfiguration = NULL;
	a->VideoAnalyticsConfiguration = NULL;
	a->PTZConfiguration = NULL;
	a->MetadataConfiguration = NULL;
	a->Extension = NULL;
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->fixed = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Profile(struct soap *soap, const struct tt__Profile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__Name(soap, &a->Name);
	soap_serialize_PointerTott__VideoSourceConfiguration(soap, &a->VideoSourceConfiguration);
	soap_serialize_PointerTott__AudioSourceConfiguration(soap, &a->AudioSourceConfiguration);
	soap_serialize_PointerTott__VideoEncoderConfiguration(soap, &a->VideoEncoderConfiguration);
	soap_serialize_PointerTott__AudioEncoderConfiguration(soap, &a->AudioEncoderConfiguration);
	soap_serialize_PointerTott__VideoAnalyticsConfiguration(soap, &a->VideoAnalyticsConfiguration);
	soap_serialize_PointerTott__PTZConfiguration(soap, &a->PTZConfiguration);
	soap_serialize_PointerTott__MetadataConfiguration(soap, &a->MetadataConfiguration);
	soap_serialize_PointerTott__ProfileExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Profile(struct soap *soap, const char *tag, int id, const struct tt__Profile *a, const char *type)
{
	if (a->token != NULL)
	{
		soap_set_attr(soap, "token", a->token, 1);
	}
	if (a->fixed != NULL)
	{
		soap_set_attr(soap, "fixed", soap_xsd__boolean_2s(soap, *a->fixed), 1);
	}
	if (a->__anyAttribute != NULL)
	{
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	}
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Profile), type))
	{
		return soap->error;
	}
	if (a->Name != NULL)
	{	
		if (soap_out_tt__Name(soap, "tt:Name", -1, &a->Name, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:Name"))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__VideoSourceConfiguration(soap, "tt:VideoSourceConfiguration", -1, &a->VideoSourceConfiguration, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__AudioSourceConfiguration(soap, "tt:AudioSourceConfiguration", -1, &a->AudioSourceConfiguration, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__VideoEncoderConfiguration(soap, "tt:VideoEncoderConfiguration", -1, &a->VideoEncoderConfiguration, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__AudioEncoderConfiguration(soap, "tt:AudioEncoderConfiguration", -1, &a->AudioEncoderConfiguration, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__VideoAnalyticsConfiguration(soap, "tt:VideoAnalyticsConfiguration", -1, &a->VideoAnalyticsConfiguration, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__PTZConfiguration(soap, "tt:PTZConfiguration", -1, &a->PTZConfiguration, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__MetadataConfiguration(soap, "tt:MetadataConfiguration", -1, &a->MetadataConfiguration, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__ProfileExtension(soap, "tt:Extension", -1, &a->Extension, ""))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Profile * SOAP_FMAC4 soap_in_tt__Profile(struct soap *soap, const char *tag, struct tt__Profile *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_VideoSourceConfiguration = 1;
	size_t soap_flag_AudioSourceConfiguration = 1;
	size_t soap_flag_VideoEncoderConfiguration = 1;
	size_t soap_flag_AudioEncoderConfiguration = 1;
	size_t soap_flag_VideoAnalyticsConfiguration = 1;
	size_t soap_flag_PTZConfiguration = 1;
	size_t soap_flag_MetadataConfiguration = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__Profile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Profile, sizeof(struct tt__Profile), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__Profile(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, 0, 64))
	{
		return NULL;
	}
	{	
		const char *t = soap_attr_value(soap, "fixed", 0);
		if (t != NULL)
		{
			if (!(a->fixed = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	
				soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->fixed))
			{
				return NULL;
			}
		}
		else if (soap->error)
		{
			return NULL;
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &a->Name, "tt:Name"))
				{	
					soap_flag_Name--;
					continue;
				}
				if (soap_flag_VideoSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__VideoSourceConfiguration(soap, "tt:VideoSourceConfiguration", &a->VideoSourceConfiguration, "tt:VideoSourceConfiguration"))
					{	
						soap_flag_VideoSourceConfiguration--;
						continue;
					}
					if (soap_flag_AudioSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTott__AudioSourceConfiguration(soap, "tt:AudioSourceConfiguration", &a->AudioSourceConfiguration, "tt:AudioSourceConfiguration"))
						{	
							soap_flag_AudioSourceConfiguration--;
							continue;
						}
						if (soap_flag_VideoEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_PointerTott__VideoEncoderConfiguration(soap, "tt:VideoEncoderConfiguration", &a->VideoEncoderConfiguration, "tt:VideoEncoderConfiguration"))
							{	
								soap_flag_VideoEncoderConfiguration--;
								continue;
							}
							if (soap_flag_AudioEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
								if (soap_in_PointerTott__AudioEncoderConfiguration(soap, "tt:AudioEncoderConfiguration", &a->AudioEncoderConfiguration, "tt:AudioEncoderConfiguration"))
								{	
									soap_flag_AudioEncoderConfiguration--;
									continue;
								}
								if (soap_flag_VideoAnalyticsConfiguration && soap->error == SOAP_TAG_MISMATCH)
									if (soap_in_PointerTott__VideoAnalyticsConfiguration(soap, "tt:VideoAnalyticsConfiguration", &a->VideoAnalyticsConfiguration, "tt:VideoAnalyticsConfiguration"))
									{	
										soap_flag_VideoAnalyticsConfiguration--;
										continue;
									}
									if (soap_flag_PTZConfiguration && soap->error == SOAP_TAG_MISMATCH)
										if (soap_in_PointerTott__PTZConfiguration(soap, "tt:PTZConfiguration", &a->PTZConfiguration, "tt:PTZConfiguration"))
										{	
											soap_flag_PTZConfiguration--;
											continue;
										}
										if (soap_flag_MetadataConfiguration && soap->error == SOAP_TAG_MISMATCH)
											if (soap_in_PointerTott__MetadataConfiguration(soap, "tt:MetadataConfiguration", &a->MetadataConfiguration, "tt:MetadataConfiguration"))
											{	
												soap_flag_MetadataConfiguration--;
												continue;
											}
											if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
												if (soap_in_PointerTott__ProfileExtension(soap, "tt:Extension", &a->Extension, "tt:ProfileExtension"))
												{	
													soap_flag_Extension--;
													continue;
												}
												if (soap->error == SOAP_TAG_MISMATCH)
												{
													soap->error = soap_ignore_element(soap);
												}
												if (soap->error == SOAP_NO_TAG)
												{
													break;
												}
												if (soap->error)
												{
													return NULL;
												}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__Profile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Profile, 0, sizeof(struct tt__Profile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Profile(struct soap *soap, const struct tt__Profile *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Profile);
	if (soap_out_tt__Profile(soap, tag?tag:"tt:Profile", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Profile * SOAP_FMAC4 soap_get_tt__Profile(struct soap *soap, struct tt__Profile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Profile(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfiguration(struct soap *soap, struct tt__VideoSourceConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfiguration))
	{
		soap_serialize_tt__VideoSourceConfiguration(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfiguration(struct soap *soap, const char *tag, int id, struct tt__VideoSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfiguration);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__VideoSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfiguration(struct soap *soap, const char *tag, struct tt__VideoSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__VideoSourceConfiguration **)soap_malloc(soap, sizeof(struct tt__VideoSourceConfiguration *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__VideoSourceConfiguration(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__VideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfiguration, sizeof(struct tt__VideoSourceConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfiguration(struct soap *soap, struct tt__VideoSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoSourceConfiguration);
	if (soap_out_PointerTott__VideoSourceConfiguration(soap, tag?tag:"tt:VideoSourceConfiguration", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfiguration(struct soap *soap, struct tt__VideoSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfiguration(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IntRectangle(struct soap *soap, struct tt__IntRectangle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->x);
	soap_default_int(soap, &a->y);
	soap_default_int(soap, &a->width);
	soap_default_int(soap, &a->height);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IntRectangle(struct soap *soap, const struct tt__IntRectangle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRectangle(struct soap *soap, const char *tag, int id, const struct tt__IntRectangle *a, const char *type)
{
	soap_set_attr(soap, "x", soap_int2s(soap, a->x), 1);
	soap_set_attr(soap, "y", soap_int2s(soap, a->y), 1);
	soap_set_attr(soap, "width", soap_int2s(soap, a->width), 1);
	soap_set_attr(soap, "height", soap_int2s(soap, a->height), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntRectangle), type))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IntRectangle * SOAP_FMAC4 soap_in_tt__IntRectangle(struct soap *soap, const char *tag, struct tt__IntRectangle *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IntRectangle *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRectangle, sizeof(struct tt__IntRectangle), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__IntRectangle(soap, a);
	if (soap_s2int(soap, soap_attr_value(soap, "x", 1), &a->x))
	{
		return NULL;
	}
	if (soap_s2int(soap, soap_attr_value(soap, "y", 1), &a->y))
	{
		return NULL;
	}
	if (soap_s2int(soap, soap_attr_value(soap, "width", 1), &a->width))
	{
		return NULL;
	}
	if (soap_s2int(soap, soap_attr_value(soap, "height", 1), &a->height))
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{
				soap->error = soap_ignore_element(soap);
			}
			if (soap->error == SOAP_NO_TAG)
			{
				break;
			}
			if (soap->error)
			{
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__IntRectangle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntRectangle, 0, sizeof(struct tt__IntRectangle), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IntRectangle(struct soap *soap, const struct tt__IntRectangle *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IntRectangle);
	if (soap_out_tt__IntRectangle(soap, tag?tag:"tt:IntRectangle", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntRectangle * SOAP_FMAC4 soap_get_tt__IntRectangle(struct soap *soap, struct tt__IntRectangle *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntRectangle(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntRectangle(struct soap *soap, struct tt__IntRectangle *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntRectangle))
	{
		soap_serialize_tt__IntRectangle(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntRectangle(struct soap *soap, const char *tag, int id, struct tt__IntRectangle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntRectangle);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__IntRectangle(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IntRectangle ** SOAP_FMAC4 soap_in_PointerTott__IntRectangle(struct soap *soap, const char *tag, struct tt__IntRectangle **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__IntRectangle **)soap_malloc(soap, sizeof(struct tt__IntRectangle *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__IntRectangle(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__IntRectangle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntRectangle, sizeof(struct tt__IntRectangle), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntRectangle(struct soap *soap, struct tt__IntRectangle *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IntRectangle);
	if (soap_out_PointerTott__IntRectangle(soap, tag?tag:"tt:IntRectangle", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntRectangle ** SOAP_FMAC4 soap_get_PointerTott__IntRectangle(struct soap *soap, struct tt__IntRectangle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntRectangle(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoSourceConfiguration(struct soap *soap, struct tt__VideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__ReferenceToken(soap, &a->SourceToken);
	a->Bounds = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoSourceConfiguration(struct soap *soap, const struct tt__VideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__Name(soap, &a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_tt__ReferenceToken(soap, &a->SourceToken);
	soap_serialize_PointerTott__IntRectangle(soap, &a->Bounds);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfiguration(struct soap *soap, const char *tag, int id, const struct tt__VideoSourceConfiguration *a, const char *type)
{
	if (a->token != NULL)
	{
		soap_set_attr(soap, "token", a->token, 1);
	}
	if (a->__anyAttribute != NULL)
	{
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	}
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfiguration), type))
	{
		return soap->error;
	}
	if (a->Name != NULL)
	{	
		if (soap_out_tt__Name(soap, "tt:Name", -1, &a->Name, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:Name"))
	{
		return soap->error;
	}
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
	{
		return soap->error;
	}
	if (a->SourceToken != NULL)
	{	
		if (soap_out_tt__ReferenceToken(soap, "tt:SourceToken", -1, &a->SourceToken, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:SourceToken"))
	{
		return soap->error;
	}
	if (a->Bounds != NULL)
	{	
		if (soap_out_PointerTott__IntRectangle(soap, "tt:Bounds", -1, &a->Bounds, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:Bounds"))
	{
		return soap->error;
	}
	if (a->__any != NULL)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_outliteral(soap, "-any", a->__any + i, NULL);
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoSourceConfiguration * SOAP_FMAC4 soap_in_tt__VideoSourceConfiguration(struct soap *soap, const char *tag, struct tt__VideoSourceConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_SourceToken = 1;
	size_t soap_flag_Bounds = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__VideoSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfiguration, sizeof(struct tt__VideoSourceConfiguration), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__VideoSourceConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, 0, 64))
	{
		return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &a->Name, "tt:Name"))
				{	
					soap_flag_Name--;
					continue;
				}
				if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
					{	
						soap_flag_UseCount--;
						continue;
					}
					if (soap_flag_SourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
						if (soap_in_tt__ReferenceToken(soap, "tt:SourceToken", &a->SourceToken, "tt:ReferenceToken"))
						{	
							soap_flag_SourceToken--;
							continue;
						}
						if (soap_flag_Bounds && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_PointerTott__IntRectangle(soap, "tt:Bounds", &a->Bounds, "tt:IntRectangle"))
							{	
								soap_flag_Bounds--;
								continue;
							}
							if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
							{	
								if (a->__any == NULL)
								{	
									if (soap_blist___any == NULL)
									{
										soap_blist___any = soap_new_block(soap);
									}
									a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
									if (a->__any == NULL)
									{
										return NULL;
									}
									*a->__any = NULL;
								}
								if (soap_inliteral(soap, "-any", a->__any))
								{	
									a->__size++;
									a->__any = NULL;
									continue;
								}
							}
							if (soap->error == SOAP_TAG_MISMATCH)
							{
								soap->error = soap_ignore_element(soap);
							}
							if (soap->error == SOAP_NO_TAG)
							{
								break;
							}
							if (soap->error)
							{
								return NULL;
							}
		}
		if (a->__any)
		{
			soap_pop_block(soap, soap_blist___any);
		}
		if (a->__size)
		{
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
			{
				soap_end_block(soap, soap_blist___any);
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__VideoSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfiguration, 0, sizeof(struct tt__VideoSourceConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_SourceToken > 0 || soap_flag_Bounds > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoSourceConfiguration(struct soap *soap, const struct tt__VideoSourceConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoSourceConfiguration);
	if (soap_out_tt__VideoSourceConfiguration(soap, tag?tag:"tt:VideoSourceConfiguration", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfiguration * SOAP_FMAC4 soap_get_tt__VideoSourceConfiguration(struct soap *soap, struct tt__VideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfiguration(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioSourceConfiguration(struct soap *soap, struct tt__AudioSourceConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioSourceConfiguration))
	{
		soap_serialize_tt__AudioSourceConfiguration(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioSourceConfiguration(struct soap *soap, const char *tag, int id, struct tt__AudioSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioSourceConfiguration);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__AudioSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AudioSourceConfiguration(struct soap *soap, const char *tag, struct tt__AudioSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__AudioSourceConfiguration **)soap_malloc(soap, sizeof(struct tt__AudioSourceConfiguration *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__AudioSourceConfiguration(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__AudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioSourceConfiguration, sizeof(struct tt__AudioSourceConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioSourceConfiguration(struct soap *soap, struct tt__AudioSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AudioSourceConfiguration);
	if (soap_out_PointerTott__AudioSourceConfiguration(soap, tag?tag:"tt:AudioSourceConfiguration", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AudioSourceConfiguration(struct soap *soap, struct tt__AudioSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioSourceConfiguration(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioSourceConfiguration(struct soap *soap, struct tt__AudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__ReferenceToken(soap, &a->SourceToken);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioSourceConfiguration(struct soap *soap, const struct tt__AudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__Name(soap, &a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_tt__ReferenceToken(soap, &a->SourceToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioSourceConfiguration(struct soap *soap, const char *tag, int id, const struct tt__AudioSourceConfiguration *a, const char *type)
{
	if (a->token != NULL)
	{
		soap_set_attr(soap, "token", a->token, 1);
	}
	if (a->__anyAttribute != NULL)
	{
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	}
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioSourceConfiguration), type))
	{	
		return soap->error;
	}
	if (a->Name != NULL)
	{	
		if (soap_out_tt__Name(soap, "tt:Name", -1, &a->Name, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:Name"))
	{
		return soap->error;
	}
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
	{	
		return soap->error;
	}
	if (a->SourceToken)
	{	
		if (soap_out_tt__ReferenceToken(soap, "tt:SourceToken", -1, &a->SourceToken, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:SourceToken"))
	{
		return soap->error;
	}
	if (a->__any != NULL)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_outliteral(soap, "-any", a->__any + i, NULL);
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioSourceConfiguration * SOAP_FMAC4 soap_in_tt__AudioSourceConfiguration(struct soap *soap, const char *tag, struct tt__AudioSourceConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_SourceToken = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__AudioSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSourceConfiguration, sizeof(struct tt__AudioSourceConfiguration), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__AudioSourceConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, 0, 64))
	{
		return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &a->Name, "tt:Name"))
				{	
					soap_flag_Name--;
					continue;
				}
				if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
					{	
						soap_flag_UseCount--;
						continue;
					}
					if (soap_flag_SourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
						if (soap_in_tt__ReferenceToken(soap, "tt:SourceToken", &a->SourceToken, "tt:ReferenceToken"))
						{	
							soap_flag_SourceToken--;
							continue;
						}
						if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
						{	
							if (a->__any == NULL)
							{	
								if (soap_blist___any == NULL)
								{
									soap_blist___any = soap_new_block(soap);
								}
								a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
								if (a->__any == NULL)
								{
									return NULL;
								}
								*a->__any = NULL;
							}
							if (soap_inliteral(soap, "-any", a->__any))
							{	
								a->__size++;
								a->__any = NULL;
								continue;
							}
						}
						if (soap->error == SOAP_TAG_MISMATCH)
						{
							soap->error = soap_ignore_element(soap);
						}
						if (soap->error == SOAP_NO_TAG)
						{
							break;
						}
						if (soap->error)
						{
							return NULL;
						}
		}
		if (a->__any != NULL)
		{
			soap_pop_block(soap, soap_blist___any);
		}
		if (a->__size)
		{
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
			{
				soap_end_block(soap, soap_blist___any);
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__AudioSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSourceConfiguration, 0, sizeof(struct tt__AudioSourceConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_SourceToken > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioSourceConfiguration(struct soap *soap, const struct tt__AudioSourceConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AudioSourceConfiguration);
	if (soap_out_tt__AudioSourceConfiguration(soap, tag?tag:"tt:AudioSourceConfiguration", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioSourceConfiguration * SOAP_FMAC4 soap_get_tt__AudioSourceConfiguration(struct soap *soap, struct tt__AudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioSourceConfiguration(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoEncoderConfiguration(struct soap *soap, struct tt__VideoEncoderConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoEncoderConfiguration))
	{
		soap_serialize_tt__VideoEncoderConfiguration(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoEncoderConfiguration(struct soap *soap, const char *tag, int id, struct tt__VideoEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoEncoderConfiguration);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__VideoEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTott__VideoEncoderConfiguration(struct soap *soap, const char *tag, struct tt__VideoEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL == (a = (struct tt__VideoEncoderConfiguration **)soap_malloc(soap, sizeof(struct tt__VideoEncoderConfiguration *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL == (*a = soap_in_tt__VideoEncoderConfiguration(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__VideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderConfiguration, sizeof(struct tt__VideoEncoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoEncoderConfiguration(struct soap *soap, struct tt__VideoEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoEncoderConfiguration);
	if (soap_out_PointerTott__VideoEncoderConfiguration(soap, tag?tag:"tt:VideoEncoderConfiguration", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTott__VideoEncoderConfiguration(struct soap *soap, struct tt__VideoEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoEncoderConfiguration(soap, tag, p, type)))
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoEncoderConfiguration(struct soap *soap, struct tt__VideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__VideoEncoding(soap, &a->Encoding);
	a->Resolution = NULL;
	soap_default_float(soap, &a->Quality);
	a->RateControl = NULL;
	a->MPEG4 = NULL;
	a->H264 = NULL;
	a->Multicast = NULL;
	soap_default_string(soap, &a->SessionTimeout);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoEncoderConfiguration(struct soap *soap, const struct tt__VideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__Name(soap, &a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_PointerTott__VideoResolution(soap, &a->Resolution);
	soap_embedded(soap, &a->Quality, SOAP_TYPE_float);
	soap_serialize_PointerTott__VideoRateControl(soap, &a->RateControl);
	soap_serialize_PointerTott__Mpeg4Configuration(soap, &a->MPEG4);
	soap_serialize_PointerTott__H264Configuration(soap, &a->H264);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &a->Multicast);
	soap_serialize_string(soap, &a->SessionTimeout);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct tt__VideoEncoderConfiguration *a, const char *type)
{
	if (a->token != NULL)
	{
		soap_set_attr(soap, "token", a->token, 1);
	}

	if (a->__anyAttribute)
	{
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	}
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderConfiguration), type))
	{	
		return soap->error;
	}
	if (a->Name != NULL)
	{	
		if (soap_out_tt__Name(soap, "tt:Name", -1, &a->Name, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:Name"))
	{
		return soap->error;
	}
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
	{
		return soap->error;
	}
	if (soap_out_tt__VideoEncoding(soap, "tt:Encoding", -1, &a->Encoding, ""))
	{
		return soap->error;
	}
	if (a->Resolution != NULL)
	{	
		if (soap_out_PointerTott__VideoResolution(soap, "tt:Resolution", -1, &a->Resolution, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:Resolution"))
	{
		return soap->error;
	}
	if (soap_out_float(soap, "tt:Quality", -1, &a->Quality, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__VideoRateControl(soap, "tt:RateControl", -1, &a->RateControl, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__Mpeg4Configuration(soap, "tt:MPEG4", -1, &a->MPEG4, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__H264Configuration(soap, "tt:H264", -1, &a->H264, ""))
	{
		return soap->error;
	}
	if (a->Multicast != NULL)
	{	
		if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->Multicast, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:Multicast"))
	{
		return soap->error;
	}
	if (a->SessionTimeout != NULL)
	{	
		if (soap_out_string(soap, "tt:SessionTimeout", -1, &a->SessionTimeout, ""))
		{
			return soap->error;
		}
	}
	else if(soap_element_nil(soap, "tt:SessionTimeout"))
	{
		return soap->error;
	}
	if (a->__any != NULL)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_outliteral(soap, "-any", a->__any + i, NULL);
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoEncoderConfiguration * SOAP_FMAC4 soap_in_tt__VideoEncoderConfiguration(struct soap *soap, const char *tag, struct tt__VideoEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_Encoding = 1;
	size_t soap_flag_Resolution = 1;
	size_t soap_flag_Quality = 1;
	size_t soap_flag_RateControl = 1;
	size_t soap_flag_MPEG4 = 1;
	size_t soap_flag_H264 = 1;
	size_t soap_flag_Multicast = 1;
	size_t soap_flag_SessionTimeout = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__VideoEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderConfiguration, sizeof(struct tt__VideoEncoderConfiguration), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__VideoEncoderConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, 0, 64))
	{
		return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &a->Name, "tt:Name"))
				{	
					soap_flag_Name--;
					continue;
				}
				if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
					{	
						soap_flag_UseCount--;
						continue;
					}
					if (soap_flag_Encoding && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_tt__VideoEncoding(soap, "tt:Encoding", &a->Encoding, "tt:VideoEncoding"))
						{	
							soap_flag_Encoding--;
							continue;
						}
						if (soap_flag_Resolution && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_PointerTott__VideoResolution(soap, "tt:Resolution", &a->Resolution, "tt:VideoResolution"))
							{	
								soap_flag_Resolution--;
								continue;
							}
							if (soap_flag_Quality && soap->error == SOAP_TAG_MISMATCH)
								if (soap_in_float(soap, "tt:Quality", &a->Quality, "xsd:float"))
								{	
									soap_flag_Quality--;
									continue;
								}
								if (soap_flag_RateControl && soap->error == SOAP_TAG_MISMATCH)
									if (soap_in_PointerTott__VideoRateControl(soap, "tt:RateControl", &a->RateControl, "tt:VideoRateControl"))
									{	
										soap_flag_RateControl--;
										continue;
									}
									if (soap_flag_MPEG4 && soap->error == SOAP_TAG_MISMATCH)
										if (soap_in_PointerTott__Mpeg4Configuration(soap, "tt:MPEG4", &a->MPEG4, "tt:Mpeg4Configuration"))
										{	
											soap_flag_MPEG4--;
											continue;
										}
										if (soap_flag_H264 && soap->error == SOAP_TAG_MISMATCH)
											if (soap_in_PointerTott__H264Configuration(soap, "tt:H264", &a->H264, "tt:H264Configuration"))
											{	
												soap_flag_H264--;
												continue;
											}
											if (soap_flag_Multicast && soap->error == SOAP_TAG_MISMATCH)
												if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->Multicast, "tt:MulticastConfiguration"))
												{	
													soap_flag_Multicast--;
													continue;
												}
												if (soap_flag_SessionTimeout && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
													if (soap_in_string(soap, "tt:SessionTimeout", &a->SessionTimeout, "xsd:string"))
													{	
														soap_flag_SessionTimeout--;
														continue;
													}
													if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
													{	
														if (a->__any == NULL)
														{	
															if (soap_blist___any == NULL)
															{
																soap_blist___any = soap_new_block(soap);
															}
															a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
															if (a->__any == NULL)
																return NULL;
															*a->__any = NULL;
														}
														if (soap_inliteral(soap, "-any", a->__any))
														{	
															a->__size++;
															a->__any = NULL;
															continue;
														}
													}
													if (soap->error == SOAP_TAG_MISMATCH)
													{
														soap->error = soap_ignore_element(soap);
													}
													if (soap->error == SOAP_NO_TAG)
													{
														break;
													}
													if (soap->error)
													{
														return NULL;
													}
		}
		if (a->__any != NULL)
		{
			soap_pop_block(soap, soap_blist___any);
		}
		if (a->__size)
		{
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
			{
				soap_end_block(soap, soap_blist___any);
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__VideoEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderConfiguration, 0, sizeof(struct tt__VideoEncoderConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_Encoding > 0 || soap_flag_Resolution > 0 || soap_flag_Quality > 0 || soap_flag_Multicast > 0 || soap_flag_SessionTimeout > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncoderConfiguration(struct soap *soap, const struct tt__VideoEncoderConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoEncoderConfiguration);
	if (soap_out_tt__VideoEncoderConfiguration(soap, tag?tag:"tt:VideoEncoderConfiguration", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderConfiguration * SOAP_FMAC4 soap_get_tt__VideoEncoderConfiguration(struct soap *soap, struct tt__VideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderConfiguration(soap, tag, p, type)))
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoEncoding(struct soap *soap, enum tt__VideoEncoding *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__VideoEncoding
	*a = SOAP_DEFAULT_tt__VideoEncoding;
#else
	*a = (enum tt__VideoEncoding)0;
#endif
}

static const struct soap_code_map soap_codes_tt__VideoEncoding[] =
{	
	{ (long)tt__VideoEncoding__JPEG, "JPEG" },
	{ (long)tt__VideoEncoding__MPEG4, "MPEG4" },
	{ (long)tt__VideoEncoding__H264, "H264" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__VideoEncoding2s(struct soap *soap, enum tt__VideoEncoding n)
{	
	const char *s = soap_code_str(soap_codes_tt__VideoEncoding, (long)n);
	if (s != NULL)
	{
		return s;
	}
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoding(struct soap *soap, const char *tag, int id, const enum tt__VideoEncoding *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoding), type) || soap_send(soap, soap_tt__VideoEncoding2s(soap, *a)))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__VideoEncoding(struct soap *soap, const char *s, enum tt__VideoEncoding *a)
{
	const struct soap_code_map *map;
	if (s == NULL)
	{
		return soap->error;
	}
	map = soap_code(soap_codes_tt__VideoEncoding, s);
	if (map != NULL)
	{
		*a = (enum tt__VideoEncoding)map->code;
	}
	else
	{	
		long n;

		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
		{
			return soap->error = SOAP_TYPE;
		}
		*a = (enum tt__VideoEncoding)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__VideoEncoding * SOAP_FMAC4 soap_in_tt__VideoEncoding(struct soap *soap, const char *tag, enum tt__VideoEncoding *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}

	a = (enum tt__VideoEncoding *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoding, sizeof(enum tt__VideoEncoding), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	
		if (!a || soap_s2tt__VideoEncoding(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (enum tt__VideoEncoding *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoding, 0, sizeof(enum tt__VideoEncoding), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncoding(struct soap *soap, const enum tt__VideoEncoding *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoEncoding);
	if (soap_out_tt__VideoEncoding(soap, tag?tag:"tt:VideoEncoding", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__VideoEncoding * SOAP_FMAC4 soap_get_tt__VideoEncoding(struct soap *soap, enum tt__VideoEncoding *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoding(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}

	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoRateControl(struct soap *soap, struct tt__VideoRateControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->FrameRateLimit);
	soap_default_int(soap, &a->EncodingInterval);
	soap_default_int(soap, &a->BitrateLimit);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoRateControl(struct soap *soap, const struct tt__VideoRateControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->FrameRateLimit, SOAP_TYPE_int);
	soap_embedded(soap, &a->EncodingInterval, SOAP_TYPE_int);
	soap_embedded(soap, &a->BitrateLimit, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoRateControl(struct soap *soap, const char *tag, int id, const struct tt__VideoRateControl *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoRateControl), type))
	{
		return soap->error;
	}
	if (soap_out_int(soap, "tt:FrameRateLimit", -1, &a->FrameRateLimit, ""))
	{
		return soap->error;
	}
	if (soap_out_int(soap, "tt:EncodingInterval", -1, &a->EncodingInterval, ""))
	{
		return soap->error;
	}
	if (soap_out_int(soap, "tt:BitrateLimit", -1, &a->BitrateLimit, ""))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoRateControl * SOAP_FMAC4 soap_in_tt__VideoRateControl(struct soap *soap, const char *tag, struct tt__VideoRateControl *a, const char *type)
{
	size_t soap_flag_FrameRateLimit = 1;
	size_t soap_flag_EncodingInterval = 1;
	size_t soap_flag_BitrateLimit = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__VideoRateControl *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoRateControl, sizeof(struct tt__VideoRateControl), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__VideoRateControl(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FrameRateLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:FrameRateLimit", &a->FrameRateLimit, "xsd:int"))
				{	
					soap_flag_FrameRateLimit--;
					continue;
				}
				if (soap_flag_EncodingInterval && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_int(soap, "tt:EncodingInterval", &a->EncodingInterval, "xsd:int"))
					{	
						soap_flag_EncodingInterval--;
						continue;
					}
					if (soap_flag_BitrateLimit && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_int(soap, "tt:BitrateLimit", &a->BitrateLimit, "xsd:int"))
						{	
							soap_flag_BitrateLimit--;
							continue;
						}
						if (soap->error == SOAP_TAG_MISMATCH)
						{
							soap->error = soap_ignore_element(soap);
						}
						if (soap->error == SOAP_NO_TAG)
						{
							break;
						}
						if (soap->error)
						{
							return NULL;
						}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__VideoRateControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoRateControl, 0, sizeof(struct tt__VideoRateControl), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FrameRateLimit > 0 || soap_flag_EncodingInterval > 0 || soap_flag_BitrateLimit > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoRateControl(struct soap *soap, const struct tt__VideoRateControl *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoRateControl);
	if (soap_out_tt__VideoRateControl(soap, tag?tag:"tt:VideoRateControl", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoRateControl * SOAP_FMAC4 soap_get_tt__VideoRateControl(struct soap *soap, struct tt__VideoRateControl *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoRateControl(soap, tag, p, type)))
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoResolution(struct soap *soap, struct tt__VideoResolution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Width);
	soap_default_int(soap, &a->Height);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoResolution(struct soap *soap, const struct tt__VideoResolution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Width, SOAP_TYPE_int);
	soap_embedded(soap, &a->Height, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoResolution(struct soap *soap, const char *tag, int id, const struct tt__VideoResolution *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoResolution), type))
	{
		return soap->error;
	}
	if (soap_out_int(soap, "tt:Width", -1, &a->Width, ""))
	{
		return soap->error;
	}
	if (soap_out_int(soap, "tt:Height", -1, &a->Height, ""))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoResolution * SOAP_FMAC4 soap_in_tt__VideoResolution(struct soap *soap, const char *tag, struct tt__VideoResolution *a, const char *type)
{
	size_t soap_flag_Width = 1;
	size_t soap_flag_Height = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__VideoResolution *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoResolution, sizeof(struct tt__VideoResolution), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__VideoResolution(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Width && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Width", &a->Width, "xsd:int"))
				{	
					soap_flag_Width--;
					continue;
				}
				if (soap_flag_Height && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_int(soap, "tt:Height", &a->Height, "xsd:int"))
					{	
						soap_flag_Height--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH)
						soap->error = soap_ignore_element(soap);
					if (soap->error == SOAP_NO_TAG)
						break;
					if (soap->error)
						return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__VideoResolution *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoResolution, 0, sizeof(struct tt__VideoResolution), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Width > 0 || soap_flag_Height > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoResolution(struct soap *soap, const struct tt__VideoResolution *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoResolution);
	if (soap_out_tt__VideoResolution(soap, tag?tag:"tt:VideoResolution", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoResolution * SOAP_FMAC4 soap_get_tt__VideoResolution(struct soap *soap, struct tt__VideoResolution *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoResolution(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{			
			return NULL;
		}
	}
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__H264Profile(struct soap *soap, enum tt__H264Profile *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__H264Profile
	*a = SOAP_DEFAULT_tt__H264Profile;
#else
	*a = (enum tt__H264Profile)0;
#endif
}

static const struct soap_code_map soap_codes_tt__H264Profile[] =
{	
	{ (long)tt__H264Profile__Baseline, "Baseline" },
	{ (long)tt__H264Profile__Main, "Main" },
	{ (long)tt__H264Profile__Extended, "Extended" },
	{ (long)tt__H264Profile__High, "High" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__H264Profile2s(struct soap *soap, enum tt__H264Profile n)
{	
	const char *s = soap_code_str(soap_codes_tt__H264Profile, (long)n);
	if (s != NULL)
	{ 
		return s;
	}
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Profile(struct soap *soap, const char *tag, int id, const enum tt__H264Profile *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Profile), type) || soap_send(soap, soap_tt__H264Profile2s(soap, *a)))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__H264Profile(struct soap *soap, const char *s, enum tt__H264Profile *a)
{
	const struct soap_code_map *map;
	if (s == NULL)
	{
		return soap->error;
	}
	map = soap_code(soap_codes_tt__H264Profile, s);
	if (map != NULL)
	{
		*a = (enum tt__H264Profile)map->code;
	}
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
		{
			return soap->error = SOAP_TYPE;
		}
		*a = (enum tt__H264Profile)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__H264Profile * SOAP_FMAC4 soap_in_tt__H264Profile(struct soap *soap, const char *tag, enum tt__H264Profile *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (enum tt__H264Profile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Profile, sizeof(enum tt__H264Profile), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	
		if (!a || soap_s2tt__H264Profile(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (enum tt__H264Profile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Profile, 0, sizeof(enum tt__H264Profile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__H264Profile(struct soap *soap, const enum tt__H264Profile *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__H264Profile);
	if (soap_out_tt__H264Profile(soap, tag?tag:"tt:H264Profile", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__H264Profile * SOAP_FMAC4 soap_get_tt__H264Profile(struct soap *soap, enum tt__H264Profile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Profile(soap, tag, p, type)))
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Mpeg4Profile(struct soap *soap, enum tt__Mpeg4Profile *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__Mpeg4Profile
	*a = SOAP_DEFAULT_tt__Mpeg4Profile;
#else
	*a = (enum tt__Mpeg4Profile)0;
#endif
}

static const struct soap_code_map soap_codes_tt__Mpeg4Profile[] =
{	
	{ (long)tt__Mpeg4Profile__SP, "SP" },
	{ (long)tt__Mpeg4Profile__ASP, "ASP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Mpeg4Profile2s(struct soap *soap, enum tt__Mpeg4Profile n)
{	
	const char *s = soap_code_str(soap_codes_tt__Mpeg4Profile, (long)n);
	if (s != NULL)
	{
		return s;
	}
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Profile(struct soap *soap, const char *tag, int id, const enum tt__Mpeg4Profile *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Profile), type) || soap_send(soap, soap_tt__Mpeg4Profile2s(soap, *a)))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Mpeg4Profile(struct soap *soap, const char *s, enum tt__Mpeg4Profile *a)
{
	const struct soap_code_map *map;
	if (s == NULL)
	{
		return soap->error;
	}
	map = soap_code(soap_codes_tt__Mpeg4Profile, s);
	if (map != NULL)
	{
		*a = (enum tt__Mpeg4Profile)map->code;
	}
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
		{
			return soap->error = SOAP_TYPE;
		}
		*a = (enum tt__Mpeg4Profile)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Mpeg4Profile * SOAP_FMAC4 soap_in_tt__Mpeg4Profile(struct soap *soap, const char *tag, enum tt__Mpeg4Profile *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}

	a = (enum tt__Mpeg4Profile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Profile, sizeof(enum tt__Mpeg4Profile), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	
		if (!a || soap_s2tt__Mpeg4Profile(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (enum tt__Mpeg4Profile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Profile, 0, sizeof(enum tt__Mpeg4Profile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Mpeg4Profile(struct soap *soap, const enum tt__Mpeg4Profile *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Mpeg4Profile);
	if (soap_out_tt__Mpeg4Profile(soap, tag?tag:"tt:Mpeg4Profile", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Mpeg4Profile * SOAP_FMAC4 soap_get_tt__Mpeg4Profile(struct soap *soap, enum tt__Mpeg4Profile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Profile(soap, tag, p, type)))
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Mpeg4Configuration(struct soap *soap, struct tt__Mpeg4Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->GovLength);
	soap_default_tt__Mpeg4Profile(soap, &a->Mpeg4Profile);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Mpeg4Configuration(struct soap *soap, const struct tt__Mpeg4Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->GovLength, SOAP_TYPE_int);
	soap_embedded(soap, &a->Mpeg4Profile, SOAP_TYPE_tt__Mpeg4Profile);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Configuration(struct soap *soap, const char *tag, int id, const struct tt__Mpeg4Configuration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Configuration), type))
	{
		return soap->error;
	}
	if (soap_out_int(soap, "tt:GovLength", -1, &a->GovLength, ""))
	{
		return soap->error;
	}
	if (soap_out_tt__Mpeg4Profile(soap, "tt:Mpeg4Profile", -1, &a->Mpeg4Profile, ""))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Mpeg4Configuration * SOAP_FMAC4 soap_in_tt__Mpeg4Configuration(struct soap *soap, const char *tag, struct tt__Mpeg4Configuration *a, const char *type)
{
	size_t soap_flag_GovLength = 1;
	size_t soap_flag_Mpeg4Profile = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Mpeg4Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Configuration, sizeof(struct tt__Mpeg4Configuration), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__Mpeg4Configuration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GovLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:GovLength", &a->GovLength, "xsd:int"))
				{	
					soap_flag_GovLength--;
					continue;
				}
				if (soap_flag_Mpeg4Profile && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_tt__Mpeg4Profile(soap, "tt:Mpeg4Profile", &a->Mpeg4Profile, "tt:Mpeg4Profile"))
					{	
						soap_flag_Mpeg4Profile--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH)
					{
						soap->error = soap_ignore_element(soap);
					}
					if (soap->error == SOAP_NO_TAG)
					{
						break;
					}
					if (soap->error)
					{
						return NULL;
					}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__Mpeg4Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Configuration, 0, sizeof(struct tt__Mpeg4Configuration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GovLength > 0 || soap_flag_Mpeg4Profile > 0))
	{
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Mpeg4Configuration(struct soap *soap, const struct tt__Mpeg4Configuration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Mpeg4Configuration);
	if (soap_out_tt__Mpeg4Configuration(soap, tag?tag:"tt:Mpeg4Configuration", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4Configuration * SOAP_FMAC4 soap_get_tt__Mpeg4Configuration(struct soap *soap, struct tt__Mpeg4Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Configuration(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__H264Configuration(struct soap *soap, struct tt__H264Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->GovLength);
	soap_default_tt__H264Profile(soap, &a->H264Profile);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__H264Configuration(struct soap *soap, const struct tt__H264Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->GovLength, SOAP_TYPE_int);
	soap_embedded(soap, &a->H264Profile, SOAP_TYPE_tt__H264Profile);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Configuration(struct soap *soap, const char *tag, int id, const struct tt__H264Configuration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Configuration), type))
	{
		return soap->error;
	}
	if (soap_out_int(soap, "tt:GovLength", -1, &a->GovLength, ""))
	{
		return soap->error;
	}
	if (soap_out_tt__H264Profile(soap, "tt:H264Profile", -1, &a->H264Profile, ""))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__H264Configuration * SOAP_FMAC4 soap_in_tt__H264Configuration(struct soap *soap, const char *tag, struct tt__H264Configuration *a, const char *type)
{
	size_t soap_flag_GovLength = 1;
	size_t soap_flag_H264Profile = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__H264Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Configuration, sizeof(struct tt__H264Configuration), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__H264Configuration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GovLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:GovLength", &a->GovLength, "xsd:int"))
				{	
					soap_flag_GovLength--;
					continue;
				}
				if (soap_flag_H264Profile && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_tt__H264Profile(soap, "tt:H264Profile", &a->H264Profile, "tt:H264Profile"))
					{	
						soap_flag_H264Profile--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH)
					{
						soap->error = soap_ignore_element(soap);
					}
					if (soap->error == SOAP_NO_TAG)
					{
						break;
					}
					if (soap->error)
					{
						return NULL;
					}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{
		a = (struct tt__H264Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Configuration, 0, sizeof(struct tt__H264Configuration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GovLength > 0 || soap_flag_H264Profile > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__H264Configuration(struct soap *soap, const struct tt__H264Configuration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__H264Configuration);
	if (soap_out_tt__H264Configuration(soap, tag?tag:"tt:H264Configuration", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264Configuration * SOAP_FMAC4 soap_get_tt__H264Configuration(struct soap *soap, struct tt__H264Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Configuration(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MulticastConfiguration(struct soap *soap, struct tt__MulticastConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Address = NULL;
	soap_default_int(soap, &a->Port);
	soap_default_int(soap, &a->TTL);
	soap_default_xsd__boolean_(soap, &a->AutoStart);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MulticastConfiguration(struct soap *soap, const struct tt__MulticastConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IPAddress(soap, &a->Address);
	soap_embedded(soap, &a->Port, SOAP_TYPE_int);
	soap_embedded(soap, &a->TTL, SOAP_TYPE_int);
	soap_embedded(soap, &a->AutoStart, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MulticastConfiguration(struct soap *soap, const char *tag, int id, const struct tt__MulticastConfiguration *a, const char *type)
{
	if (a->__anyAttribute != NULL)
	{
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	}
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MulticastConfiguration), type))
	{
		return soap->error;
	}
	if (a->Address != NULL)
	{	
		if (soap_out_PointerTott__IPAddress(soap, "tt:Address", -1, &a->Address, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:Address"))
	{
		return soap->error;
	}
	if (soap_out_int(soap, "tt:Port", -1, &a->Port, ""))
	{
		return soap->error;
	}
	if (soap_out_int(soap, "tt:TTL", -1, &a->TTL, ""))
	{
		return soap->error;
	}
	if (soap_out_xsd__boolean_(soap, "tt:AutoStart", -1, &a->AutoStart, ""))
	{
		return soap->error;
	}
	if (a->__any != NULL)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_outliteral(soap, "-any", a->__any + i, NULL);
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MulticastConfiguration * SOAP_FMAC4 soap_in_tt__MulticastConfiguration(struct soap *soap, const char *tag, struct tt__MulticastConfiguration *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_Port = 1;
	size_t soap_flag_TTL = 1;
	size_t soap_flag_AutoStart = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__MulticastConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MulticastConfiguration, sizeof(struct tt__MulticastConfiguration), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__MulticastConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPAddress(soap, "tt:Address", &a->Address, "tt:IPAddress"))
				{	
					soap_flag_Address--;
					continue;
				}
				if (soap_flag_Port && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_int(soap, "tt:Port", &a->Port, "xsd:int"))
					{	
						soap_flag_Port--;
						continue;
					}
					if (soap_flag_TTL && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_int(soap, "tt:TTL", &a->TTL, "xsd:int"))
						{
							soap_flag_TTL--;
							continue;
						}
						if (soap_flag_AutoStart && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_xsd__boolean_(soap, "tt:AutoStart", &a->AutoStart, "xsd:boolean"))
							{	
								soap_flag_AutoStart--;
								continue;
							}
							if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
							{	
								if (a->__any == NULL)
								{	
									if (soap_blist___any == NULL)
										soap_blist___any = soap_new_block(soap);
									a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
									if (a->__any == NULL)
										return NULL;
									*a->__any = NULL;
								}
								if (soap_inliteral(soap, "-any", a->__any))
								{	
									a->__size++;
									a->__any = NULL;
									continue;
								}
							}
							if (soap->error == SOAP_TAG_MISMATCH)
							{
								soap->error = soap_ignore_element(soap);
							}
							if (soap->error == SOAP_NO_TAG)
							{
								break;
							}
							if (soap->error)
							{
								return NULL;
							}
		}
		if (a->__any != NULL)
		{
			soap_pop_block(soap, soap_blist___any);
		}
		if (a->__size)
		{
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}	
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
			{
				soap_end_block(soap, soap_blist___any);
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__MulticastConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MulticastConfiguration, 0, sizeof(struct tt__MulticastConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0 || soap_flag_Port > 0 || soap_flag_TTL > 0 || soap_flag_AutoStart > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MulticastConfiguration(struct soap *soap, const struct tt__MulticastConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__MulticastConfiguration);
	if (soap_out_tt__MulticastConfiguration(soap, tag?tag:"tt:MulticastConfiguration", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MulticastConfiguration * SOAP_FMAC4 soap_get_tt__MulticastConfiguration(struct soap *soap, struct tt__MulticastConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MulticastConfiguration(soap, tag, p, type)))
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoResolution(struct soap *soap, struct tt__VideoResolution *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoResolution))
	{
		soap_serialize_tt__VideoResolution(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoResolution(struct soap *soap, const char *tag, int id, struct tt__VideoResolution *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoResolution);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__VideoResolution(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoResolution ** SOAP_FMAC4 soap_in_PointerTott__VideoResolution(struct soap *soap, const char *tag, struct tt__VideoResolution **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
	{
		if ((a = (struct tt__VideoResolution **)soap_malloc(soap, sizeof(struct tt__VideoResolution *))) == NULL)
		{ 
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__VideoResolution(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__VideoResolution **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoResolution, sizeof(struct tt__VideoResolution), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoResolution(struct soap *soap, struct tt__VideoResolution *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoResolution);
	if (soap_out_PointerTott__VideoResolution(soap, tag?tag:"tt:VideoResolution", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoResolution ** SOAP_FMAC4 soap_get_PointerTott__VideoResolution(struct soap *soap, struct tt__VideoResolution **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoResolution(soap, tag, p, type)))
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoRateControl(struct soap *soap, struct tt__VideoRateControl *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoRateControl))
	{
		soap_serialize_tt__VideoRateControl(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoRateControl(struct soap *soap, const char *tag, int id, struct tt__VideoRateControl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoRateControl);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__VideoRateControl(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoRateControl ** SOAP_FMAC4 soap_in_PointerTott__VideoRateControl(struct soap *soap, const char *tag, struct tt__VideoRateControl **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (!(a = (struct tt__VideoRateControl **)soap_malloc(soap, sizeof(struct tt__VideoRateControl *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__VideoRateControl(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__VideoRateControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoRateControl, sizeof(struct tt__VideoRateControl), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoRateControl(struct soap *soap, struct tt__VideoRateControl *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoRateControl);
	if (soap_out_PointerTott__VideoRateControl(soap, tag?tag:"tt:VideoRateControl", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoRateControl ** SOAP_FMAC4 soap_get_PointerTott__VideoRateControl(struct soap *soap, struct tt__VideoRateControl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoRateControl(soap, tag, p, type)))
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4Configuration(struct soap *soap, struct tt__Mpeg4Configuration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Mpeg4Configuration))
	{
		soap_serialize_tt__Mpeg4Configuration(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4Configuration(struct soap *soap, const char *tag, int id, struct tt__Mpeg4Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Mpeg4Configuration);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__Mpeg4Configuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Mpeg4Configuration ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4Configuration(struct soap *soap, const char *tag, struct tt__Mpeg4Configuration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (!(a = (struct tt__Mpeg4Configuration **)soap_malloc(soap, sizeof(struct tt__Mpeg4Configuration *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__Mpeg4Configuration(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__Mpeg4Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Configuration, sizeof(struct tt__Mpeg4Configuration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{	
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4Configuration(struct soap *soap, struct tt__Mpeg4Configuration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Mpeg4Configuration);
	if (soap_out_PointerTott__Mpeg4Configuration(soap, tag?tag:"tt:Mpeg4Configuration", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4Configuration ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4Configuration(struct soap *soap, struct tt__Mpeg4Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Mpeg4Configuration(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264Configuration(struct soap *soap, struct tt__H264Configuration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__H264Configuration))
	{
		soap_serialize_tt__H264Configuration(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264Configuration(struct soap *soap, const char *tag, int id, struct tt__H264Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__H264Configuration);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__H264Configuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__H264Configuration ** SOAP_FMAC4 soap_in_PointerTott__H264Configuration(struct soap *soap, const char *tag, struct tt__H264Configuration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
	{
		if (!(a = (struct tt__H264Configuration **)soap_malloc(soap, sizeof(struct tt__H264Configuration *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__H264Configuration(soap, tag, *a, type)))	
		{ 
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__H264Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Configuration, sizeof(struct tt__H264Configuration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264Configuration(struct soap *soap, struct tt__H264Configuration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__H264Configuration);
	if (soap_out_PointerTott__H264Configuration(soap, tag?tag:"tt:H264Configuration", id, a, type))
	{	
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264Configuration ** SOAP_FMAC4 soap_get_PointerTott__H264Configuration(struct soap *soap, struct tt__H264Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__H264Configuration(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MulticastConfiguration(struct soap *soap, struct tt__MulticastConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MulticastConfiguration))
	{
		soap_serialize_tt__MulticastConfiguration(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MulticastConfiguration(struct soap *soap, const char *tag, int id, struct tt__MulticastConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MulticastConfiguration);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__MulticastConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MulticastConfiguration ** SOAP_FMAC4 soap_in_PointerTott__MulticastConfiguration(struct soap *soap, const char *tag, struct tt__MulticastConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__MulticastConfiguration **)soap_malloc(soap, sizeof(struct tt__MulticastConfiguration *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if ((*a = soap_in_tt__MulticastConfiguration(soap, tag, *a, type)) != NULL)
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__MulticastConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MulticastConfiguration, sizeof(struct tt__MulticastConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MulticastConfiguration(struct soap *soap, struct tt__MulticastConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MulticastConfiguration);
	if (soap_out_PointerTott__MulticastConfiguration(soap, tag?tag:"tt:MulticastConfiguration", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MulticastConfiguration ** SOAP_FMAC4 soap_get_PointerTott__MulticastConfiguration(struct soap *soap, struct tt__MulticastConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MulticastConfiguration(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioEncoderConfiguration(struct soap *soap, struct tt__AudioEncoderConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioEncoderConfiguration))
	{
		soap_serialize_tt__AudioEncoderConfiguration(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioEncoderConfiguration(struct soap *soap, const char *tag, int id, struct tt__AudioEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioEncoderConfiguration);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__AudioEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AudioEncoderConfiguration(struct soap *soap, const char *tag, struct tt__AudioEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__AudioEncoderConfiguration **)soap_malloc(soap, sizeof(struct tt__AudioEncoderConfiguration *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__AudioEncoderConfiguration(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__AudioEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioEncoderConfiguration, sizeof(struct tt__AudioEncoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioEncoderConfiguration(struct soap *soap, struct tt__AudioEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AudioEncoderConfiguration);
	if (soap_out_PointerTott__AudioEncoderConfiguration(soap, tag?tag:"tt:AudioEncoderConfiguration", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AudioEncoderConfiguration(struct soap *soap, struct tt__AudioEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioEncoderConfiguration(soap, tag, p, type)))
	{
		if (soap_getindependent(soap))	
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioEncoding(struct soap *soap, enum tt__AudioEncoding *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__AudioEncoding
	*a = SOAP_DEFAULT_tt__AudioEncoding;
#else
	*a = (enum tt__AudioEncoding)0;
#endif
}

static const struct soap_code_map soap_codes_tt__AudioEncoding[] =
{	
	{ (long)tt__AudioEncoding__G711, "G711" },
	{ (long)tt__AudioEncoding__G726, "G726" },
	{ (long)tt__AudioEncoding__AAC, "AAC" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__AudioEncoding2s(struct soap *soap, enum tt__AudioEncoding n)
{	
	const char *s = soap_code_str(soap_codes_tt__AudioEncoding, (long)n);
	if (s != NULL)
	{
		return s;
	}
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoding(struct soap *soap, const char *tag, int id, const enum tt__AudioEncoding *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoding), type) || soap_send(soap, soap_tt__AudioEncoding2s(soap, *a)))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__AudioEncoding(struct soap *soap, const char *s, enum tt__AudioEncoding *a)
{
	const struct soap_code_map *map;
	if (s == NULL)
	{
		return soap->error;
	}
	map = soap_code(soap_codes_tt__AudioEncoding, s);
	if (map != NULL)
	{
		*a = (enum tt__AudioEncoding)map->code;
	}
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
		{
			return soap->error = SOAP_TYPE;
		}
		*a = (enum tt__AudioEncoding)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__AudioEncoding * SOAP_FMAC4 soap_in_tt__AudioEncoding(struct soap *soap, const char *tag, enum tt__AudioEncoding *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (enum tt__AudioEncoding *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoding, sizeof(enum tt__AudioEncoding), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	
		if ((a == NULL) || soap_s2tt__AudioEncoding(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (enum tt__AudioEncoding *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoding, 0, sizeof(enum tt__AudioEncoding), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioEncoding(struct soap *soap, const enum tt__AudioEncoding *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AudioEncoding);
	if (soap_out_tt__AudioEncoding(soap, tag?tag:"tt:AudioEncoding", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__AudioEncoding * SOAP_FMAC4 soap_get_tt__AudioEncoding(struct soap *soap, enum tt__AudioEncoding *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoding(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioEncoderConfiguration(struct soap *soap, struct tt__AudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__AudioEncoding(soap, &a->Encoding);
	soap_default_int(soap, &a->Bitrate);
	soap_default_int(soap, &a->SampleRate);
	a->Multicast = NULL;
	soap_default_string(soap, &a->SessionTimeout);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioEncoderConfiguration(struct soap *soap, const struct tt__AudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__Name(soap, &a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_embedded(soap, &a->Bitrate, SOAP_TYPE_int);
	soap_embedded(soap, &a->SampleRate, SOAP_TYPE_int);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &a->Multicast);
	soap_serialize_string(soap, &a->SessionTimeout);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct tt__AudioEncoderConfiguration *a, const char *type)
{
	if (a->token != NULL)
	{
		soap_set_attr(soap, "token", a->token, 1);
	}
	if (a->__anyAttribute != NULL)
	{
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	}
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoderConfiguration), type))
	{
		return soap->error;
	}
	if (a->Name != NULL)
	{	
		if (soap_out_tt__Name(soap, "tt:Name", -1, &a->Name, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:Name"))
	{
		return soap->error;
	}
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
	{
		return soap->error;
	}
	if (soap_out_tt__AudioEncoding(soap, "tt:Encoding", -1, &a->Encoding, ""))
	{
		return soap->error;
	}
	if (soap_out_int(soap, "tt:Bitrate", -1, &a->Bitrate, ""))
	{	
		return soap->error;
	}
	if (soap_out_int(soap, "tt:SampleRate", -1, &a->SampleRate, ""))
	{
		return soap->error;
	}
	if (a->Multicast != NULL)
	{	
		if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->Multicast, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:Multicast"))
	{
		return soap->error;
	}
	if (a->SessionTimeout != NULL)
	{	
		if (soap_out_string(soap, "tt:SessionTimeout", -1, &a->SessionTimeout, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:SessionTimeout"))
	{
		return soap->error;
	}
	if (a->__any != NULL)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_outliteral(soap, "-any", a->__any + i, NULL);
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioEncoderConfiguration * SOAP_FMAC4 soap_in_tt__AudioEncoderConfiguration(struct soap *soap, const char *tag, struct tt__AudioEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_Encoding = 1;
	size_t soap_flag_Bitrate = 1;
	size_t soap_flag_SampleRate = 1;
	size_t soap_flag_Multicast = 1;
	size_t soap_flag_SessionTimeout = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__AudioEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoderConfiguration, sizeof(struct tt__AudioEncoderConfiguration), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__AudioEncoderConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, 0, 64))
	{
		return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &a->Name, "tt:Name"))
				{	
					soap_flag_Name--;
					continue;
				}
				if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
					{	
						soap_flag_UseCount--;
						continue;
					}
					if (soap_flag_Encoding && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_tt__AudioEncoding(soap, "tt:Encoding", &a->Encoding, "tt:AudioEncoding"))
						{	
							soap_flag_Encoding--;
							continue;
						}
						if (soap_flag_Bitrate && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_int(soap, "tt:Bitrate", &a->Bitrate, "xsd:int"))
							{	
								soap_flag_Bitrate--;
								continue;
							}
							if (soap_flag_SampleRate && soap->error == SOAP_TAG_MISMATCH)
								if (soap_in_int(soap, "tt:SampleRate", &a->SampleRate, "xsd:int"))
								{	
									soap_flag_SampleRate--;
									continue;
								}
								if (soap_flag_Multicast && soap->error == SOAP_TAG_MISMATCH)
									if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->Multicast, "tt:MulticastConfiguration"))
									{	
										soap_flag_Multicast--;
										continue;
									}
									if (soap_flag_SessionTimeout && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
										if (soap_in_string(soap, "tt:SessionTimeout", &a->SessionTimeout, "xsd:string"))
										{	
											soap_flag_SessionTimeout--;
											continue;
										}
										if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
										{	
											if (a->__any == NULL)
											{	
												if (soap_blist___any == NULL)
												{
													soap_blist___any = soap_new_block(soap);
												}
												a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
												if (a->__any == NULL)
												{
													return NULL;
												}
												*a->__any = NULL;
											}
											if (soap_inliteral(soap, "-any", a->__any))
											{	
												a->__size++;
												a->__any = NULL;
												continue;
											}
										}
										if (soap->error == SOAP_TAG_MISMATCH)
										{
											soap->error = soap_ignore_element(soap);
										}
										if (soap->error == SOAP_NO_TAG)
										{
											break;
										}
										if (soap->error)
										{
											return NULL;
										}
		}
		if (a->__any != NULL)
		{
			soap_pop_block(soap, soap_blist___any);
		}
		if (a->__size)
		{
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
			{
				soap_end_block(soap, soap_blist___any);
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__AudioEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoderConfiguration, 0, sizeof(struct tt__AudioEncoderConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_Encoding > 0 || soap_flag_Bitrate > 0 || soap_flag_SampleRate > 0 || soap_flag_Multicast > 0 || soap_flag_SessionTimeout > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioEncoderConfiguration(struct soap *soap, const struct tt__AudioEncoderConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AudioEncoderConfiguration);
	if (soap_out_tt__AudioEncoderConfiguration(soap, tag?tag:"tt:AudioEncoderConfiguration", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioEncoderConfiguration * SOAP_FMAC4 soap_get_tt__AudioEncoderConfiguration(struct soap *soap, struct tt__AudioEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoderConfiguration(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, struct tt__VideoAnalyticsConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoAnalyticsConfiguration))
	{
		soap_serialize_tt__VideoAnalyticsConfiguration(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, struct tt__VideoAnalyticsConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoAnalyticsConfiguration);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__VideoAnalyticsConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoAnalyticsConfiguration ** SOAP_FMAC4 soap_in_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct tt__VideoAnalyticsConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL == (a = (struct tt__VideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(struct tt__VideoAnalyticsConfiguration *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__VideoAnalyticsConfiguration(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__VideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoAnalyticsConfiguration, sizeof(struct tt__VideoAnalyticsConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, struct tt__VideoAnalyticsConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoAnalyticsConfiguration);
	if (soap_out_PointerTott__VideoAnalyticsConfiguration(soap, tag?tag:"tt:VideoAnalyticsConfiguration", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoAnalyticsConfiguration ** SOAP_FMAC4 soap_get_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, struct tt__VideoAnalyticsConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoAnalyticsConfiguration(soap, tag, p, type)))
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoAnalyticsConfiguration(struct soap *soap, struct tt__VideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->AnalyticsEngineConfiguration = NULL;
	a->RuleEngineConfiguration = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoAnalyticsConfiguration(struct soap *soap, const struct tt__VideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__Name(soap, &a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	//soap_serialize_PointerTott__AnalyticsEngineConfiguration(soap, &a->AnalyticsEngineConfiguration);
	//soap_serialize_PointerTott__RuleEngineConfiguration(soap, &a->RuleEngineConfiguration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const struct tt__VideoAnalyticsConfiguration *a, const char *type)
{
	if (a->token != NULL)
	{
		soap_set_attr(soap, "token", a->token, 1);
	}
	if (a->__anyAttribute != NULL)
	{
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	}
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoAnalyticsConfiguration), type))
	{
		return soap->error;
	}
	if (a->Name != NULL)
	{	
		if (soap_out_tt__Name(soap, "tt:Name", -1, &a->Name, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:Name"))
	{
		return soap->error;
	}
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
	{
		return soap->error;
	}
#if 0
	if (a->AnalyticsEngineConfiguration)
	{	if (soap_out_PointerTott__AnalyticsEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", -1, &a->AnalyticsEngineConfiguration, ""))
	return soap->error;
	}
	else
#endif

		if (soap_element_nil(soap, "tt:AnalyticsEngineConfiguration"))
		{
			return soap->error;
		}
		//if (a->RuleEngineConfiguration)
		//{	
		//if (soap_out_PointerTott__RuleEngineConfiguration(soap, "tt:RuleEngineConfiguration", -1, &a->RuleEngineConfiguration, ""))
		//	return soap->error;
		//	return
		//}
		//else 
		if (soap_element_nil(soap, "tt:RuleEngineConfiguration"))
		{	
			return soap->error;
		}
		if (a->__any != NULL)
		{	
			int i;
			for (i = 0; i < a->__size; i++)
			{
				soap_outliteral(soap, "-any", a->__any + i, NULL);
			}
		}
		return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoAnalyticsConfiguration * SOAP_FMAC4 soap_in_tt__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct tt__VideoAnalyticsConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_AnalyticsEngineConfiguration = 1;
	size_t soap_flag_RuleEngineConfiguration = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
	{	
		return NULL;
	}
	a = (struct tt__VideoAnalyticsConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoAnalyticsConfiguration, sizeof(struct tt__VideoAnalyticsConfiguration), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__VideoAnalyticsConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, 0, 64))
	{
		return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &a->Name, "tt:Name"))
				{	
					soap_flag_Name--;
					continue;
				}
				if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
					{	
						soap_flag_UseCount--;
						continue;
					}
#if 0
					if (soap_flag_AnalyticsEngineConfiguration && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTott__AnalyticsEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", &a->AnalyticsEngineConfiguration, "tt:AnalyticsEngineConfiguration"))
						{	
							soap_flag_AnalyticsEngineConfiguration--;
							continue;
						}

						if (soap_flag_RuleEngineConfiguration && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_PointerTott__RuleEngineConfiguration(soap, "tt:RuleEngineConfiguration", &a->RuleEngineConfiguration, "tt:RuleEngineConfiguration"))
							{	
								soap_flag_RuleEngineConfiguration--;
								continue;
							}
#endif
							if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
							{	
								if (a->__any == NULL)
								{	
									if (soap_blist___any == NULL)
									{
										soap_blist___any = soap_new_block(soap);
									}
									a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
									if (a->__any == NULL)
									{
										return NULL;
									}
									*a->__any = NULL;
								}
								if (soap_inliteral(soap, "-any", a->__any))
								{	
									a->__size++;
									a->__any = NULL;
									continue;
								}
							}
							if (soap->error == SOAP_TAG_MISMATCH)
							{
								soap->error = soap_ignore_element(soap);
							}
							if (soap->error == SOAP_NO_TAG)
							{
								break;
							}
							if (soap->error)
							{
								return NULL;
							}
		}
		if (a->__any != NULL) 
		{
			soap_pop_block(soap, soap_blist___any);
		}
		if (a->__size)
		{
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
			{
				soap_end_block(soap, soap_blist___any);
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__VideoAnalyticsConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoAnalyticsConfiguration, 0, sizeof(struct tt__VideoAnalyticsConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_AnalyticsEngineConfiguration > 0 || soap_flag_RuleEngineConfiguration > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoAnalyticsConfiguration(struct soap *soap, const struct tt__VideoAnalyticsConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoAnalyticsConfiguration);
	if (soap_out_tt__VideoAnalyticsConfiguration(soap, tag?tag:"tt:VideoAnalyticsConfiguration", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoAnalyticsConfiguration * SOAP_FMAC4 soap_get_tt__VideoAnalyticsConfiguration(struct soap *soap, struct tt__VideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoAnalyticsConfiguration(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfiguration(struct soap *soap, struct tt__PTZConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfiguration))
	{
		soap_serialize_tt__PTZConfiguration(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfiguration(struct soap *soap, const char *tag, int id, struct tt__PTZConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfiguration);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__PTZConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZConfiguration ** SOAP_FMAC4 soap_in_PointerTott__PTZConfiguration(struct soap *soap, const char *tag, struct tt__PTZConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__PTZConfiguration **)soap_malloc(soap, sizeof(struct tt__PTZConfiguration *))))
		{
			return NULL;
		}
	}

	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__PTZConfiguration(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__PTZConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfiguration, sizeof(struct tt__PTZConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfiguration(struct soap *soap, struct tt__PTZConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZConfiguration);
	if (soap_out_PointerTott__PTZConfiguration(soap, tag?tag:"tt:PTZConfiguration", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZConfiguration ** SOAP_FMAC4 soap_get_PointerTott__PTZConfiguration(struct soap *soap, struct tt__PTZConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfiguration(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZConfiguration(struct soap *soap, struct tt__PTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__ReferenceToken(soap, &a->NodeToken);
	soap_default_string(soap, &a->DefaultAbsolutePantTiltPositionSpace);
	soap_default_string(soap, &a->DefaultAbsoluteZoomPositionSpace);
	soap_default_string(soap, &a->DefaultRelativePanTiltTranslationSpace);
	soap_default_string(soap, &a->DefaultRelativeZoomTranslationSpace);
	soap_default_string(soap, &a->DefaultContinuousPanTiltVelocitySpace);
	soap_default_string(soap, &a->DefaultContinuousZoomVelocitySpace);
	a->DefaultPTZSpeed = NULL;
	soap_default_string(soap, &a->DefaultPTZTimeout);
	a->PanTiltLimits = NULL;
	a->ZoomLimits = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZConfiguration(struct soap *soap, const struct tt__PTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__Name(soap, &a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_tt__ReferenceToken(soap, &a->NodeToken);
	soap_serialize_string(soap, &a->DefaultAbsolutePantTiltPositionSpace);
	soap_serialize_string(soap, &a->DefaultAbsoluteZoomPositionSpace);
	soap_serialize_string(soap, &a->DefaultRelativePanTiltTranslationSpace);
	soap_serialize_string(soap, &a->DefaultRelativeZoomTranslationSpace);
	soap_serialize_string(soap, &a->DefaultContinuousPanTiltVelocitySpace);
	soap_serialize_string(soap, &a->DefaultContinuousZoomVelocitySpace);
	soap_serialize_PointerTott__PTZSpeed(soap, &a->DefaultPTZSpeed);
	soap_serialize_string(soap, &a->DefaultPTZTimeout);
	soap_serialize_PointerTott__PanTiltLimits(soap, &a->PanTiltLimits);
	soap_serialize_PointerTott__ZoomLimits(soap, &a->ZoomLimits);
	soap_serialize_PointerTott__PTZConfigurationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfiguration(struct soap *soap, const char *tag, int id, const struct tt__PTZConfiguration *a, const char *type)
{
	if (a->token != NULL)
	{
		soap_set_attr(soap, "token", a->token, 1);
	}
	if (a->__anyAttribute != NULL)
	{
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	}
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfiguration), type))
	{
		return soap->error;
	}
	if (a->Name != NULL)
	{	
		if (soap_out_tt__Name(soap, "tt:Name", -1, &a->Name, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:Name"))
	{
		return soap->error;
	}
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
	{
		return soap->error;
	}
	if (a->NodeToken != NULL)
	{	
		if (soap_out_tt__ReferenceToken(soap, "tt:NodeToken", -1, &a->NodeToken, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:NodeToken"))
	{
		return soap->error;
	}
	if (soap_out_string(soap, "tt:DefaultAbsolutePantTiltPositionSpace", -1, &a->DefaultAbsolutePantTiltPositionSpace, ""))
	{
		return soap->error;
	}
	if (soap_out_string(soap, "tt:DefaultAbsoluteZoomPositionSpace", -1, &a->DefaultAbsoluteZoomPositionSpace, ""))
	{
		return soap->error;
	}
	if (soap_out_string(soap, "tt:DefaultRelativePanTiltTranslationSpace", -1, &a->DefaultRelativePanTiltTranslationSpace, ""))
	{
		return soap->error;
	}
	if (soap_out_string(soap, "tt:DefaultRelativeZoomTranslationSpace", -1, &a->DefaultRelativeZoomTranslationSpace, ""))
	{
		return soap->error;
	}
	if (soap_out_string(soap, "tt:DefaultContinuousPanTiltVelocitySpace", -1, &a->DefaultContinuousPanTiltVelocitySpace, ""))
	{
		return soap->error;
	}
	if (soap_out_string(soap, "tt:DefaultContinuousZoomVelocitySpace", -1, &a->DefaultContinuousZoomVelocitySpace, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__PTZSpeed(soap, "tt:DefaultPTZSpeed", -1, &a->DefaultPTZSpeed, ""))
	{
		return soap->error;
	}
	if (soap_out_string(soap, "tt:DefaultPTZTimeout", -1, &a->DefaultPTZTimeout, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__PanTiltLimits(soap, "tt:PanTiltLimits", -1, &a->PanTiltLimits, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__ZoomLimits(soap, "tt:ZoomLimits", -1, &a->ZoomLimits, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__PTZConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZConfiguration * SOAP_FMAC4 soap_in_tt__PTZConfiguration(struct soap *soap, const char *tag, struct tt__PTZConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_NodeToken = 1;
	size_t soap_flag_DefaultAbsolutePantTiltPositionSpace = 1;
	size_t soap_flag_DefaultAbsoluteZoomPositionSpace = 1;
	size_t soap_flag_DefaultRelativePanTiltTranslationSpace = 1;
	size_t soap_flag_DefaultRelativeZoomTranslationSpace = 1;
	size_t soap_flag_DefaultContinuousPanTiltVelocitySpace = 1;
	size_t soap_flag_DefaultContinuousZoomVelocitySpace = 1;
	size_t soap_flag_DefaultPTZSpeed = 1;
	size_t soap_flag_DefaultPTZTimeout = 1;
	size_t soap_flag_PanTiltLimits = 1;
	size_t soap_flag_ZoomLimits = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__PTZConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfiguration, sizeof(struct tt__PTZConfiguration), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__PTZConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, 0, 64))
	{
		return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &a->Name, "tt:Name"))
				{	
					soap_flag_Name--;
					continue;
				}
				if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
					{	
						soap_flag_UseCount--;
						continue;
					}
					if (soap_flag_NodeToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
						if (soap_in_tt__ReferenceToken(soap, "tt:NodeToken", &a->NodeToken, "tt:ReferenceToken"))
						{	
							soap_flag_NodeToken--;
							continue;
						}
						if (soap_flag_DefaultAbsolutePantTiltPositionSpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
							if (soap_in_string(soap, "tt:DefaultAbsolutePantTiltPositionSpace", &a->DefaultAbsolutePantTiltPositionSpace, "xsd:string"))
							{	
								soap_flag_DefaultAbsolutePantTiltPositionSpace--;
								continue;
							}
							if (soap_flag_DefaultAbsoluteZoomPositionSpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
								if (soap_in_string(soap, "tt:DefaultAbsoluteZoomPositionSpace", &a->DefaultAbsoluteZoomPositionSpace, "xsd:string"))
								{	
									soap_flag_DefaultAbsoluteZoomPositionSpace--;
									continue;
								}
								if (soap_flag_DefaultRelativePanTiltTranslationSpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
									if (soap_in_string(soap, "tt:DefaultRelativePanTiltTranslationSpace", &a->DefaultRelativePanTiltTranslationSpace, "xsd:string"))
									{	
										soap_flag_DefaultRelativePanTiltTranslationSpace--;
										continue;
									}
									if (soap_flag_DefaultRelativeZoomTranslationSpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
										if (soap_in_string(soap, "tt:DefaultRelativeZoomTranslationSpace", &a->DefaultRelativeZoomTranslationSpace, "xsd:string"))
										{	
											soap_flag_DefaultRelativeZoomTranslationSpace--;
											continue;
										}
										if (soap_flag_DefaultContinuousPanTiltVelocitySpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
											if (soap_in_string(soap, "tt:DefaultContinuousPanTiltVelocitySpace", &a->DefaultContinuousPanTiltVelocitySpace, "xsd:string"))
											{	
												soap_flag_DefaultContinuousPanTiltVelocitySpace--;
												continue;
											}
											if (soap_flag_DefaultContinuousZoomVelocitySpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
												if (soap_in_string(soap, "tt:DefaultContinuousZoomVelocitySpace", &a->DefaultContinuousZoomVelocitySpace, "xsd:string"))
												{	
													soap_flag_DefaultContinuousZoomVelocitySpace--;
													continue;
												}
												if (soap_flag_DefaultPTZSpeed && soap->error == SOAP_TAG_MISMATCH)
													if (soap_in_PointerTott__PTZSpeed(soap, "tt:DefaultPTZSpeed", &a->DefaultPTZSpeed, "tt:PTZSpeed"))
													{	
														soap_flag_DefaultPTZSpeed--;
														continue;
													}
													if (soap_flag_DefaultPTZTimeout && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
														if (soap_in_string(soap, "tt:DefaultPTZTimeout", &a->DefaultPTZTimeout, "xsd:string"))
														{	
															soap_flag_DefaultPTZTimeout--;
															continue;
														}
														if (soap_flag_PanTiltLimits && soap->error == SOAP_TAG_MISMATCH)
															if (soap_in_PointerTott__PanTiltLimits(soap, "tt:PanTiltLimits", &a->PanTiltLimits, "tt:PanTiltLimits"))
															{	
																soap_flag_PanTiltLimits--;
																continue;
															}
															if (soap_flag_ZoomLimits && soap->error == SOAP_TAG_MISMATCH)
																if (soap_in_PointerTott__ZoomLimits(soap, "tt:ZoomLimits", &a->ZoomLimits, "tt:ZoomLimits"))
																{	
																	soap_flag_ZoomLimits--;
																	continue;
																}
																if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
																	if (soap_in_PointerTott__PTZConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:PTZConfigurationExtension"))
																	{	
																		soap_flag_Extension--;
																		continue;
																	}
																	if (soap->error == SOAP_TAG_MISMATCH)
																	{
																		soap->error = soap_ignore_element(soap);
																	}
																	if (soap->error == SOAP_NO_TAG)
																	{
																		break;
																	}
																	if (soap->error)
																	{
																		return NULL;
																	}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__PTZConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfiguration, 0, sizeof(struct tt__PTZConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_NodeToken > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZConfiguration(struct soap *soap, const struct tt__PTZConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PTZConfiguration);
	if (soap_out_tt__PTZConfiguration(soap, tag?tag:"tt:PTZConfiguration", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZConfiguration * SOAP_FMAC4 soap_get_tt__PTZConfiguration(struct soap *soap, struct tt__PTZConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfiguration(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Vector1D(struct soap *soap, struct tt__Vector1D *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->x);
	soap_default_string(soap, &a->space);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Vector1D(struct soap *soap, const struct tt__Vector1D *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector1D(struct soap *soap, const char *tag, int id, const struct tt__Vector1D *a, const char *type)
{
	soap_set_attr(soap, "x", soap_float2s(soap, a->x), 1);
	if (a->space != NULL)
	{
		soap_set_attr(soap, "space", a->space, 1);
	}
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Vector1D), type))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Vector1D * SOAP_FMAC4 soap_in_tt__Vector1D(struct soap *soap, const char *tag, struct tt__Vector1D *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__Vector1D *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector1D, sizeof(struct tt__Vector1D), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__Vector1D(soap, a);
	if (soap_s2float(soap, soap_attr_value(soap, "x", 1), &a->x))
	{
		return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "space", 0), &a->space, 0, -1))
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{
				soap->error = soap_ignore_element(soap);
			}
			if (soap->error == SOAP_NO_TAG)
			{
				break;
			}
			if (soap->error)
			{
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__Vector1D *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Vector1D, 0, sizeof(struct tt__Vector1D), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Vector1D(struct soap *soap, const struct tt__Vector1D *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Vector1D);
	if (soap_out_tt__Vector1D(soap, tag?tag:"tt:Vector1D", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Vector1D * SOAP_FMAC4 soap_get_tt__Vector1D(struct soap *soap, struct tt__Vector1D *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Vector1D(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Vector2D(struct soap *soap, struct tt__Vector2D *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->x);
	soap_default_float(soap, &a->y);
	soap_default_string(soap, &a->space);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Vector2D(struct soap *soap, const struct tt__Vector2D *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector2D(struct soap *soap, const char *tag, int id, const struct tt__Vector2D *a, const char *type)
{
	soap_set_attr(soap, "x", soap_float2s(soap, a->x), 1);
	soap_set_attr(soap, "y", soap_float2s(soap, a->y), 1);
	if (a->space != NULL)
	{
		soap_set_attr(soap, "space", a->space, 1);
	}
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Vector2D), type))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Vector2D * SOAP_FMAC4 soap_in_tt__Vector2D(struct soap *soap, const char *tag, struct tt__Vector2D *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__Vector2D *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector2D, sizeof(struct tt__Vector2D), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__Vector2D(soap, a);
	if (soap_s2float(soap, soap_attr_value(soap, "x", 1), &a->x))
	{
		return NULL;
	}
	if (soap_s2float(soap, soap_attr_value(soap, "y", 1), &a->y))
	{
		return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "space", 0), &a->space, 0, -1))
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{
				soap->error = soap_ignore_element(soap);
			}
			if (soap->error == SOAP_NO_TAG)
			{
				break;
			}
			if (soap->error)
			{
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__Vector2D *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Vector2D, 0, sizeof(struct tt__Vector2D), 0, NULL);
		if(soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Vector2D(struct soap *soap, const struct tt__Vector2D *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Vector2D);
	if (soap_out_tt__Vector2D(soap, tag?tag:"tt:Vector2D", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Vector2D * SOAP_FMAC4 soap_get_tt__Vector2D(struct soap *soap, struct tt__Vector2D *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Vector2D(soap, tag, p, type)))
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Vector1D(struct soap *soap, struct tt__Vector1D *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Vector1D))
	{
		soap_serialize_tt__Vector1D(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Vector1D(struct soap *soap, const char *tag, int id, struct tt__Vector1D *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Vector1D);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__Vector1D(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Vector1D ** SOAP_FMAC4 soap_in_PointerTott__Vector1D(struct soap *soap, const char *tag, struct tt__Vector1D **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__Vector1D **)soap_malloc(soap, sizeof(struct tt__Vector1D *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__Vector1D(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__Vector1D **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Vector1D, sizeof(struct tt__Vector1D), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Vector1D(struct soap *soap, struct tt__Vector1D *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Vector1D);
	if (soap_out_PointerTott__Vector1D(soap, tag?tag:"tt:Vector1D", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Vector1D ** SOAP_FMAC4 soap_get_PointerTott__Vector1D(struct soap *soap, struct tt__Vector1D **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Vector1D(soap, tag, p, type)))
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Vector2D(struct soap *soap, struct tt__Vector2D *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Vector2D))
	{
		soap_serialize_tt__Vector2D(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Vector2D(struct soap *soap, const char *tag, int id, struct tt__Vector2D *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Vector2D);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__Vector2D(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Vector2D ** SOAP_FMAC4 soap_in_PointerTott__Vector2D(struct soap *soap, const char *tag, struct tt__Vector2D **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__Vector2D **)soap_malloc(soap, sizeof(struct tt__Vector2D *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__Vector2D(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__Vector2D **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Vector2D, sizeof(struct tt__Vector2D), 0);
		if(soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Vector2D(struct soap *soap, struct tt__Vector2D *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Vector2D);
	if (soap_out_PointerTott__Vector2D(soap, tag?tag:"tt:Vector2D", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Vector2D ** SOAP_FMAC4 soap_get_PointerTott__Vector2D(struct soap *soap, struct tt__Vector2D **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Vector2D(soap, tag, p, type)))
	{
		if (soap_getindependent(soap))
		{			
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZSpeed(struct soap *soap, struct tt__PTZSpeed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PanTilt = NULL;
	a->Zoom = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZSpeed(struct soap *soap, const struct tt__PTZSpeed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Vector2D(soap, &a->PanTilt);
	soap_serialize_PointerTott__Vector1D(soap, &a->Zoom);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZSpeed(struct soap *soap, const char *tag, int id, const struct tt__PTZSpeed *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZSpeed), type))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__Vector2D(soap, "tt:PanTilt", -1, &a->PanTilt, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__Vector1D(soap, "tt:Zoom", -1, &a->Zoom, ""))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZSpeed * SOAP_FMAC4 soap_in_tt__PTZSpeed(struct soap *soap, const char *tag, struct tt__PTZSpeed *a, const char *type)
{
	size_t soap_flag_PanTilt = 1;
	size_t soap_flag_Zoom = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__PTZSpeed *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZSpeed, sizeof(struct tt__PTZSpeed), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__PTZSpeed(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTilt && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Vector2D(soap, "tt:PanTilt", &a->PanTilt, "tt:Vector2D"))
				{	
					soap_flag_PanTilt--;
					continue;
				}
				if (soap_flag_Zoom && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__Vector1D(soap, "tt:Zoom", &a->Zoom, "tt:Vector1D"))
					{	
						soap_flag_Zoom--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH)
					{
						soap->error = soap_ignore_element(soap);
					}
					if (soap->error == SOAP_NO_TAG)
					{
						break;
					}
					if (soap->error)
					{
						return NULL;
					}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__PTZSpeed *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZSpeed, 0, sizeof(struct tt__PTZSpeed), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZSpeed(struct soap *soap, const struct tt__PTZSpeed *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PTZSpeed);
	if (soap_out_tt__PTZSpeed(soap, tag?tag:"tt:PTZSpeed", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZSpeed * SOAP_FMAC4 soap_get_tt__PTZSpeed(struct soap *soap, struct tt__PTZSpeed *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZSpeed(soap, tag, p, type)))
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZSpeed(struct soap *soap, struct tt__PTZSpeed *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZSpeed))
	{
		soap_serialize_tt__PTZSpeed(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZSpeed(struct soap *soap, const char *tag, int id, struct tt__PTZSpeed *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZSpeed);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__PTZSpeed(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZSpeed ** SOAP_FMAC4 soap_in_PointerTott__PTZSpeed(struct soap *soap, const char *tag, struct tt__PTZSpeed **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (!(a = (struct tt__PTZSpeed **)soap_malloc(soap, sizeof(struct tt__PTZSpeed *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__PTZSpeed(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{
		a = (struct tt__PTZSpeed **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZSpeed, sizeof(struct tt__PTZSpeed), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZSpeed(struct soap *soap, struct tt__PTZSpeed *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZSpeed);
	if (soap_out_PointerTott__PTZSpeed(soap, tag?tag:"tt:PTZSpeed", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZSpeed ** SOAP_FMAC4 soap_get_PointerTott__PTZSpeed(struct soap *soap, struct tt__PTZSpeed **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZSpeed(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Space1DDescription(struct soap *soap, struct tt__Space1DDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->URI);
	a->XRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Space1DDescription(struct soap *soap, const struct tt__Space1DDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->URI);
	soap_serialize_PointerTott__FloatRange(soap, &a->XRange);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Space1DDescription(struct soap *soap, const char *tag, int id, const struct tt__Space1DDescription *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Space1DDescription), type))
	{
		return soap->error;
	}
	if (a->URI != NULL)
	{	
		if (soap_out_string(soap, "tt:URI", -1, &a->URI, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:URI"))
	{
		return soap->error;
	}
	if (a->XRange != NULL)
	{	
		if (soap_out_PointerTott__FloatRange(soap, "tt:XRange", -1, &a->XRange, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:XRange"))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Space1DDescription * SOAP_FMAC4 soap_in_tt__Space1DDescription(struct soap *soap, const char *tag, struct tt__Space1DDescription *a, const char *type)
{
	size_t soap_flag_URI = 1;
	size_t soap_flag_XRange = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__Space1DDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Space1DDescription, sizeof(struct tt__Space1DDescription), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__Space1DDescription(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_URI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:URI", &a->URI, "xsd:string"))
				{	
					soap_flag_URI--;
					continue;
				}
				if (soap_flag_XRange && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__FloatRange(soap, "tt:XRange", &a->XRange, "tt:FloatRange"))
					{	
						soap_flag_XRange--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH)
					{
						soap->error = soap_ignore_element(soap);
					}
					if (soap->error == SOAP_NO_TAG)
					{
						break;
					}
					if (soap->error)
					{
						return NULL;
					}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__Space1DDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Space1DDescription, 0, sizeof(struct tt__Space1DDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{	
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_URI > 0 || soap_flag_XRange > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Space1DDescription(struct soap *soap, const struct tt__Space1DDescription *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Space1DDescription);
	if (soap_out_tt__Space1DDescription(soap, tag?tag:"tt:Space1DDescription", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Space1DDescription * SOAP_FMAC4 soap_get_tt__Space1DDescription(struct soap *soap, struct tt__Space1DDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Space1DDescription(soap, tag, p, type))!= NULL)
	{	
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Space2DDescription(struct soap *soap, struct tt__Space2DDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->URI);
	a->XRange = NULL;
	a->YRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Space2DDescription(struct soap *soap, const struct tt__Space2DDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->URI);
	soap_serialize_PointerTott__FloatRange(soap, &a->XRange);
	soap_serialize_PointerTott__FloatRange(soap, &a->YRange);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Space2DDescription(struct soap *soap, const char *tag, int id, const struct tt__Space2DDescription *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Space2DDescription), type))
	{
		return soap->error;
	}
	if (a->URI != NULL)
	{	
		if (soap_out_string(soap, "tt:URI", -1, &a->URI, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:URI"))
	{
		return soap->error;
	}
	if (a->XRange != NULL)
	{	
		if (soap_out_PointerTott__FloatRange(soap, "tt:XRange", -1, &a->XRange, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:XRange"))
	{
		return soap->error;
	}
	if (a->YRange != NULL)
	{	
		if (soap_out_PointerTott__FloatRange(soap, "tt:YRange", -1, &a->YRange, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:YRange"))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Space2DDescription * SOAP_FMAC4 soap_in_tt__Space2DDescription(struct soap *soap, const char *tag, struct tt__Space2DDescription *a, const char *type)
{
	size_t soap_flag_URI = 1;
	size_t soap_flag_XRange = 1;
	size_t soap_flag_YRange = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__Space2DDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Space2DDescription, sizeof(struct tt__Space2DDescription), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__Space2DDescription(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_URI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:URI", &a->URI, "xsd:string"))
				{	
					soap_flag_URI--;
					continue;
				}
				if (soap_flag_XRange && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__FloatRange(soap, "tt:XRange", &a->XRange, "tt:FloatRange"))
					{	
						soap_flag_XRange--;
						continue;
					}
					if (soap_flag_YRange && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTott__FloatRange(soap, "tt:YRange", &a->YRange, "tt:FloatRange"))
						{	
							soap_flag_YRange--;
							continue;
						}
						if (soap->error == SOAP_TAG_MISMATCH)
						{
							soap->error = soap_ignore_element(soap);
						}
						if (soap->error == SOAP_NO_TAG)
						{
							break;
						}
						if (soap->error)
						{
							return NULL;
						}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__Space2DDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Space2DDescription, 0, sizeof(struct tt__Space2DDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_URI > 0 || soap_flag_XRange > 0 || soap_flag_YRange > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Space2DDescription(struct soap *soap, const struct tt__Space2DDescription *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Space2DDescription);
	if (soap_out_tt__Space2DDescription(soap, tag?tag:"tt:Space2DDescription", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Space2DDescription * SOAP_FMAC4 soap_get_tt__Space2DDescription(struct soap *soap, struct tt__Space2DDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Space2DDescription(soap, tag, p, type)))
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Space1DDescription(struct soap *soap, struct tt__Space1DDescription *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Space1DDescription))
	{
		soap_serialize_tt__Space1DDescription(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Space1DDescription(struct soap *soap, const char *tag, int id, struct tt__Space1DDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Space1DDescription);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__Space1DDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Space1DDescription ** SOAP_FMAC4 soap_in_PointerTott__Space1DDescription(struct soap *soap, const char *tag, struct tt__Space1DDescription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__Space1DDescription **)soap_malloc(soap, sizeof(struct tt__Space1DDescription *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if ((*a = soap_in_tt__Space1DDescription(soap, tag, *a, type)) == NULL)
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__Space1DDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Space1DDescription, sizeof(struct tt__Space1DDescription), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Space1DDescription(struct soap *soap, struct tt__Space1DDescription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Space1DDescription);
	if (soap_out_PointerTott__Space1DDescription(soap, tag?tag:"tt:Space1DDescription", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Space1DDescription ** SOAP_FMAC4 soap_get_PointerTott__Space1DDescription(struct soap *soap, struct tt__Space1DDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Space1DDescription(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Space2DDescription(struct soap *soap, struct tt__Space2DDescription *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Space2DDescription))
	{
		soap_serialize_tt__Space2DDescription(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Space2DDescription(struct soap *soap, const char *tag, int id, struct tt__Space2DDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Space2DDescription);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__Space2DDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Space2DDescription ** SOAP_FMAC4 soap_in_PointerTott__Space2DDescription(struct soap *soap, const char *tag, struct tt__Space2DDescription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__Space2DDescription **)soap_malloc(soap, sizeof(struct tt__Space2DDescription *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if(NULL==(*a = soap_in_tt__Space2DDescription(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__Space2DDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Space2DDescription, sizeof(struct tt__Space2DDescription), 0);
		if(soap->body && soap_element_end_in(soap, tag))
		{	
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Space2DDescription(struct soap *soap, struct tt__Space2DDescription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Space2DDescription);
	if (soap_out_PointerTott__Space2DDescription(soap, tag?tag:"tt:Space2DDescription", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Space2DDescription ** SOAP_FMAC4 soap_get_PointerTott__Space2DDescription(struct soap *soap, struct tt__Space2DDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Space2DDescription(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PanTiltLimits(struct soap *soap, struct tt__PanTiltLimits *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Range = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PanTiltLimits(struct soap *soap, const struct tt__PanTiltLimits *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Space2DDescription(soap, &a->Range);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PanTiltLimits(struct soap *soap, const char *tag, int id, const struct tt__PanTiltLimits *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PanTiltLimits), type))
	{
		return soap->error;
	}
	if (a->Range != NULL)
	{	
		if (soap_out_PointerTott__Space2DDescription(soap, "tt:Range", -1, &a->Range, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:Range"))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PanTiltLimits * SOAP_FMAC4 soap_in_tt__PanTiltLimits(struct soap *soap, const char *tag, struct tt__PanTiltLimits *a, const char *type)
{
	size_t soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__PanTiltLimits *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PanTiltLimits, sizeof(struct tt__PanTiltLimits), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__PanTiltLimits(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Space2DDescription(soap, "tt:Range", &a->Range, "tt:Space2DDescription"))
				{	
					soap_flag_Range--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH)
				{
					soap->error = soap_ignore_element(soap);
				}
				if (soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{
					return NULL;
				}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__PanTiltLimits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PanTiltLimits, 0, sizeof(struct tt__PanTiltLimits), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Range > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PanTiltLimits(struct soap *soap, const struct tt__PanTiltLimits *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PanTiltLimits);
	if (soap_out_tt__PanTiltLimits(soap, tag?tag:"tt:PanTiltLimits", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PanTiltLimits * SOAP_FMAC4 soap_get_tt__PanTiltLimits(struct soap *soap, struct tt__PanTiltLimits *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PanTiltLimits(soap, tag, p, type)))
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PanTiltLimits(struct soap *soap, struct tt__PanTiltLimits *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PanTiltLimits))
	{
		soap_serialize_tt__PanTiltLimits(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PanTiltLimits(struct soap *soap, const char *tag, int id, struct tt__PanTiltLimits *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PanTiltLimits);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__PanTiltLimits(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PanTiltLimits ** SOAP_FMAC4 soap_in_PointerTott__PanTiltLimits(struct soap *soap, const char *tag, struct tt__PanTiltLimits **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (!(a = (struct tt__PanTiltLimits **)soap_malloc(soap, sizeof(struct tt__PanTiltLimits *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__PanTiltLimits(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__PanTiltLimits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PanTiltLimits, sizeof(struct tt__PanTiltLimits), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PanTiltLimits(struct soap *soap, struct tt__PanTiltLimits *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PanTiltLimits);
	if (soap_out_PointerTott__PanTiltLimits(soap, tag?tag:"tt:PanTiltLimits", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PanTiltLimits ** SOAP_FMAC4 soap_get_PointerTott__PanTiltLimits(struct soap *soap, struct tt__PanTiltLimits **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PanTiltLimits(soap, tag, p, type)))
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ZoomLimits(struct soap *soap, struct tt__ZoomLimits *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Range = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ZoomLimits(struct soap *soap, const struct tt__ZoomLimits *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Space1DDescription(soap, &a->Range);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ZoomLimits(struct soap *soap, const char *tag, int id, const struct tt__ZoomLimits *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ZoomLimits), type))
	{
		return soap->error;
	}
	if (a->Range != NULL)
	{	
		if (soap_out_PointerTott__Space1DDescription(soap, "tt:Range", -1, &a->Range, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:Range"))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ZoomLimits * SOAP_FMAC4 soap_in_tt__ZoomLimits(struct soap *soap, const char *tag, struct tt__ZoomLimits *a, const char *type)
{
	size_t soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__ZoomLimits *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ZoomLimits, sizeof(struct tt__ZoomLimits), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__ZoomLimits(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Space1DDescription(soap, "tt:Range", &a->Range, "tt:Space1DDescription"))
				{	
					soap_flag_Range--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH)
				{
					soap->error = soap_ignore_element(soap);
				}
				if (soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{	
					return NULL;
				}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__ZoomLimits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ZoomLimits, 0, sizeof(struct tt__ZoomLimits), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Range > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ZoomLimits(struct soap *soap, const struct tt__ZoomLimits *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ZoomLimits);
	if (soap_out_tt__ZoomLimits(soap, tag?tag:"tt:ZoomLimits", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ZoomLimits * SOAP_FMAC4 soap_get_tt__ZoomLimits(struct soap *soap, struct tt__ZoomLimits *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ZoomLimits(soap, tag, p, type)) != NULL)
	{	
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ZoomLimits(struct soap *soap, struct tt__ZoomLimits *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ZoomLimits))
	{
		soap_serialize_tt__ZoomLimits(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ZoomLimits(struct soap *soap, const char *tag, int id, struct tt__ZoomLimits *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ZoomLimits);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__ZoomLimits(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ZoomLimits ** SOAP_FMAC4 soap_in_PointerTott__ZoomLimits(struct soap *soap, const char *tag, struct tt__ZoomLimits **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__ZoomLimits **)soap_malloc(soap, sizeof(struct tt__ZoomLimits *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__ZoomLimits(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__ZoomLimits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ZoomLimits, sizeof(struct tt__ZoomLimits), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ZoomLimits(struct soap *soap, struct tt__ZoomLimits *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ZoomLimits);
	if (soap_out_PointerTott__ZoomLimits(soap, tag?tag:"tt:ZoomLimits", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ZoomLimits ** SOAP_FMAC4 soap_get_PointerTott__ZoomLimits(struct soap *soap, struct tt__ZoomLimits **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ZoomLimits(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfigurationExtension(struct soap *soap, struct tt__PTZConfigurationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfigurationExtension))
	{
		soap_serialize_tt__PTZConfigurationExtension(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__PTZConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfigurationExtension);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__PTZConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZConfigurationExtension(struct soap *soap, const char *tag, struct tt__PTZConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (!(a = (struct tt__PTZConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__PTZConfigurationExtension *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__PTZConfigurationExtension(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__PTZConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfigurationExtension, sizeof(struct tt__PTZConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfigurationExtension(struct soap *soap, struct tt__PTZConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZConfigurationExtension);
	if (soap_out_PointerTott__PTZConfigurationExtension(soap, tag?tag:"tt:PTZConfigurationExtension", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZConfigurationExtension(struct soap *soap, struct tt__PTZConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfigurationExtension(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{		
			return NULL;
		}	
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZConfigurationExtension(struct soap *soap, struct tt__PTZConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZConfigurationExtension(struct soap *soap, const struct tt__PTZConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__PTZConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfigurationExtension), type))
	{
		return soap->error;
	}
	if (a->__any != NULL)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_outliteral(soap, "-any", a->__any + i, NULL);
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension * SOAP_FMAC4 soap_in_tt__PTZConfigurationExtension(struct soap *soap, const char *tag, struct tt__PTZConfigurationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__PTZConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfigurationExtension, sizeof(struct tt__PTZConfigurationExtension), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__PTZConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
					{
						soap_blist___any = soap_new_block(soap);
					}
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
					{
						return NULL;
					}
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{
				soap->error = soap_ignore_element(soap);
			}
			if (soap->error == SOAP_NO_TAG)
			{
				break;
			}
			if (soap->error)
			{
				return NULL;
			}
		}
		if (a->__any != NULL)
		{
			soap_pop_block(soap, soap_blist___any);
		}
		if (a->__size)
		{
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
			{
				soap_end_block(soap, soap_blist___any);
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__PTZConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfigurationExtension, 0, sizeof(struct tt__PTZConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZConfigurationExtension(struct soap *soap, const struct tt__PTZConfigurationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PTZConfigurationExtension);
	if (soap_out_tt__PTZConfigurationExtension(soap, tag?tag:"tt:PTZConfigurationExtension", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension * SOAP_FMAC4 soap_get_tt__PTZConfigurationExtension(struct soap *soap, struct tt__PTZConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfigurationExtension(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZFilter(struct soap *soap, struct tt__PTZFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->Status);
	soap_default_xsd__boolean_(soap, &a->Position);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZFilter(struct soap *soap, const struct tt__PTZFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Status, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->Position, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZFilter(struct soap *soap, const char *tag, int id, const struct tt__PTZFilter *a, const char *type)
{
	if (a->__anyAttribute)
	{
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	}
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZFilter), type))
	{
		return soap->error;
	}
	if (soap_out_xsd__boolean_(soap, "tt:Status", -1, &a->Status, ""))
	{
		return soap->error;
	}
	if (soap_out_xsd__boolean_(soap, "tt:Position", -1, &a->Position, ""))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZFilter * SOAP_FMAC4 soap_in_tt__PTZFilter(struct soap *soap, const char *tag, struct tt__PTZFilter *a, const char *type)
{
	size_t soap_flag_Status = 1;
	size_t soap_flag_Position = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__PTZFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZFilter, sizeof(struct tt__PTZFilter), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__PTZFilter(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:Status", &a->Status, "xsd:boolean"))
				{	
					soap_flag_Status--;
					continue;
				}
				if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_xsd__boolean_(soap, "tt:Position", &a->Position, "xsd:boolean"))
					{	
						soap_flag_Position--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH)
					{
						soap->error = soap_ignore_element(soap);
					}
					if (soap->error == SOAP_NO_TAG)
					{
						break;
					}
					if (soap->error)
					{
						return NULL;
					}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__PTZFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZFilter, 0, sizeof(struct tt__PTZFilter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Status > 0 || soap_flag_Position > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZFilter(struct soap *soap, const struct tt__PTZFilter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PTZFilter);
	if (soap_out_tt__PTZFilter(soap, tag?tag:"tt:PTZFilter", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZFilter * SOAP_FMAC4 soap_get_tt__PTZFilter(struct soap *soap, struct tt__PTZFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZFilter(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZFilter(struct soap *soap, struct tt__PTZFilter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZFilter))
	{	
		soap_serialize_tt__PTZFilter(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZFilter(struct soap *soap, const char *tag, int id, struct tt__PTZFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZFilter);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__PTZFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZFilter ** SOAP_FMAC4 soap_in_PointerTott__PTZFilter(struct soap *soap, const char *tag, struct tt__PTZFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__PTZFilter **)soap_malloc(soap, sizeof(struct tt__PTZFilter *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__PTZFilter(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__PTZFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZFilter, sizeof(struct tt__PTZFilter), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZFilter(struct soap *soap, struct tt__PTZFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZFilter);
	if (soap_out_PointerTott__PTZFilter(soap, tag?tag:"tt:PTZFilter", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZFilter ** SOAP_FMAC4 soap_get_PointerTott__PTZFilter(struct soap *soap, struct tt__PTZFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZFilter(soap, tag, p, type)))
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataConfiguration(struct soap *soap, struct tt__MetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->PTZStatus = NULL;
	a->Events = NULL;
	a->Analytics = NULL;
	a->Multicast = NULL;
	soap_default_string(soap, &a->SessionTimeout);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataConfiguration(struct soap *soap, const struct tt__MetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__Name(soap, &a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_PointerTott__PTZFilter(soap, &a->PTZStatus);
	//soap_serialize_PointerTott__EventSubscription(soap, &a->Events);
	soap_serialize_PointerToxsd__boolean_(soap, &a->Analytics);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &a->Multicast);
	soap_serialize_string(soap, &a->SessionTimeout);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataConfiguration(struct soap *soap, const char *tag, int id, const struct tt__MetadataConfiguration *a, const char *type)
{
	if (a->token != NULL)
	{
		soap_set_attr(soap, "token", a->token, 1);
	}
	if (a->__anyAttribute != NULL)
	{
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	}
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataConfiguration), type))
	{
		return soap->error;
	}
	if (a->Name != NULL)
	{	
		if (soap_out_tt__Name(soap, "tt:Name", -1, &a->Name, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:Name"))
	{
		return soap->error;
	}
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__PTZFilter(soap, "tt:PTZStatus", -1, &a->PTZStatus, ""))
	{
		return soap->error;
	}
	//	if (soap_out_PointerTott__EventSubscription(soap, "tt:Events", -1, &a->Events, ""))
	//	return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:Analytics", -1, &a->Analytics, ""))
	{
		return soap->error;
	}
	if (a->Multicast != NULL)
	{	
		if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->Multicast, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:Multicast"))
	{
		return soap->error;
	}
	if (a->SessionTimeout != NULL)
	{	
		if (soap_out_string(soap, "tt:SessionTimeout", -1, &a->SessionTimeout, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:SessionTimeout"))
	{
		return soap->error;
	}
	if (a->__any != NULL)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_outliteral(soap, "-any", a->__any + i, NULL);
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataConfiguration * SOAP_FMAC4 soap_in_tt__MetadataConfiguration(struct soap *soap, const char *tag, struct tt__MetadataConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_PTZStatus = 1;
	size_t soap_flag_Events = 1;
	size_t soap_flag_Analytics = 1;
	size_t soap_flag_Multicast = 1;
	size_t soap_flag_SessionTimeout = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__MetadataConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataConfiguration, sizeof(struct tt__MetadataConfiguration), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__MetadataConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, 0, 64))
	{
		return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &a->Name, "tt:Name"))
				{	
					soap_flag_Name--;
					continue;
				}
				if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
					{	
						soap_flag_UseCount--;
						continue;
					}
					if (soap_flag_PTZStatus && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTott__PTZFilter(soap, "tt:PTZStatus", &a->PTZStatus, "tt:PTZFilter"))
						{	
							soap_flag_PTZStatus--;
							continue;
						}
						//if (soap_flag_Events && soap->error == SOAP_TAG_MISMATCH)
						//if (soap_in_PointerTott__EventSubscription(soap, "tt:Events", &a->Events, "tt:EventSubscription"))
						//{	
						//	soap_flag_Events--;
						//		continue;
						// }
						if (soap_flag_Analytics && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_PointerToxsd__boolean_(soap, "tt:Analytics", &a->Analytics, "xsd:boolean"))
							{	
								soap_flag_Analytics--;
								continue;
							}
							if (soap_flag_Multicast && soap->error == SOAP_TAG_MISMATCH)
								if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->Multicast, "tt:MulticastConfiguration"))
								{	
									soap_flag_Multicast--;
									continue;
								}
								if (soap_flag_SessionTimeout && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
									if (soap_in_string(soap, "tt:SessionTimeout", &a->SessionTimeout, "xsd:string"))
									{	
										soap_flag_SessionTimeout--;
										continue;
									}
									if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
									{	
										if (a->__any == NULL)
										{	
											if (soap_blist___any == NULL)
											{
												soap_blist___any = soap_new_block(soap);
											}
											a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
											if (a->__any == NULL)
											{
												return NULL;
											}
											*a->__any = NULL;
										}
										if (soap_inliteral(soap, "-any", a->__any))
										{	
											a->__size++;
											a->__any = NULL;
											continue;
										}
									}
									if (soap->error == SOAP_TAG_MISMATCH)
									{
										soap->error = soap_ignore_element(soap);
									}
									if (soap->error == SOAP_NO_TAG)
									{
										break;
									}
									if (soap->error)
									{
										return NULL;
									}
		}
		if (a->__any != NULL)
		{
			soap_pop_block(soap, soap_blist___any);
		}
		if (a->__size)
		{
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
			{
				soap_end_block(soap, soap_blist___any);
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__MetadataConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataConfiguration, 0, sizeof(struct tt__MetadataConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_Multicast > 0 || soap_flag_SessionTimeout > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataConfiguration(struct soap *soap, const struct tt__MetadataConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__MetadataConfiguration);
	if (soap_out_tt__MetadataConfiguration(soap, tag?tag:"tt:MetadataConfiguration", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataConfiguration * SOAP_FMAC4 soap_get_tt__MetadataConfiguration(struct soap *soap, struct tt__MetadataConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataConfiguration(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataConfiguration(struct soap *soap, struct tt__MetadataConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataConfiguration))
	{
		soap_serialize_tt__MetadataConfiguration(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataConfiguration(struct soap *soap, const char *tag, int id, struct tt__MetadataConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataConfiguration);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__MetadataConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MetadataConfiguration ** SOAP_FMAC4 soap_in_PointerTott__MetadataConfiguration(struct soap *soap, const char *tag, struct tt__MetadataConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (!(a = (struct tt__MetadataConfiguration **)soap_malloc(soap, sizeof(struct tt__MetadataConfiguration *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__MetadataConfiguration(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__MetadataConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataConfiguration, sizeof(struct tt__MetadataConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataConfiguration(struct soap *soap, struct tt__MetadataConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MetadataConfiguration);
	if (soap_out_PointerTott__MetadataConfiguration(soap, tag?tag:"tt:MetadataConfiguration", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataConfiguration ** SOAP_FMAC4 soap_get_PointerTott__MetadataConfiguration(struct soap *soap, struct tt__MetadataConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataConfiguration(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{			
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ProfileExtension(struct soap *soap, struct tt__ProfileExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ProfileExtension))
	{
		soap_serialize_tt__ProfileExtension(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ProfileExtension(struct soap *soap, const char *tag, int id, struct tt__ProfileExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ProfileExtension);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__ProfileExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ProfileExtension ** SOAP_FMAC4 soap_in_PointerTott__ProfileExtension(struct soap *soap, const char *tag, struct tt__ProfileExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__ProfileExtension **)soap_malloc(soap, sizeof(struct tt__ProfileExtension *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in_tt__ProfileExtension(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__ProfileExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ProfileExtension, sizeof(struct tt__ProfileExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ProfileExtension(struct soap *soap, struct tt__ProfileExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ProfileExtension);
	if (soap_out_PointerTott__ProfileExtension(soap, tag?tag:"tt:ProfileExtension", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileExtension ** SOAP_FMAC4 soap_get_PointerTott__ProfileExtension(struct soap *soap, struct tt__ProfileExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ProfileExtension(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ProfileExtension2(struct soap *soap, struct tt__ProfileExtension2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ProfileExtension2))
	{
		soap_serialize_tt__ProfileExtension2(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ProfileExtension2(struct soap *soap, const char *tag, int id, struct tt__ProfileExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ProfileExtension2);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__ProfileExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ProfileExtension2 ** SOAP_FMAC4 soap_in_PointerTott__ProfileExtension2(struct soap *soap, const char *tag, struct tt__ProfileExtension2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (NULL==a)
	{
		if (NULL==(a = (struct tt__ProfileExtension2 **)soap_malloc(soap, sizeof(struct tt__ProfileExtension2 *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__ProfileExtension2(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__ProfileExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ProfileExtension2, sizeof(struct tt__ProfileExtension2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ProfileExtension2(struct soap *soap, struct tt__ProfileExtension2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ProfileExtension2);
	if (soap_out_PointerTott__ProfileExtension2(soap, tag?tag:"tt:ProfileExtension2", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileExtension2 ** SOAP_FMAC4 soap_get_PointerTott__ProfileExtension2(struct soap *soap, struct tt__ProfileExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ProfileExtension2(soap, tag, p, type)) !=NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioDecoderConfiguration(struct soap *soap, struct tt__AudioDecoderConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioDecoderConfiguration))
	{
		soap_serialize_tt__AudioDecoderConfiguration(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioDecoderConfiguration(struct soap *soap, const char *tag, int id, struct tt__AudioDecoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioDecoderConfiguration);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__AudioDecoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioDecoderConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AudioDecoderConfiguration(struct soap *soap, const char *tag, struct tt__AudioDecoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (NULL==a)
	{
		if (NULL==(a = (struct tt__AudioDecoderConfiguration **)soap_malloc(soap, sizeof(struct tt__AudioDecoderConfiguration *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__AudioDecoderConfiguration(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__AudioDecoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioDecoderConfiguration, sizeof(struct tt__AudioDecoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioDecoderConfiguration(struct soap *soap, struct tt__AudioDecoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AudioDecoderConfiguration);
	if (soap_out_PointerTott__AudioDecoderConfiguration(soap, tag?tag:"tt:AudioDecoderConfiguration", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioDecoderConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AudioDecoderConfiguration(struct soap *soap, struct tt__AudioDecoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioDecoderConfiguration(soap, tag, p, type)) !=NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ProfileExtension(struct soap *soap, struct tt__ProfileExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->AudioOutputConfiguration = NULL;
	a->AudioDecoderConfiguration = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ProfileExtension(struct soap *soap, const struct tt__ProfileExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__AudioOutputConfiguration(soap, &a->AudioOutputConfiguration);
	soap_serialize_PointerTott__AudioDecoderConfiguration(soap, &a->AudioDecoderConfiguration);
	soap_serialize_PointerTott__ProfileExtension2(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ProfileExtension(struct soap *soap, const char *tag, int id, const struct tt__ProfileExtension *a, const char *type)
{
	if (a->__anyAttribute != NULL)
	{
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	}
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ProfileExtension), type))
	{
		return soap->error;
	}
	if (a->__any != NULL)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_outliteral(soap, "-any", a->__any + i, NULL);
		}
	}
	if (soap_out_PointerTott__AudioOutputConfiguration(soap, "tt:AudioOutputConfiguration", -1, &a->AudioOutputConfiguration, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__AudioDecoderConfiguration(soap, "tt:AudioDecoderConfiguration", -1, &a->AudioDecoderConfiguration, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__ProfileExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ProfileExtension * SOAP_FMAC4 soap_in_tt__ProfileExtension(struct soap *soap, const char *tag, struct tt__ProfileExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_AudioOutputConfiguration = 1;
	size_t soap_flag_AudioDecoderConfiguration = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__ProfileExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileExtension, sizeof(struct tt__ProfileExtension), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__ProfileExtension(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
					{
						soap_blist___any = soap_new_block(soap);
					}
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
					{
						return NULL;
					}
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap_flag_AudioOutputConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioOutputConfiguration(soap, "tt:AudioOutputConfiguration", &a->AudioOutputConfiguration, "tt:AudioOutputConfiguration"))
				{
					soap_flag_AudioOutputConfiguration--;
					continue;
				}
				if (soap_flag_AudioDecoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__AudioDecoderConfiguration(soap, "tt:AudioDecoderConfiguration", &a->AudioDecoderConfiguration, "tt:AudioDecoderConfiguration"))
					{	
						soap_flag_AudioDecoderConfiguration--;
						continue;
					}
					if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTott__ProfileExtension2(soap, "tt:Extension", &a->Extension, "tt:ProfileExtension2"))
						{	
							soap_flag_Extension--;
							continue;
						}
						if (soap->error == SOAP_TAG_MISMATCH)
						{
							soap->error = soap_ignore_element(soap);
						}
						if (soap->error == SOAP_NO_TAG)
						{
							break;
						}
						if (soap->error)
						{
							return NULL;
						}
		}
		if (a->__any!= NULL)
		{
			soap_pop_block(soap, soap_blist___any);
		}
		if (a->__size)
		{
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
			{
				soap_end_block(soap, soap_blist___any);
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__ProfileExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileExtension, 0, sizeof(struct tt__ProfileExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ProfileExtension(struct soap *soap, const struct tt__ProfileExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ProfileExtension);
	if (soap_out_tt__ProfileExtension(soap, tag?tag:"tt:ProfileExtension", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileExtension * SOAP_FMAC4 soap_get_tt__ProfileExtension(struct soap *soap, struct tt__ProfileExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ProfileExtension(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ProfileExtension2(struct soap *soap, struct tt__ProfileExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ProfileExtension2(struct soap *soap, const struct tt__ProfileExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ProfileExtension2(struct soap *soap, const char *tag, int id, const struct tt__ProfileExtension2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ProfileExtension2), type))
	{
		return soap->error;
	}
	if (a->__any)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_outliteral(soap, "-any", a->__any + i, NULL);
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ProfileExtension2 * SOAP_FMAC4 soap_in_tt__ProfileExtension2(struct soap *soap, const char *tag, struct tt__ProfileExtension2 *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__ProfileExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileExtension2, sizeof(struct tt__ProfileExtension2), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__ProfileExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
					{
						soap_blist___any = soap_new_block(soap);
					}
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{
				soap->error = soap_ignore_element(soap);
			}
			if (soap->error == SOAP_NO_TAG)
			{
				break;
			}
			if (soap->error)
			{
				return NULL;
			}
		}
		if (a->__any != NULL)
		{
			soap_pop_block(soap, soap_blist___any);
		}
		if (a->__size)
		{
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
			{
				soap_end_block(soap, soap_blist___any);
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__ProfileExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileExtension2, 0, sizeof(struct tt__ProfileExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ProfileExtension2(struct soap *soap, const struct tt__ProfileExtension2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ProfileExtension2);
	if (soap_out_tt__ProfileExtension2(soap, tag?tag:"tt:ProfileExtension2", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileExtension2 * SOAP_FMAC4 soap_get_tt__ProfileExtension2(struct soap *soap, struct tt__ProfileExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ProfileExtension2(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioOutputConfiguration(struct soap *soap, struct tt__AudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__ReferenceToken(soap, &a->OutputToken);
	soap_default_string(soap, &a->SendPrimacy);
	soap_default_int(soap, &a->OutputLevel);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioOutputConfiguration(struct soap *soap, const struct tt__AudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__Name(soap, &a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_tt__ReferenceToken(soap, &a->OutputToken);
	soap_serialize_string(soap, &a->SendPrimacy);
	soap_embedded(soap, &a->OutputLevel, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioOutputConfiguration(struct soap *soap, const char *tag, int id, const struct tt__AudioOutputConfiguration *a, const char *type)
{
	if (a->token != NULL)
	{
		soap_set_attr(soap, "token", a->token, 1);
	}
	if (a->__anyAttribute != NULL)
	{
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	}
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioOutputConfiguration), type))
	{
		return soap->error;
	}
	if (a->Name != NULL)
	{	
		if (soap_out_tt__Name(soap, "tt:Name", -1, &a->Name, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:Name"))
	{
		return soap->error;
	}
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
	{
		return soap->error;
	}
	if (a->OutputToken)
	{	
		if (soap_out_tt__ReferenceToken(soap, "tt:OutputToken", -1, &a->OutputToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:OutputToken"))
	{
		return soap->error;
	}
	if (soap_out_string(soap, "tt:SendPrimacy", -1, &a->SendPrimacy, ""))
	{
		return soap->error;
	}
	if (soap_out_int(soap, "tt:OutputLevel", -1, &a->OutputLevel, ""))
	{
		return soap->error;
	}
	if (a->__any != NULL)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_outliteral(soap, "-any", a->__any + i, NULL);
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioOutputConfiguration * SOAP_FMAC4 soap_in_tt__AudioOutputConfiguration(struct soap *soap, const char *tag, struct tt__AudioOutputConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_OutputToken = 1;
	size_t soap_flag_SendPrimacy = 1;
	size_t soap_flag_OutputLevel = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__AudioOutputConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioOutputConfiguration, sizeof(struct tt__AudioOutputConfiguration), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__AudioOutputConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, 0, 64))
	{
		return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &a->Name, "tt:Name"))
				{	
					soap_flag_Name--;
					continue;
				}
				if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
					{	
						soap_flag_UseCount--;
						continue;
					}
					if (soap_flag_OutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
						if (soap_in_tt__ReferenceToken(soap, "tt:OutputToken", &a->OutputToken, "tt:ReferenceToken"))
						{	
							soap_flag_OutputToken--;
							continue;
						}
						if (soap_flag_SendPrimacy && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
							if (soap_in_string(soap, "tt:SendPrimacy", &a->SendPrimacy, "xsd:string"))
							{	
								soap_flag_SendPrimacy--;
								continue;
							}
							if (soap_flag_OutputLevel && soap->error == SOAP_TAG_MISMATCH)
								if (soap_in_int(soap, "tt:OutputLevel", &a->OutputLevel, "xsd:int"))
								{	
									soap_flag_OutputLevel--;
									continue;
								}
								if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
								{	
									if (a->__any == NULL)
									{	
										if (soap_blist___any == NULL)
										{
											soap_blist___any = soap_new_block(soap);
										}
										a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
										if (a->__any == NULL)
										{
											return NULL;
										}
										*a->__any = NULL;
									}
									if (soap_inliteral(soap, "-any", a->__any))
									{	
										a->__size++;
										a->__any = NULL;
										continue;
									}
								}
								if (soap->error == SOAP_TAG_MISMATCH)
								{
									soap->error = soap_ignore_element(soap);
								}
								if (soap->error == SOAP_NO_TAG)
								{
									break;
								}
								if (soap->error)
								{
									return NULL;
								}
		}
		if (a->__any != NULL)
		{
			soap_pop_block(soap, soap_blist___any);
		}
		if (a->__size)
		{
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
			{
				soap_end_block(soap, soap_blist___any);
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__AudioOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioOutputConfiguration, 0, sizeof(struct tt__AudioOutputConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_OutputToken > 0 || soap_flag_OutputLevel > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioOutputConfiguration(struct soap *soap, const struct tt__AudioOutputConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AudioOutputConfiguration);
	if (soap_out_tt__AudioOutputConfiguration(soap, tag?tag:"tt:AudioOutputConfiguration", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioOutputConfiguration * SOAP_FMAC4 soap_get_tt__AudioOutputConfiguration(struct soap *soap, struct tt__AudioOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioOutputConfiguration(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioOutputConfiguration(struct soap *soap, struct tt__AudioOutputConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioOutputConfiguration))
	{
		soap_serialize_tt__AudioOutputConfiguration(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioOutputConfiguration(struct soap *soap, const char *tag, int id, struct tt__AudioOutputConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioOutputConfiguration);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__AudioOutputConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioOutputConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AudioOutputConfiguration(struct soap *soap, const char *tag, struct tt__AudioOutputConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__AudioOutputConfiguration **)soap_malloc(soap, sizeof(struct tt__AudioOutputConfiguration *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__AudioOutputConfiguration(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{
		a = (struct tt__AudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioOutputConfiguration, sizeof(struct tt__AudioOutputConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioOutputConfiguration(struct soap *soap, struct tt__AudioOutputConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AudioOutputConfiguration);
	if (soap_out_PointerTott__AudioOutputConfiguration(soap, tag?tag:"tt:AudioOutputConfiguration", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioOutputConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AudioOutputConfiguration(struct soap *soap, struct tt__AudioOutputConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioOutputConfiguration(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{		
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioDecoderConfiguration(struct soap *soap, struct tt__AudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioDecoderConfiguration(struct soap *soap, const struct tt__AudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__Name(soap, &a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioDecoderConfiguration(struct soap *soap, const char *tag, int id, const struct tt__AudioDecoderConfiguration *a, const char *type)
{
	if (a->token != NULL)
	{
		soap_set_attr(soap, "token", a->token, 1);
	}
	if (a->__anyAttribute != NULL)
	{	
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	}
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioDecoderConfiguration), type))
	{
		return soap->error;
	}
	if (a->Name != NULL)
	{	
		if (soap_out_tt__Name(soap, "tt:Name", -1, &a->Name, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:Name"))
	{
		return soap->error;
	}
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
	{
		return soap->error;
	}
	if (a->__any != NULL)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_outliteral(soap, "-any", a->__any + i, NULL);
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioDecoderConfiguration * SOAP_FMAC4 soap_in_tt__AudioDecoderConfiguration(struct soap *soap, const char *tag, struct tt__AudioDecoderConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__AudioDecoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioDecoderConfiguration, sizeof(struct tt__AudioDecoderConfiguration), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__AudioDecoderConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, 0, 64))
	{
		return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &a->Name, "tt:Name"))
				{	
					soap_flag_Name--;
					continue;
				}
				if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
					{	
						soap_flag_UseCount--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
					{	
						if (a->__any == NULL)
						{	
							if (soap_blist___any == NULL)
							{
								soap_blist___any = soap_new_block(soap);
							}
							a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
							if (a->__any == NULL)
							{
								return NULL;
							}
							*a->__any = NULL;
						}
						if (soap_inliteral(soap, "-any", a->__any))
						{	
							a->__size++;
							a->__any = NULL;
							continue;
						}
					}
					if (soap->error == SOAP_TAG_MISMATCH)
					{
						soap->error = soap_ignore_element(soap);
					}
					if (soap->error == SOAP_NO_TAG)
					{
						break;
					}
					if (soap->error)
					{
						return NULL;
					}
		}
		if (a->__any != NULL)
		{
			soap_pop_block(soap, soap_blist___any);
		}
		if (a->__size)
		{
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
			{
				soap_end_block(soap, soap_blist___any);
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__AudioDecoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioDecoderConfiguration, 0, sizeof(struct tt__AudioDecoderConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioDecoderConfiguration(struct soap *soap, const struct tt__AudioDecoderConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AudioDecoderConfiguration);
	if (soap_out_tt__AudioDecoderConfiguration(soap, tag?tag:"tt:AudioDecoderConfiguration", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioDecoderConfiguration * SOAP_FMAC4 soap_get_tt__AudioDecoderConfiguration(struct soap *soap, struct tt__AudioDecoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioDecoderConfiguration(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetVideoEncoderConfiguration(struct soap *soap, struct __trt__GetVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetVideoEncoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetVideoEncoderConfiguration(struct soap *soap, const struct __trt__GetVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetVideoEncoderConfiguration(soap, &a->trt__GetVideoEncoderConfiguration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__GetVideoEncoderConfiguration *a, const char *type)
{
	if (soap_out_PointerTo_trt__GetVideoEncoderConfiguration(soap, "trt:GetVideoEncoderConfiguration", -1, &a->trt__GetVideoEncoderConfiguration, ""))
	{
		return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoEncoderConfiguration * SOAP_FMAC4 soap_in___trt__GetVideoEncoderConfiguration(struct soap *soap, const char *tag, struct __trt__GetVideoEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__GetVideoEncoderConfiguration = 1;
	short soap_flag;
	a = (struct __trt__GetVideoEncoderConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetVideoEncoderConfiguration, sizeof(struct __trt__GetVideoEncoderConfiguration), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default___trt__GetVideoEncoderConfiguration(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_trt__GetVideoEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_trt__GetVideoEncoderConfiguration(soap, "trt:GetVideoEncoderConfiguration", &a->trt__GetVideoEncoderConfiguration, ""))
			{	
				soap_flag_trt__GetVideoEncoderConfiguration--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{
					return NULL;
				}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetVideoEncoderConfiguration(struct soap *soap, const struct __trt__GetVideoEncoderConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetVideoEncoderConfiguration(soap, tag?tag:"-trt:GetVideoEncoderConfiguration", id, a, type))
	{
		return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoEncoderConfiguration * SOAP_FMAC4 soap_get___trt__GetVideoEncoderConfiguration(struct soap *soap, struct __trt__GetVideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetVideoEncoderConfiguration(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoEncoderConfigurationResponse(struct soap *soap, const struct _trt__GetVideoEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__VideoEncoderConfiguration(soap, &a->Configuration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoEncoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse), type))
	{
		return soap->error;
	}
	if (a->Configuration != NULL)
	{
		soap_element_result(soap, "trt:Configuration");
	}
	if (a->Configuration != NULL)
	{	
		if (soap_out_PointerTott__VideoEncoderConfiguration(soap, "trt:Configuration", -1, &a->Configuration, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "trt:Configuration"))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationResponse * SOAP_FMAC4 soap_in__trt__GetVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfigurationResponse *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct _trt__GetVideoEncoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse, sizeof(struct _trt__GetVideoEncoderConfigurationResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default__trt__GetVideoEncoderConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoEncoderConfiguration(soap, "trt:Configuration", &a->Configuration, "tt:VideoEncoderConfiguration"))
				{	
					soap_flag_Configuration--;
					continue;
				}
				soap_check_result(soap, "trt:Configuration");
				if (soap->error == SOAP_TAG_MISMATCH)
				{
					soap->error = soap_ignore_element(soap);
				}
				if (soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{
					return NULL;
				}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _trt__GetVideoEncoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse, 0, sizeof(struct _trt__GetVideoEncoderConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoEncoderConfigurationResponse(struct soap *soap, const struct _trt__GetVideoEncoderConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse);
	if (soap_out__trt__GetVideoEncoderConfigurationResponse(soap, tag?tag:"trt:GetVideoEncoderConfigurationResponse", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationResponse * SOAP_FMAC4 soap_get__trt__GetVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoEncoderConfigurationResponse(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoEncoderConfiguration(struct soap *soap, struct _trt__GetVideoEncoderConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoEncoderConfiguration))
	{
		soap_serialize__trt__GetVideoEncoderConfiguration(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, struct _trt__GetVideoEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoEncoderConfiguration);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out__trt__GetVideoEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct _trt__GetVideoEncoderConfiguration **)soap_malloc(soap, sizeof(struct _trt__GetVideoEncoderConfiguration *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in__trt__GetVideoEncoderConfiguration(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__GetVideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfiguration, sizeof(struct _trt__GetVideoEncoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoEncoderConfiguration(struct soap *soap, struct _trt__GetVideoEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoEncoderConfiguration);
	if (soap_out_PointerTo_trt__GetVideoEncoderConfiguration(soap, tag?tag:"trt:GetVideoEncoderConfiguration", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoEncoderConfiguration(struct soap *soap, struct _trt__GetVideoEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoEncoderConfiguration(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse))
	{
		soap_serialize__trt__GetVideoEncoderConfigurationResponse(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__GetVideoEncoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out__trt__GetVideoEncoderConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct _trt__GetVideoEncoderConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__GetVideoEncoderConfigurationResponse *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in__trt__GetVideoEncoderConfigurationResponse(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__GetVideoEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse, sizeof(struct _trt__GetVideoEncoderConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoEncoderConfigurationResponse);
	if (soap_out_PointerTo_trt__GetVideoEncoderConfigurationResponse(soap, tag?tag:"trt:GetVideoEncoderConfigurationResponse", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoEncoderConfigurationResponse(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoEncoderConfiguration(struct soap *soap, struct _trt__GetVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoEncoderConfiguration(struct soap *soap, const struct _trt__GetVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoEncoderConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoEncoderConfiguration), type))
	{
		return soap->error;
	}
	if (a->ConfigurationToken != NULL)
	{	
		if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, &a->ConfigurationToken, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "trt:ConfigurationToken"))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfiguration * SOAP_FMAC4 soap_in__trt__GetVideoEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct _trt__GetVideoEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoEncoderConfiguration, sizeof(struct _trt__GetVideoEncoderConfiguration), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default__trt__GetVideoEncoderConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", &a->ConfigurationToken, "tt:ReferenceToken"))
				{	
					soap_flag_ConfigurationToken--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH)
				{
					soap->error = soap_ignore_element(soap);
				}
				if (soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{
					return NULL;
				}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__GetVideoEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoEncoderConfiguration, 0, sizeof(struct _trt__GetVideoEncoderConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoEncoderConfiguration(struct soap *soap, const struct _trt__GetVideoEncoderConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetVideoEncoderConfiguration);
	if (soap_out__trt__GetVideoEncoderConfiguration(soap, tag?tag:"trt:GetVideoEncoderConfiguration", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfiguration * SOAP_FMAC4 soap_get__trt__GetVideoEncoderConfiguration(struct soap *soap, struct _trt__GetVideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoEncoderConfiguration(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

//set video encoder
SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetVideoEncoderConfiguration(struct soap *soap, struct __trt__SetVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetVideoEncoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetVideoEncoderConfiguration(struct soap *soap, const struct __trt__SetVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__SetVideoEncoderConfiguration(soap, &a->trt__SetVideoEncoderConfiguration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__SetVideoEncoderConfiguration *a, const char *type)
{
	if (soap_out_PointerTo_trt__SetVideoEncoderConfiguration(soap, "trt:SetVideoEncoderConfiguration", -1, &a->trt__SetVideoEncoderConfiguration, ""))
	{
		return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetVideoEncoderConfiguration * SOAP_FMAC4 soap_in___trt__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, struct __trt__SetVideoEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__SetVideoEncoderConfiguration = 1;
	short soap_flag;
	a = (struct __trt__SetVideoEncoderConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetVideoEncoderConfiguration, sizeof(struct __trt__SetVideoEncoderConfiguration), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default___trt__SetVideoEncoderConfiguration(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_trt__SetVideoEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_trt__SetVideoEncoderConfiguration(soap, "trt:SetVideoEncoderConfiguration", &a->trt__SetVideoEncoderConfiguration, ""))
			{	
				soap_flag_trt__SetVideoEncoderConfiguration--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{
					return NULL;
				}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetVideoEncoderConfiguration(struct soap *soap, const struct __trt__SetVideoEncoderConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__SetVideoEncoderConfiguration(soap, tag?tag:"-trt:SetVideoEncoderConfiguration", id, a, type))
	{
		return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetVideoEncoderConfiguration * SOAP_FMAC4 soap_get___trt__SetVideoEncoderConfiguration(struct soap *soap, struct __trt__SetVideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetVideoEncoderConfiguration(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__SetVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__SetVideoEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__SetVideoEncoderConfigurationResponse(struct soap *soap, const struct _trt__SetVideoEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__SetVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__SetVideoEncoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse), type))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__SetVideoEncoderConfigurationResponse * SOAP_FMAC4 soap_in__trt__SetVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__SetVideoEncoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct _trt__SetVideoEncoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse, sizeof(struct _trt__SetVideoEncoderConfigurationResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default__trt__SetVideoEncoderConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{
				soap->error = soap_ignore_element(soap);
			}
			if (soap->error == SOAP_NO_TAG)
			{
				break;
			}
			if (soap->error)
			{
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__SetVideoEncoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse, 0, sizeof(struct _trt__SetVideoEncoderConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__SetVideoEncoderConfigurationResponse(struct soap *soap, const struct _trt__SetVideoEncoderConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse);
	if (soap_out__trt__SetVideoEncoderConfigurationResponse(soap, tag?tag:"trt:SetVideoEncoderConfigurationResponse", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetVideoEncoderConfigurationResponse * SOAP_FMAC4 soap_get__trt__SetVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__SetVideoEncoderConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__SetVideoEncoderConfigurationResponse(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__SetVideoEncoderConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse))
	{
		soap_serialize__trt__SetVideoEncoderConfigurationResponse(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__SetVideoEncoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out__trt__SetVideoEncoderConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__SetVideoEncoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct _trt__SetVideoEncoderConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__SetVideoEncoderConfigurationResponse *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in__trt__SetVideoEncoderConfigurationResponse(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__SetVideoEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse, sizeof(struct _trt__SetVideoEncoderConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__SetVideoEncoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetVideoEncoderConfigurationResponse);
	if (soap_out_PointerTo_trt__SetVideoEncoderConfigurationResponse(soap, tag?tag:"trt:SetVideoEncoderConfigurationResponse", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__SetVideoEncoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetVideoEncoderConfigurationResponse(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetVideoEncoderConfiguration(struct soap *soap, struct _trt__SetVideoEncoderConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetVideoEncoderConfiguration))
	{
		soap_serialize__trt__SetVideoEncoderConfiguration(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, struct _trt__SetVideoEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetVideoEncoderConfiguration);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out__trt__SetVideoEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetVideoEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__SetVideoEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (a == NULL)
	{
		if (NULL==(a = (struct _trt__SetVideoEncoderConfiguration **)soap_malloc(soap, sizeof(struct _trt__SetVideoEncoderConfiguration *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__trt__SetVideoEncoderConfiguration(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__SetVideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoEncoderConfiguration, sizeof(struct _trt__SetVideoEncoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetVideoEncoderConfiguration(struct soap *soap, struct _trt__SetVideoEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetVideoEncoderConfiguration);
	if (soap_out_PointerTo_trt__SetVideoEncoderConfiguration(soap, tag?tag:"trt:SetVideoEncoderConfiguration", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetVideoEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetVideoEncoderConfiguration(struct soap *soap, struct _trt__SetVideoEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetVideoEncoderConfiguration(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__SetVideoEncoderConfiguration(struct soap *soap, struct _trt__SetVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
	soap_default_xsd__boolean_(soap, &a->ForcePersistence);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__SetVideoEncoderConfiguration(struct soap *soap, const struct _trt__SetVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__VideoEncoderConfiguration(soap, &a->Configuration);
	soap_embedded(soap, &a->ForcePersistence, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__SetVideoEncoderConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__SetVideoEncoderConfiguration), type))
	{
		return soap->error;
	}
	if (a->Configuration != NULL)
	{	
		if (soap_out_PointerTott__VideoEncoderConfiguration(soap, "trt:Configuration", -1, &a->Configuration, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "trt:Configuration"))
	{
		return soap->error;
	}
	if (soap_out_xsd__boolean_(soap, "trt:ForcePersistence", -1, &a->ForcePersistence, ""))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__SetVideoEncoderConfiguration * SOAP_FMAC4 soap_in__trt__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__SetVideoEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	size_t soap_flag_ForcePersistence = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct _trt__SetVideoEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetVideoEncoderConfiguration, sizeof(struct _trt__SetVideoEncoderConfiguration), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default__trt__SetVideoEncoderConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoEncoderConfiguration(soap, "trt:Configuration", &a->Configuration, "tt:VideoEncoderConfiguration"))
				{	
					soap_flag_Configuration--;
					continue;
				}
				if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_xsd__boolean_(soap, "trt:ForcePersistence", &a->ForcePersistence, "xsd:boolean"))
					{	
						soap_flag_ForcePersistence--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH)
					{
						soap->error = soap_ignore_element(soap);
					}
					if (soap->error == SOAP_NO_TAG)
					{
						break;
					}
					if (soap->error)
					{
						return NULL;
					}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__SetVideoEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetVideoEncoderConfiguration, 0, sizeof(struct _trt__SetVideoEncoderConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0 || soap_flag_ForcePersistence > 0))
	{
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__SetVideoEncoderConfiguration(struct soap *soap, const struct _trt__SetVideoEncoderConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__SetVideoEncoderConfiguration);
	if (soap_out__trt__SetVideoEncoderConfiguration(soap, tag?tag:"trt:SetVideoEncoderConfiguration", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetVideoEncoderConfiguration * SOAP_FMAC4 soap_get__trt__SetVideoEncoderConfiguration(struct soap *soap, struct _trt__SetVideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__SetVideoEncoderConfiguration(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}


//video encoder configuration options
SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, struct __trt__GetVideoEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetVideoEncoderConfigurationOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const struct __trt__GetVideoEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetVideoEncoderConfigurationOptions(soap, &a->trt__GetVideoEncoderConfigurationOptions);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, const struct __trt__GetVideoEncoderConfigurationOptions *a, const char *type)
{
	if (soap_out_PointerTo_trt__GetVideoEncoderConfigurationOptions(soap, "trt:GetVideoEncoderConfigurationOptions", -1, &a->trt__GetVideoEncoderConfigurationOptions, ""))
	{
		return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoEncoderConfigurationOptions * SOAP_FMAC4 soap_in___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *tag, struct __trt__GetVideoEncoderConfigurationOptions *a, const char *type)
{
	size_t soap_flag_trt__GetVideoEncoderConfigurationOptions = 1;
	short soap_flag;
	a = (struct __trt__GetVideoEncoderConfigurationOptions *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetVideoEncoderConfigurationOptions, sizeof(struct __trt__GetVideoEncoderConfigurationOptions), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default___trt__GetVideoEncoderConfigurationOptions(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_trt__GetVideoEncoderConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_trt__GetVideoEncoderConfigurationOptions(soap, "trt:GetVideoEncoderConfigurationOptions", &a->trt__GetVideoEncoderConfigurationOptions, ""))
			{	
				soap_flag_trt__GetVideoEncoderConfigurationOptions--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{
					return NULL;
				}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const struct __trt__GetVideoEncoderConfigurationOptions *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetVideoEncoderConfigurationOptions(soap, tag?tag:"-trt:GetVideoEncoderConfigurationOptions", id, a, type))
	{
		return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoEncoderConfigurationOptions * SOAP_FMAC4 soap_get___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, struct __trt__GetVideoEncoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetVideoEncoderConfigurationOptions(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, const struct _trt__GetVideoEncoderConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__VideoEncoderConfigurationOptions(soap, &a->Options);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoEncoderConfigurationOptionsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse), type))
	{
		return soap->error;
	}
	if (a->Options != NULL)
	{
		soap_element_result(soap, "trt:Options");
	}
	if (a->Options != NULL)
	{	
		if (soap_out_PointerTott__VideoEncoderConfigurationOptions(soap, "trt:Options", -1, &a->Options, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "trt:Options"))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationOptionsResponse * SOAP_FMAC4 soap_in__trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfigurationOptionsResponse *a, const char *type)
{
	size_t soap_flag_Options = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct _trt__GetVideoEncoderConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse, sizeof(struct _trt__GetVideoEncoderConfigurationOptionsResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default__trt__GetVideoEncoderConfigurationOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoEncoderConfigurationOptions(soap, "trt:Options", &a->Options, "tt:VideoEncoderConfigurationOptions"))
				{	
					soap_flag_Options--;
					continue;
				}
				soap_check_result(soap, "trt:Options");
				if (soap->error == SOAP_TAG_MISMATCH)
				{
					soap->error = soap_ignore_element(soap);
				}
				if (soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{
					return NULL;
				}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__GetVideoEncoderConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse, 0, sizeof(struct _trt__GetVideoEncoderConfigurationOptionsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Options > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, const struct _trt__GetVideoEncoderConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse);
	if (soap_out__trt__GetVideoEncoderConfigurationOptionsResponse(soap, tag?tag:"trt:GetVideoEncoderConfigurationOptionsResponse", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationOptionsResponse * SOAP_FMAC4 soap_get__trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoEncoderConfigurationOptionsResponse(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationOptionsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse))
	{
		soap_serialize__trt__GetVideoEncoderConfigurationOptionsResponse(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetVideoEncoderConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out__trt__GetVideoEncoderConfigurationOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct _trt__GetVideoEncoderConfigurationOptionsResponse **)soap_malloc(soap, sizeof(struct _trt__GetVideoEncoderConfigurationOptionsResponse *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in__trt__GetVideoEncoderConfigurationOptionsResponse(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__GetVideoEncoderConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse, sizeof(struct _trt__GetVideoEncoderConfigurationOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse);
	if (soap_out_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse(soap, tag?tag:"trt:GetVideoEncoderConfigurationOptionsResponse", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoEncoderConfigurationOptions(struct soap *soap, struct _trt__GetVideoEncoderConfigurationOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions))
	{
		soap_serialize__trt__GetVideoEncoderConfigurationOptions(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, struct _trt__GetVideoEncoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out__trt__GetVideoEncoderConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct _trt__GetVideoEncoderConfigurationOptions **)soap_malloc(soap, sizeof(struct _trt__GetVideoEncoderConfigurationOptions *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in__trt__GetVideoEncoderConfigurationOptions(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__GetVideoEncoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions, sizeof(struct _trt__GetVideoEncoderConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoEncoderConfigurationOptions(struct soap *soap, struct _trt__GetVideoEncoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoEncoderConfigurationOptions);
	if (soap_out_PointerTo_trt__GetVideoEncoderConfigurationOptions(soap, tag?tag:"trt:GetVideoEncoderConfigurationOptions", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoEncoderConfigurationOptions(struct soap *soap, struct _trt__GetVideoEncoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoEncoderConfigurationOptions(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoEncoderConfigurationOptions(struct soap *soap, struct _trt__GetVideoEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const struct _trt__GetVideoEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ConfigurationToken);
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoEncoderConfigurationOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions), type))
	{
		return soap->error;
	}
	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, &a->ConfigurationToken, ""))
	{
		return soap->error;
	}
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationOptions * SOAP_FMAC4 soap_in__trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfigurationOptions *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct _trt__GetVideoEncoderConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions, sizeof(struct _trt__GetVideoEncoderConfigurationOptions), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default__trt__GetVideoEncoderConfigurationOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", &a->ConfigurationToken, "tt:ReferenceToken"))
				{	
					soap_flag_ConfigurationToken--;
					continue;
				}
				if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
					if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
					{	
						soap_flag_ProfileToken--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH)
					{
						soap->error = soap_ignore_element(soap);
					}
					if (soap->error == SOAP_NO_TAG)
					{
						break;
					}
					if (soap->error)
					{
						return NULL;
					}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__GetVideoEncoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions, 0, sizeof(struct _trt__GetVideoEncoderConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const struct _trt__GetVideoEncoderConfigurationOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions);
	if (soap_out__trt__GetVideoEncoderConfigurationOptions(soap, tag?tag:"trt:GetVideoEncoderConfigurationOptions", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationOptions * SOAP_FMAC4 soap_get__trt__GetVideoEncoderConfigurationOptions(struct soap *soap, struct _trt__GetVideoEncoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoEncoderConfigurationOptions(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoEncoderConfigurationOptions(struct soap *soap, struct tt__VideoEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->QualityRange = NULL;
	a->JPEG = NULL;
	a->MPEG4 = NULL;
	a->H264 = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoEncoderConfigurationOptions(struct soap *soap, const struct tt__VideoEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IntRange(soap, &a->QualityRange);
	soap_serialize_PointerTott__JpegOptions(soap, &a->JPEG);
	soap_serialize_PointerTott__Mpeg4Options(soap, &a->MPEG4);
	soap_serialize_PointerTott__H264Options(soap, &a->H264);
	soap_serialize_PointerTott__VideoEncoderOptionsExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__VideoEncoderConfigurationOptions *a, const char *type)
{
	if (a->__anyAttribute != NULL)
	{
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	}
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions), type))
	{
		return soap->error;
	}
	if (a->QualityRange != NULL)
	{	
		if (soap_out_PointerTott__IntRange(soap, "tt:QualityRange", -1, &a->QualityRange, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:QualityRange"))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__JpegOptions(soap, "tt:JPEG", -1, &a->JPEG, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__Mpeg4Options(soap, "tt:MPEG4", -1, &a->MPEG4, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__H264Options(soap, "tt:H264", -1, &a->H264, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__VideoEncoderOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoEncoderConfigurationOptions * SOAP_FMAC4 soap_in_tt__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, struct tt__VideoEncoderConfigurationOptions *a, const char *type)
{
	size_t soap_flag_QualityRange = 1;
	size_t soap_flag_JPEG = 1;
	size_t soap_flag_MPEG4 = 1;
	size_t soap_flag_H264 = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__VideoEncoderConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, sizeof(struct tt__VideoEncoderConfigurationOptions), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__VideoEncoderConfigurationOptions(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_QualityRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:QualityRange", &a->QualityRange, "tt:IntRange"))
				{	
					soap_flag_QualityRange--;
					continue;
				}
				if (soap_flag_JPEG && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__JpegOptions(soap, "tt:JPEG", &a->JPEG, "tt:JpegOptions"))
					{	
						soap_flag_JPEG--;
						continue;
					}
					if (soap_flag_MPEG4 && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTott__Mpeg4Options(soap, "tt:MPEG4", &a->MPEG4, "tt:Mpeg4Options"))
						{
							soap_flag_MPEG4--;
							continue;
						}
						if (soap_flag_H264 && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_PointerTott__H264Options(soap, "tt:H264", &a->H264, "tt:H264Options"))
							{	
								soap_flag_H264--;
								continue;
							}
							if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
								if (soap_in_PointerTott__VideoEncoderOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:VideoEncoderOptionsExtension"))
								{	
									soap_flag_Extension--;
									continue;
								}
								if (soap->error == SOAP_TAG_MISMATCH)
								{
									soap->error = soap_ignore_element(soap);
								}
								if (soap->error == SOAP_NO_TAG)
								{
									break;
								}
								if (soap->error)
								{
									return NULL;
								}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__VideoEncoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, 0, sizeof(struct tt__VideoEncoderConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_QualityRange > 0))
	{
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncoderConfigurationOptions(struct soap *soap, const struct tt__VideoEncoderConfigurationOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoEncoderConfigurationOptions);
	if (soap_out_tt__VideoEncoderConfigurationOptions(soap, tag?tag:"tt:VideoEncoderConfigurationOptions", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderConfigurationOptions * SOAP_FMAC4 soap_get_tt__VideoEncoderConfigurationOptions(struct soap *soap, struct tt__VideoEncoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderConfigurationOptions(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, struct tt__VideoEncoderOptionsExtension2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoEncoderOptionsExtension2))
	{	
		soap_serialize_tt__VideoEncoderOptionsExtension2(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, const char *tag, int id, struct tt__VideoEncoderOptionsExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoEncoderOptionsExtension2);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__VideoEncoderOptionsExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension2 ** SOAP_FMAC4 soap_in_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, const char *tag, struct tt__VideoEncoderOptionsExtension2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{	if (NULL==(a = (struct tt__VideoEncoderOptionsExtension2 **)soap_malloc(soap, sizeof(struct tt__VideoEncoderOptionsExtension2 *))))
	{
		return NULL;
	}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__VideoEncoderOptionsExtension2(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__VideoEncoderOptionsExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, sizeof(struct tt__VideoEncoderOptionsExtension2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, struct tt__VideoEncoderOptionsExtension2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoEncoderOptionsExtension2);
	if (soap_out_PointerTott__VideoEncoderOptionsExtension2(soap, tag?tag:"tt:VideoEncoderOptionsExtension2", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension2 ** SOAP_FMAC4 soap_get_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, struct tt__VideoEncoderOptionsExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoEncoderOptionsExtension2(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoEncoderOptionsExtension2(struct soap *soap, struct tt__VideoEncoderOptionsExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoEncoderOptionsExtension2(struct soap *soap, const struct tt__VideoEncoderOptionsExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderOptionsExtension2(struct soap *soap, const char *tag, int id, const struct tt__VideoEncoderOptionsExtension2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension2), type))
	{
		return soap->error;
	}
	if (a->__any != NULL)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_outliteral(soap, "-any", a->__any + i, NULL);
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension2 * SOAP_FMAC4 soap_in_tt__VideoEncoderOptionsExtension2(struct soap *soap, const char *tag, struct tt__VideoEncoderOptionsExtension2 *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__VideoEncoderOptionsExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, sizeof(struct tt__VideoEncoderOptionsExtension2), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__VideoEncoderOptionsExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
					{
						soap_blist___any = soap_new_block(soap);
					}
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
					{
						return NULL;
					}
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{
				soap->error = soap_ignore_element(soap);
			}
			if (soap->error == SOAP_NO_TAG)
			{
				break;
			}
			if (soap->error)
			{
				return NULL;
			}
		}
		if (a->__any != NULL)
		{
			soap_pop_block(soap, soap_blist___any);
		}
		if (a->__size)
		{
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
			{
				soap_end_block(soap, soap_blist___any);
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__VideoEncoderOptionsExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, 0, sizeof(struct tt__VideoEncoderOptionsExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncoderOptionsExtension2(struct soap *soap, const struct tt__VideoEncoderOptionsExtension2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoEncoderOptionsExtension2);
	if (soap_out_tt__VideoEncoderOptionsExtension2(soap, tag?tag:"tt:VideoEncoderOptionsExtension2", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension2 * SOAP_FMAC4 soap_get_tt__VideoEncoderOptionsExtension2(struct soap *soap, struct tt__VideoEncoderOptionsExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderOptionsExtension2(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, struct tt__VideoEncoderConfigurationOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions))
	{
		soap_serialize_tt__VideoEncoderConfigurationOptions(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__VideoEncoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoEncoderConfigurationOptions);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__VideoEncoderConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoEncoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, struct tt__VideoEncoderConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__VideoEncoderConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__VideoEncoderConfigurationOptions *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__VideoEncoderConfigurationOptions(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__VideoEncoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, sizeof(struct tt__VideoEncoderConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, struct tt__VideoEncoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoEncoderConfigurationOptions);
	if (soap_out_PointerTott__VideoEncoderConfigurationOptions(soap, tag?tag:"tt:VideoEncoderConfigurationOptions", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, struct tt__VideoEncoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoEncoderConfigurationOptions(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, struct tt__VideoEncoderOptionsExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoEncoderOptionsExtension))
	{	
		soap_serialize_tt__VideoEncoderOptionsExtension(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__VideoEncoderOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoEncoderOptionsExtension);
	if (id < 0)
	{	
		return soap->error;
	}
	return soap_out_tt__VideoEncoderOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, struct tt__VideoEncoderOptionsExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__VideoEncoderOptionsExtension **)soap_malloc(soap, sizeof(struct tt__VideoEncoderOptionsExtension *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__VideoEncoderOptionsExtension(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__VideoEncoderOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderOptionsExtension, sizeof(struct tt__VideoEncoderOptionsExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, struct tt__VideoEncoderOptionsExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoEncoderOptionsExtension);
	if (soap_out_PointerTott__VideoEncoderOptionsExtension(soap, tag?tag:"tt:VideoEncoderOptionsExtension", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, struct tt__VideoEncoderOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoEncoderOptionsExtension(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoEncoderOptionsExtension(struct soap *soap, struct tt__VideoEncoderOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->JPEG = NULL;
	a->MPEG4 = NULL;
	a->H264 = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoEncoderOptionsExtension(struct soap *soap, const struct tt__VideoEncoderOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__JpegOptions2(soap, &a->JPEG);
	soap_serialize_PointerTott__Mpeg4Options2(soap, &a->MPEG4);
	soap_serialize_PointerTott__H264Options2(soap, &a->H264);
	soap_serialize_PointerTott__VideoEncoderOptionsExtension2(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__VideoEncoderOptionsExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension), type))
	{
		return soap->error;
	}
	if (a->__any != NULL)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_outliteral(soap, "-any", a->__any + i, NULL);
		}
	}
	if (soap_out_PointerTott__JpegOptions2(soap, "tt:JPEG", -1, &a->JPEG, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__Mpeg4Options2(soap, "tt:MPEG4", -1, &a->MPEG4, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__H264Options2(soap, "tt:H264", -1, &a->H264, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__VideoEncoderOptionsExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension * SOAP_FMAC4 soap_in_tt__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, struct tt__VideoEncoderOptionsExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_JPEG = 1;
	size_t soap_flag_MPEG4 = 1;
	size_t soap_flag_H264 = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__VideoEncoderOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension, sizeof(struct tt__VideoEncoderOptionsExtension), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__VideoEncoderOptionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			//if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			//{	
			//	if (a->__any == NULL)
			//	{	
			//		if (soap_blist___any == NULL)
			//		{
			//			soap_blist___any = soap_new_block(soap);
			//		}
			//		a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
			//		if (a->__any == NULL)
			//		{
			//			return NULL;
			//		}
			//		*a->__any = NULL;
			//	}
			//	if (soap_inliteral(soap, "-any", a->__any))
			//	{	
			//		a->__size++;
			//		a->__any = NULL;
			//		continue;
			//	}
			//}
			if (soap_flag_JPEG && soap->error == SOAP_TAG_MISMATCH)
			{
				if (soap_in_PointerTott__JpegOptions2(soap, "tt:JPEG", &a->JPEG, "tt:JpegOptions2"))
				{	
					soap_flag_JPEG--;
					continue;
				}
			}
			if (soap_flag_MPEG4 && soap->error == SOAP_TAG_MISMATCH)
			{	
				if (soap_in_PointerTott__Mpeg4Options2(soap, "tt:MPEG4", &a->MPEG4, "tt:Mpeg4Options2"))
				{	
					soap_flag_MPEG4--;
					continue;
				}
			}
			if (soap_flag_H264 && soap->error == SOAP_TAG_MISMATCH)
			{
				if (soap_in_PointerTott__H264Options2(soap, "tt:H264", &a->H264, "tt:H264Options2"))
				{	
					soap_flag_H264--;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
			{
				if (soap_in_PointerTott__VideoEncoderOptionsExtension2(soap, "tt:Extension", &a->Extension, "tt:VideoEncoderOptionsExtension2"))
				{	
					soap_flag_Extension--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{
				soap->error = soap_ignore_element(soap);
			}
			if (soap->error == SOAP_NO_TAG)
			{
				break;
			}
			if (soap->error)
			{
				return NULL;
			}
		}
		if (a->__any != NULL)
		{
			soap_pop_block(soap, soap_blist___any);
		}
		if (a->__size)
		{
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
			{
				soap_end_block(soap, soap_blist___any);
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__VideoEncoderOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderOptionsExtension, 0, sizeof(struct tt__VideoEncoderOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncoderOptionsExtension(struct soap *soap, const struct tt__VideoEncoderOptionsExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoEncoderOptionsExtension);
	if (soap_out_tt__VideoEncoderOptionsExtension(soap, tag?tag:"tt:VideoEncoderOptionsExtension", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension * SOAP_FMAC4 soap_get_tt__VideoEncoderOptionsExtension(struct soap *soap, struct tt__VideoEncoderOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderOptionsExtension(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264Options2(struct soap *soap, struct tt__H264Options2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__H264Options2))
	{
		soap_serialize_tt__H264Options2(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264Options2(struct soap *soap, const char *tag, int id, struct tt__H264Options2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__H264Options2);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__H264Options2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__H264Options2 ** SOAP_FMAC4 soap_in_PointerTott__H264Options2(struct soap *soap, const char *tag, struct tt__H264Options2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__H264Options2 **)soap_malloc(soap, sizeof(struct tt__H264Options2 *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__H264Options2(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__H264Options2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Options2, sizeof(struct tt__H264Options2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264Options2(struct soap *soap, struct tt__H264Options2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__H264Options2);
	if (soap_out_PointerTott__H264Options2(soap, tag?tag:"tt:H264Options2", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264Options2 ** SOAP_FMAC4 soap_get_PointerTott__H264Options2(struct soap *soap, struct tt__H264Options2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__H264Options2(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4Options2(struct soap *soap, struct tt__Mpeg4Options2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Mpeg4Options2))
	{
		soap_serialize_tt__Mpeg4Options2(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4Options2(struct soap *soap, const char *tag, int id, struct tt__Mpeg4Options2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Mpeg4Options2);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__Mpeg4Options2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Mpeg4Options2 ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4Options2(struct soap *soap, const char *tag, struct tt__Mpeg4Options2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__Mpeg4Options2 **)soap_malloc(soap, sizeof(struct tt__Mpeg4Options2 *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__Mpeg4Options2(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__Mpeg4Options2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Options2, sizeof(struct tt__Mpeg4Options2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4Options2(struct soap *soap, struct tt__Mpeg4Options2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Mpeg4Options2);
	if (soap_out_PointerTott__Mpeg4Options2(soap, tag?tag:"tt:Mpeg4Options2", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4Options2 ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4Options2(struct soap *soap, struct tt__Mpeg4Options2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Mpeg4Options2(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__JpegOptions2(struct soap *soap, struct tt__JpegOptions2 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__JpegOptions2))
	{
		soap_serialize_tt__JpegOptions2(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__JpegOptions2(struct soap *soap, const char *tag, int id, struct tt__JpegOptions2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__JpegOptions2);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__JpegOptions2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__JpegOptions2 ** SOAP_FMAC4 soap_in_PointerTott__JpegOptions2(struct soap *soap, const char *tag, struct tt__JpegOptions2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__JpegOptions2 **)soap_malloc(soap, sizeof(struct tt__JpegOptions2 *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__JpegOptions2(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__JpegOptions2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__JpegOptions2, sizeof(struct tt__JpegOptions2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__JpegOptions2(struct soap *soap, struct tt__JpegOptions2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__JpegOptions2);
	if (soap_out_PointerTott__JpegOptions2(soap, tag?tag:"tt:JpegOptions2", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__JpegOptions2 ** SOAP_FMAC4 soap_get_PointerTott__JpegOptions2(struct soap *soap, struct tt__JpegOptions2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__JpegOptions2(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}



SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264Options(struct soap *soap, struct tt__H264Options *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__H264Options))
	{
		soap_serialize_tt__H264Options(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264Options(struct soap *soap, const char *tag, int id, struct tt__H264Options *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__H264Options);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__H264Options(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__H264Options ** SOAP_FMAC4 soap_in_PointerTott__H264Options(struct soap *soap, const char *tag, struct tt__H264Options **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__H264Options **)soap_malloc(soap, sizeof(struct tt__H264Options *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__H264Options(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{
		a = (struct tt__H264Options **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Options, sizeof(struct tt__H264Options), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264Options(struct soap *soap, struct tt__H264Options *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__H264Options);
	if (soap_out_PointerTott__H264Options(soap, tag?tag:"tt:H264Options", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264Options ** SOAP_FMAC4 soap_get_PointerTott__H264Options(struct soap *soap, struct tt__H264Options **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__H264Options(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4Options(struct soap *soap, struct tt__Mpeg4Options *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Mpeg4Options))
	{
		soap_serialize_tt__Mpeg4Options(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4Options(struct soap *soap, const char *tag, int id, struct tt__Mpeg4Options *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Mpeg4Options);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__Mpeg4Options(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Mpeg4Options ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4Options(struct soap *soap, const char *tag, struct tt__Mpeg4Options **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__Mpeg4Options **)soap_malloc(soap, sizeof(struct tt__Mpeg4Options *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__Mpeg4Options(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__Mpeg4Options **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Options, sizeof(struct tt__Mpeg4Options), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4Options(struct soap *soap, struct tt__Mpeg4Options *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Mpeg4Options);
	if (soap_out_PointerTott__Mpeg4Options(soap, tag?tag:"tt:Mpeg4Options", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4Options ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4Options(struct soap *soap, struct tt__Mpeg4Options **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Mpeg4Options(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__JpegOptions(struct soap *soap, struct tt__JpegOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__JpegOptions))
	{
		soap_serialize_tt__JpegOptions(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__JpegOptions(struct soap *soap, const char *tag, int id, struct tt__JpegOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__JpegOptions);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__JpegOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__JpegOptions ** SOAP_FMAC4 soap_in_PointerTott__JpegOptions(struct soap *soap, const char *tag, struct tt__JpegOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__JpegOptions **)soap_malloc(soap, sizeof(struct tt__JpegOptions *))))
		{
			return NULL;
		}

	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__JpegOptions(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__JpegOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__JpegOptions, sizeof(struct tt__JpegOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__JpegOptions(struct soap *soap, struct tt__JpegOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__JpegOptions);
	if (soap_out_PointerTott__JpegOptions(soap, tag?tag:"tt:JpegOptions", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__JpegOptions ** SOAP_FMAC4 soap_get_PointerTott__JpegOptions(struct soap *soap, struct tt__JpegOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__JpegOptions(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}




SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__H264Options2(struct soap *soap, struct tt__H264Options2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->GovLengthRange = NULL;
	a->FrameRateRange = NULL;
	a->EncodingIntervalRange = NULL;
	a->__sizeH264ProfilesSupported = 0;
	a->H264ProfilesSupported = NULL;
	a->BitrateRange = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__H264Options2(struct soap *soap, const struct tt__H264Options2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ResolutionsAvailable != NULL)
	{	
		int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->GovLengthRange);
	soap_serialize_PointerTott__IntRange(soap, &a->FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &a->EncodingIntervalRange);
	if (a->H264ProfilesSupported != NULL)
	{	
		int i;
		for (i = 0; i < a->__sizeH264ProfilesSupported; i++)
		{
			soap_embedded(soap, a->H264ProfilesSupported + i, SOAP_TYPE_tt__H264Profile);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->BitrateRange);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Options2(struct soap *soap, const char *tag, int id, const struct tt__H264Options2 *a, const char *type)
{
	if (a->__anyAttribute != NULL)
	{
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	}
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Options2), type))
	{
		return soap->error;
	}
	if (a->ResolutionsAvailable != NULL)
	{	
		int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
		{
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
			{
				return soap->error;
			}
		}
	}
	if (a->GovLengthRange != NULL)
	{	
		if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->GovLengthRange, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:GovLengthRange"))
	{
		return soap->error;
	}
	if (a->FrameRateRange != NULL)
	{	
		if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->FrameRateRange, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:FrameRateRange"))
	{
		return soap->error;
	}
	if (a->EncodingIntervalRange != NULL)
	{	
		if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->EncodingIntervalRange, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:EncodingIntervalRange"))
	{
		return soap->error;
	}
	if (a->H264ProfilesSupported != NULL)
	{	
		int i;
		for (i = 0; i < a->__sizeH264ProfilesSupported; i++)
		{
			if (soap_out_tt__H264Profile(soap, "tt:H264ProfilesSupported", -1, a->H264ProfilesSupported + i, ""))
			{
				return soap->error;
			}
		}
	}
	if (a->BitrateRange != NULL)
	{	
		if (soap_out_PointerTott__IntRange(soap, "tt:BitrateRange", -1, &a->BitrateRange, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:BitrateRange"))
	{
		return soap->error;
	}
	if (a->__any != NULL)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_outliteral(soap, "-any", a->__any + i, NULL);
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__H264Options2 * SOAP_FMAC4 soap_in_tt__H264Options2(struct soap *soap, const char *tag, struct tt__H264Options2 *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_GovLengthRange = 1;
	size_t soap_flag_FrameRateRange = 1;
	size_t soap_flag_EncodingIntervalRange = 1;
	struct soap_blist *soap_blist_H264ProfilesSupported = NULL;
	size_t soap_flag_BitrateRange = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__H264Options2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Options2, sizeof(struct tt__H264Options2), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__H264Options2(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	
				if (a->ResolutionsAvailable == NULL)
				{
					if (soap_blist_ResolutionsAvailable == NULL)
					{
						soap_blist_ResolutionsAvailable = soap_new_block(soap);
					}
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
					{
						return NULL;
					}
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	
					a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_GovLengthRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &a->GovLengthRange, "tt:IntRange"))
				{	
					soap_flag_GovLengthRange--;
					continue;
				}
				if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->FrameRateRange, "tt:IntRange"))
					{	
						soap_flag_FrameRateRange--;
						continue;
					}
					if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->EncodingIntervalRange, "tt:IntRange"))
						{	
							soap_flag_EncodingIntervalRange--;
							continue;
						}
						if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:H264ProfilesSupported", 1, NULL))
						{	
							if (a->H264ProfilesSupported == NULL)
							{	
								if (soap_blist_H264ProfilesSupported == NULL)
								{
									soap_blist_H264ProfilesSupported = soap_new_block(soap);
								}
								a->H264ProfilesSupported = (enum tt__H264Profile *)soap_push_block(soap, soap_blist_H264ProfilesSupported, sizeof(enum tt__H264Profile));
								if (a->H264ProfilesSupported == NULL)
								{
									return NULL;
								}
								soap_default_tt__H264Profile(soap, a->H264ProfilesSupported);
							}
							soap_revert(soap);
							if (soap_in_tt__H264Profile(soap, "tt:H264ProfilesSupported", a->H264ProfilesSupported, "tt:H264Profile"))
							{	
								a->__sizeH264ProfilesSupported++;
								a->H264ProfilesSupported = NULL;
								continue;
							}
						}
						if (soap_flag_BitrateRange && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_PointerTott__IntRange(soap, "tt:BitrateRange", &a->BitrateRange, "tt:IntRange"))
							{	
								soap_flag_BitrateRange--;
								continue;
							}
							if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
							{	
								if (a->__any == NULL)
								{	
									if (soap_blist___any == NULL)
									{
										soap_blist___any = soap_new_block(soap);
									}
									a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
									if (a->__any == NULL)
									{
										return NULL;
									}
									*a->__any = NULL;
								}
								if (soap_inliteral(soap, "-any", a->__any))
								{	
									a->__size++;
									a->__any = NULL;
									continue;
								}
							}
							if (soap->error == SOAP_TAG_MISMATCH)
							{
								soap->error = soap_ignore_element(soap);
							}
							if (soap->error == SOAP_NO_TAG)
							{
								break;
							}
							if (soap->error)
							{
								return NULL;
							}
		}
		if (a->ResolutionsAvailable != NULL)
		{
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (a->__sizeResolutionsAvailable)
		{
			a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		}
		else
		{	
			a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
			{
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
			}
		}
		if (a->H264ProfilesSupported != NULL)
		{
			soap_pop_block(soap, soap_blist_H264ProfilesSupported);
		}
		if (a->__sizeH264ProfilesSupported)
		{
			a->H264ProfilesSupported = (enum tt__H264Profile *)soap_save_block(soap, soap_blist_H264ProfilesSupported, NULL, 1);
		}
		else
		{	
			a->H264ProfilesSupported = NULL;
			if (soap_blist_H264ProfilesSupported)
			{
				soap_end_block(soap, soap_blist_H264ProfilesSupported);
			}
		}
		if (a->__any != NULL)
		{
			soap_pop_block(soap, soap_blist___any);
		}
		if (a->__size)
		{
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
			{
				soap_end_block(soap, soap_blist___any);
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__H264Options2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Options2, 0, sizeof(struct tt__H264Options2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || soap_flag_GovLengthRange > 0 || soap_flag_FrameRateRange > 0 || soap_flag_EncodingIntervalRange > 0 || a->__sizeH264ProfilesSupported < 1 || soap_flag_BitrateRange > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__H264Options2(struct soap *soap, const struct tt__H264Options2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__H264Options2);
	if (soap_out_tt__H264Options2(soap, tag?tag:"tt:H264Options2", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264Options2 * SOAP_FMAC4 soap_get_tt__H264Options2(struct soap *soap, struct tt__H264Options2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Options2(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Mpeg4Options2(struct soap *soap, struct tt__Mpeg4Options2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->GovLengthRange = NULL;
	a->FrameRateRange = NULL;
	a->EncodingIntervalRange = NULL;
	a->__sizeMpeg4ProfilesSupported = 0;
	a->Mpeg4ProfilesSupported = NULL;
	a->BitrateRange = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Mpeg4Options2(struct soap *soap, const struct tt__Mpeg4Options2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ResolutionsAvailable != NULL)
	{	
		int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->GovLengthRange);
	soap_serialize_PointerTott__IntRange(soap, &a->FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &a->EncodingIntervalRange);
	if (a->Mpeg4ProfilesSupported != NULL)
	{	
		int i;
		for (i = 0; i < a->__sizeMpeg4ProfilesSupported; i++)
		{
			soap_embedded(soap, a->Mpeg4ProfilesSupported + i, SOAP_TYPE_tt__Mpeg4Profile);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->BitrateRange);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Options2(struct soap *soap, const char *tag, int id, const struct tt__Mpeg4Options2 *a, const char *type)
{
	if (a->__anyAttribute != NULL)
	{
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	}
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Options2), type))
	{
		return soap->error;
	}
	if (a->ResolutionsAvailable != NULL)
	{	
		int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
		{
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
			{
				return soap->error;
			}
		}
	}
	if (a->GovLengthRange != NULL)
	{	
		if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->GovLengthRange, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:GovLengthRange"))
	{
		return soap->error;
	}
	if (a->FrameRateRange != NULL)
	{
		if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->FrameRateRange, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:FrameRateRange"))
	{
		return soap->error;
	}
	if (a->EncodingIntervalRange != NULL)
	{	
		if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->EncodingIntervalRange, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:EncodingIntervalRange"))
	{
		return soap->error;
	}
	if (a->Mpeg4ProfilesSupported != NULL)
	{	
		int i;
		for (i = 0; i < a->__sizeMpeg4ProfilesSupported; i++)
		{
			if (soap_out_tt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", -1, a->Mpeg4ProfilesSupported + i, ""))
			{
				return soap->error;
			}
		}
	}
	if (a->BitrateRange != NULL)
	{	
		if (soap_out_PointerTott__IntRange(soap, "tt:BitrateRange", -1, &a->BitrateRange, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:BitrateRange"))
	{
		return soap->error;
	}
	if (a->__any != NULL)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_outliteral(soap, "-any", a->__any + i, NULL);
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Mpeg4Options2 * SOAP_FMAC4 soap_in_tt__Mpeg4Options2(struct soap *soap, const char *tag, struct tt__Mpeg4Options2 *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_GovLengthRange = 1;
	size_t soap_flag_FrameRateRange = 1;
	size_t soap_flag_EncodingIntervalRange = 1;
	struct soap_blist *soap_blist_Mpeg4ProfilesSupported = NULL;
	size_t soap_flag_BitrateRange = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__Mpeg4Options2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Options2, sizeof(struct tt__Mpeg4Options2), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__Mpeg4Options2(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	
				if (a->ResolutionsAvailable == NULL)
				{	
					if (soap_blist_ResolutionsAvailable == NULL)
					{
						soap_blist_ResolutionsAvailable = soap_new_block(soap);
					}
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
					{
						return NULL;
					}
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	
					a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_GovLengthRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &a->GovLengthRange, "tt:IntRange"))
				{	
					soap_flag_GovLengthRange--;
					continue;
				}
				if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->FrameRateRange, "tt:IntRange"))
					{	
						soap_flag_FrameRateRange--;
						continue;
					}
					if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->EncodingIntervalRange, "tt:IntRange"))
						{	
							soap_flag_EncodingIntervalRange--;
							continue;
						}
						if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mpeg4ProfilesSupported", 1, NULL))
						{	
							if (a->Mpeg4ProfilesSupported == NULL)
							{	
								if (soap_blist_Mpeg4ProfilesSupported == NULL)
								{
									soap_blist_Mpeg4ProfilesSupported = soap_new_block(soap);
								}
								a->Mpeg4ProfilesSupported = (enum tt__Mpeg4Profile *)soap_push_block(soap, soap_blist_Mpeg4ProfilesSupported, sizeof(enum tt__Mpeg4Profile));
								if (a->Mpeg4ProfilesSupported == NULL)
								{
									return NULL;
								}
								soap_default_tt__Mpeg4Profile(soap, a->Mpeg4ProfilesSupported);
							}
							soap_revert(soap);
							if (soap_in_tt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", a->Mpeg4ProfilesSupported, "tt:Mpeg4Profile"))
							{	
								a->__sizeMpeg4ProfilesSupported++;
								a->Mpeg4ProfilesSupported = NULL;
								continue;
							}
						}
						if (soap_flag_BitrateRange && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_PointerTott__IntRange(soap, "tt:BitrateRange", &a->BitrateRange, "tt:IntRange"))
							{	
								soap_flag_BitrateRange--;
								continue;
							}
							if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
							{	
								if (a->__any == NULL)
								{	
									if (soap_blist___any == NULL)
									{
										soap_blist___any = soap_new_block(soap);
									}
									a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
									if (a->__any == NULL)
									{
										return NULL;
									}
									*a->__any = NULL;
								}
								if (soap_inliteral(soap, "-any", a->__any))
								{	
									a->__size++;
									a->__any = NULL;
									continue;
								}
							}
							if (soap->error == SOAP_TAG_MISMATCH)
							{
								soap->error = soap_ignore_element(soap);
							}
							if (soap->error == SOAP_NO_TAG)
							{
								break;
							}
							if (soap->error)
							{
								return NULL;
							}
		}
		if (a->ResolutionsAvailable != NULL)
		{
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (a->__sizeResolutionsAvailable)
		{
			a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		}
		else
		{	
			a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
			{
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
			}
		}
		if (a->Mpeg4ProfilesSupported != NULL)
		{
			soap_pop_block(soap, soap_blist_Mpeg4ProfilesSupported);
		}
		if (a->__sizeMpeg4ProfilesSupported)
		{
			a->Mpeg4ProfilesSupported = (enum tt__Mpeg4Profile *)soap_save_block(soap, soap_blist_Mpeg4ProfilesSupported, NULL, 1);
		}
		else
		{	
			a->Mpeg4ProfilesSupported = NULL;
			if (soap_blist_Mpeg4ProfilesSupported)
			{
				soap_end_block(soap, soap_blist_Mpeg4ProfilesSupported);
			}
		}
		if (a->__any != NULL)
		{
			soap_pop_block(soap, soap_blist___any);
		}
		if (a->__size)
		{
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
			{
				soap_end_block(soap, soap_blist___any);
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__Mpeg4Options2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Options2, 0, sizeof(struct tt__Mpeg4Options2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || soap_flag_GovLengthRange > 0 || soap_flag_FrameRateRange > 0 || soap_flag_EncodingIntervalRange > 0 || a->__sizeMpeg4ProfilesSupported < 1 || soap_flag_BitrateRange > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Mpeg4Options2(struct soap *soap, const struct tt__Mpeg4Options2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Mpeg4Options2);
	if (soap_out_tt__Mpeg4Options2(soap, tag?tag:"tt:Mpeg4Options2", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4Options2 * SOAP_FMAC4 soap_get_tt__Mpeg4Options2(struct soap *soap, struct tt__Mpeg4Options2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Options2(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__JpegOptions2(struct soap *soap, struct tt__JpegOptions2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->FrameRateRange = NULL;
	a->EncodingIntervalRange = NULL;
	a->BitrateRange = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__JpegOptions2(struct soap *soap, const struct tt__JpegOptions2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ResolutionsAvailable != NULL)
	{	
		int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &a->EncodingIntervalRange);
	soap_serialize_PointerTott__IntRange(soap, &a->BitrateRange);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__JpegOptions2(struct soap *soap, const char *tag, int id, const struct tt__JpegOptions2 *a, const char *type)
{
	if (a->__anyAttribute != NULL)
	{
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	}
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__JpegOptions2), type))
	{
		return soap->error;
	}
	if (a->ResolutionsAvailable != NULL)
	{	
		int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
		{
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
			{
				return soap->error;
			}
		}
	}
	if (a->FrameRateRange != NULL)
	{	
		if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->FrameRateRange, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:FrameRateRange"))
	{
		return soap->error;
	}
	if (a->EncodingIntervalRange != NULL)
	{
		if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->EncodingIntervalRange, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:EncodingIntervalRange"))
	{
		return soap->error;
	}
	if (a->BitrateRange != NULL)
	{	
		if (soap_out_PointerTott__IntRange(soap, "tt:BitrateRange", -1, &a->BitrateRange, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:BitrateRange"))
	{
		return soap->error;
	}
	if (a->__any != NULL)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_outliteral(soap, "-any", a->__any + i, NULL);
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__JpegOptions2 * SOAP_FMAC4 soap_in_tt__JpegOptions2(struct soap *soap, const char *tag, struct tt__JpegOptions2 *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_FrameRateRange = 1;
	size_t soap_flag_EncodingIntervalRange = 1;
	size_t soap_flag_BitrateRange = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__JpegOptions2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__JpegOptions2, sizeof(struct tt__JpegOptions2), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__JpegOptions2(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	
				if (a->ResolutionsAvailable == NULL)
				{	
					if (soap_blist_ResolutionsAvailable == NULL)
					{
						soap_blist_ResolutionsAvailable = soap_new_block(soap);
					}
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
					{
						return NULL;
					}
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	
					a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->FrameRateRange, "tt:IntRange"))
				{	
					soap_flag_FrameRateRange--;
					continue;
				}
				if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->EncodingIntervalRange, "tt:IntRange"))
					{	
						soap_flag_EncodingIntervalRange--;
						continue;
					}
					if (soap_flag_BitrateRange && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTott__IntRange(soap, "tt:BitrateRange", &a->BitrateRange, "tt:IntRange"))
						{	
							soap_flag_BitrateRange--;
							continue;
						}	
						if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
						{	
							if (a->__any == NULL)
							{	
								if (soap_blist___any == NULL)
								{
									soap_blist___any = soap_new_block(soap);
								}
								a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
								if (a->__any == NULL)
								{
									return NULL;
								}
								*a->__any = NULL;
							}
							if (soap_inliteral(soap, "-any", a->__any))
							{	
								a->__size++;
								a->__any = NULL;
								continue;
							}
						}
						if (soap->error == SOAP_TAG_MISMATCH)
						{
							soap->error = soap_ignore_element(soap);
						}
						if (soap->error == SOAP_NO_TAG)
						{
							break;
						}
						if (soap->error)
						{
							return NULL;
						}
		}
		if (a->ResolutionsAvailable != NULL)
		{
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (a->__sizeResolutionsAvailable)
		{
			a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		}
		else
		{	
			a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
			{
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
			}
		}
		if (a->__any != NULL)
		{
			soap_pop_block(soap, soap_blist___any);
		}
		if (a->__size)
		{
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
			{
				soap_end_block(soap, soap_blist___any);
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct tt__JpegOptions2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__JpegOptions2, 0, sizeof(struct tt__JpegOptions2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || soap_flag_FrameRateRange > 0 || soap_flag_EncodingIntervalRange > 0 || soap_flag_BitrateRange > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__JpegOptions2(struct soap *soap, const struct tt__JpegOptions2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__JpegOptions2);
	if (soap_out_tt__JpegOptions2(soap, tag?tag:"tt:JpegOptions2", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__JpegOptions2 * SOAP_FMAC4 soap_get_tt__JpegOptions2(struct soap *soap, struct tt__JpegOptions2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__JpegOptions2(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}



SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__H264Options(struct soap *soap, struct tt__H264Options *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->GovLengthRange = NULL;
	a->FrameRateRange = NULL;
	a->EncodingIntervalRange = NULL;
	a->__sizeH264ProfilesSupported = 0;
	a->H264ProfilesSupported = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__H264Options(struct soap *soap, const struct tt__H264Options *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ResolutionsAvailable != NULL)
	{	
		int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->GovLengthRange);
	soap_serialize_PointerTott__IntRange(soap, &a->FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &a->EncodingIntervalRange);
	if (a->H264ProfilesSupported)
	{	
		int i;
		for (i = 0; i < a->__sizeH264ProfilesSupported; i++)
		{
			soap_embedded(soap, a->H264ProfilesSupported + i, SOAP_TYPE_tt__H264Profile);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Options(struct soap *soap, const char *tag, int id, const struct tt__H264Options *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Options), type))
	{
		return soap->error;
	}

	if (a->ResolutionsAvailable != NULL)
	{	
		int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
		{
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
			{
				return soap->error;
			}
		}
	}
	if (a->GovLengthRange != NULL)
	{	
		if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->GovLengthRange, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:GovLengthRange"))
	{
		return soap->error;
	}
	if (a->FrameRateRange != NULL)
	{	
		if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->FrameRateRange, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:FrameRateRange"))
	{
		return soap->error;
	}
	if (a->EncodingIntervalRange != NULL)
	{	
		if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->EncodingIntervalRange, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:EncodingIntervalRange"))
	{
		return soap->error;
	}
	if (a->H264ProfilesSupported != NULL)
	{	
		int i;
		for (i = 0; i < a->__sizeH264ProfilesSupported; i++)
		{
			if (soap_out_tt__H264Profile(soap, "tt:H264ProfilesSupported", -1, a->H264ProfilesSupported + i, ""))
			{
				return soap->error;
			}
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__H264Options * SOAP_FMAC4 soap_in_tt__H264Options(struct soap *soap, const char *tag, struct tt__H264Options *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_GovLengthRange = 1;
	size_t soap_flag_FrameRateRange = 1;
	size_t soap_flag_EncodingIntervalRange = 1;
	struct soap_blist *soap_blist_H264ProfilesSupported = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__H264Options *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Options, sizeof(struct tt__H264Options), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__H264Options(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	
				if (a->ResolutionsAvailable == NULL)
				{	
					if (soap_blist_ResolutionsAvailable == NULL)
					{
						soap_blist_ResolutionsAvailable = soap_new_block(soap);
					}
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
					{
						return NULL;
					}
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	
					a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_GovLengthRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &a->GovLengthRange, "tt:IntRange"))
				{	
					soap_flag_GovLengthRange--;
					continue;
				}
				if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->FrameRateRange, "tt:IntRange"))
					{	
						soap_flag_FrameRateRange--;
						continue;
					}
					if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->EncodingIntervalRange, "tt:IntRange"))
						{	
							soap_flag_EncodingIntervalRange--;
							continue;
						}
						if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:H264ProfilesSupported", 1, NULL))
						{	
							if (a->H264ProfilesSupported == NULL)
							{	
								if (soap_blist_H264ProfilesSupported == NULL)
								{
									soap_blist_H264ProfilesSupported = soap_new_block(soap);
								}
								a->H264ProfilesSupported = (enum tt__H264Profile *)soap_push_block(soap, soap_blist_H264ProfilesSupported, sizeof(enum tt__H264Profile));
								if (a->H264ProfilesSupported == NULL)
								{
									return NULL;
								}
								soap_default_tt__H264Profile(soap, a->H264ProfilesSupported);
							}
							soap_revert(soap);
							if (soap_in_tt__H264Profile(soap, "tt:H264ProfilesSupported", a->H264ProfilesSupported, "tt:H264Profile"))
							{	
								a->__sizeH264ProfilesSupported++;
								a->H264ProfilesSupported = NULL;
								continue;
							}
						}
						if (soap->error == SOAP_TAG_MISMATCH)
						{
							soap->error = soap_ignore_element(soap);
						}
						if (soap->error == SOAP_NO_TAG)
						{
							break;
						}
						if (soap->error)
						{
							return NULL;
						}
		}
		if (a->ResolutionsAvailable != NULL)
		{
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (a->__sizeResolutionsAvailable)
		{
			a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		}
		else
		{
			a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
			{
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
			}
		}
		if (a->H264ProfilesSupported != NULL)
		{
			soap_pop_block(soap, soap_blist_H264ProfilesSupported);
		}
		if (a->__sizeH264ProfilesSupported)
		{
			a->H264ProfilesSupported = (enum tt__H264Profile *)soap_save_block(soap, soap_blist_H264ProfilesSupported, NULL, 1);
		}
		else
		{	
			a->H264ProfilesSupported = NULL;
			if (soap_blist_H264ProfilesSupported)
			{
				soap_end_block(soap, soap_blist_H264ProfilesSupported);
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{
		a = (struct tt__H264Options *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Options, 0, sizeof(struct tt__H264Options), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || soap_flag_GovLengthRange > 0 || soap_flag_FrameRateRange > 0 || soap_flag_EncodingIntervalRange > 0 || a->__sizeH264ProfilesSupported < 1))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__H264Options(struct soap *soap, const struct tt__H264Options *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__H264Options);
	if (soap_out_tt__H264Options(soap, tag?tag:"tt:H264Options", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264Options * SOAP_FMAC4 soap_get_tt__H264Options(struct soap *soap, struct tt__H264Options *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Options(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Mpeg4Options(struct soap *soap, struct tt__Mpeg4Options *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->GovLengthRange = NULL;
	a->FrameRateRange = NULL;
	a->EncodingIntervalRange = NULL;
	a->__sizeMpeg4ProfilesSupported = 0;
	a->Mpeg4ProfilesSupported = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Mpeg4Options(struct soap *soap, const struct tt__Mpeg4Options *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ResolutionsAvailable != NULL)
	{	
		int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->GovLengthRange);
	soap_serialize_PointerTott__IntRange(soap, &a->FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &a->EncodingIntervalRange);
	if (a->Mpeg4ProfilesSupported)
	{	
		int i;
		for (i = 0; i < a->__sizeMpeg4ProfilesSupported; i++)
		{
			soap_embedded(soap, a->Mpeg4ProfilesSupported + i, SOAP_TYPE_tt__Mpeg4Profile);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Options(struct soap *soap, const char *tag, int id, const struct tt__Mpeg4Options *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Options), type))
	{
		return soap->error;
	}
	if (a->ResolutionsAvailable != NULL)
	{	
		int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
		{
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
			{
				return soap->error;
			}
		}
	}
	if (a->GovLengthRange != NULL)
	{
		if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->GovLengthRange, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:GovLengthRange"))
	{
		return soap->error;
	}
	if (a->FrameRateRange != NULL)
	{
		if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->FrameRateRange, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:FrameRateRange"))
	{
		return soap->error;
	}
	if (a->EncodingIntervalRange != NULL)
	{	
		if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->EncodingIntervalRange, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:EncodingIntervalRange"))
	{
		return soap->error;
	}
	if (a->Mpeg4ProfilesSupported != NULL)
	{	
		int i;
		for (i = 0; i < a->__sizeMpeg4ProfilesSupported; i++)
		{
			if (soap_out_tt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", -1, a->Mpeg4ProfilesSupported + i, ""))
			{
				return soap->error;
			}
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Mpeg4Options * SOAP_FMAC4 soap_in_tt__Mpeg4Options(struct soap *soap, const char *tag, struct tt__Mpeg4Options *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_GovLengthRange = 1;
	size_t soap_flag_FrameRateRange = 1;
	size_t soap_flag_EncodingIntervalRange = 1;
	struct soap_blist *soap_blist_Mpeg4ProfilesSupported = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__Mpeg4Options *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Options, sizeof(struct tt__Mpeg4Options), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__Mpeg4Options(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	
				if (a->ResolutionsAvailable == NULL)
				{	
					if (soap_blist_ResolutionsAvailable == NULL)
					{
						soap_blist_ResolutionsAvailable = soap_new_block(soap);
					}
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
					{
						return NULL;
					}
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	
					a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_GovLengthRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &a->GovLengthRange, "tt:IntRange"))
				{	
					soap_flag_GovLengthRange--;
					continue;
				}
				if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->FrameRateRange, "tt:IntRange"))
					{	
						soap_flag_FrameRateRange--;
						continue;
					}
					if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->EncodingIntervalRange, "tt:IntRange"))
						{	
							soap_flag_EncodingIntervalRange--;
							continue;
						}
						if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mpeg4ProfilesSupported", 1, NULL))
						{	
							if (a->Mpeg4ProfilesSupported == NULL)
							{	
								if (soap_blist_Mpeg4ProfilesSupported == NULL)
								{
									soap_blist_Mpeg4ProfilesSupported = soap_new_block(soap);
								}
								a->Mpeg4ProfilesSupported = (enum tt__Mpeg4Profile *)soap_push_block(soap, soap_blist_Mpeg4ProfilesSupported, sizeof(enum tt__Mpeg4Profile));
								if (a->Mpeg4ProfilesSupported == NULL)
								{
									return NULL;
								}
								soap_default_tt__Mpeg4Profile(soap, a->Mpeg4ProfilesSupported);
							}
							soap_revert(soap);
							if (soap_in_tt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", a->Mpeg4ProfilesSupported, "tt:Mpeg4Profile"))
							{
								a->__sizeMpeg4ProfilesSupported++;
								a->Mpeg4ProfilesSupported = NULL;
								continue;
							}
						}
						if (soap->error == SOAP_TAG_MISMATCH)
						{
							soap->error = soap_ignore_element(soap);
						}
						if (soap->error == SOAP_NO_TAG)
						{
							break;
						}
						if (soap->error)
						{
							return NULL;
						}
		}
		if (a->ResolutionsAvailable != NULL)
		{
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (a->__sizeResolutionsAvailable)
		{
			a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		}
		else
		{	

			a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
			{
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
			}
		}
		if (a->Mpeg4ProfilesSupported != NULL)
		{
			soap_pop_block(soap, soap_blist_Mpeg4ProfilesSupported);
		}
		if (a->__sizeMpeg4ProfilesSupported)
		{
			a->Mpeg4ProfilesSupported = (enum tt__Mpeg4Profile *)soap_save_block(soap, soap_blist_Mpeg4ProfilesSupported, NULL, 1);
		}
		else
		{	
			a->Mpeg4ProfilesSupported = NULL;
			if (soap_blist_Mpeg4ProfilesSupported)
			{
				soap_end_block(soap, soap_blist_Mpeg4ProfilesSupported);
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__Mpeg4Options *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Options, 0, sizeof(struct tt__Mpeg4Options), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || soap_flag_GovLengthRange > 0 || soap_flag_FrameRateRange > 0 || soap_flag_EncodingIntervalRange > 0 || a->__sizeMpeg4ProfilesSupported < 1))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Mpeg4Options(struct soap *soap, const struct tt__Mpeg4Options *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Mpeg4Options);
	if (soap_out_tt__Mpeg4Options(soap, tag?tag:"tt:Mpeg4Options", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4Options * SOAP_FMAC4 soap_get_tt__Mpeg4Options(struct soap *soap, struct tt__Mpeg4Options *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Options(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__JpegOptions(struct soap *soap, struct tt__JpegOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->FrameRateRange = NULL;
	a->EncodingIntervalRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__JpegOptions(struct soap *soap, const struct tt__JpegOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ResolutionsAvailable != NULL)
	{	
		int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &a->EncodingIntervalRange);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__JpegOptions(struct soap *soap, const char *tag, int id, const struct tt__JpegOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__JpegOptions), type))
	{
		return soap->error;
	}
	if (a->ResolutionsAvailable != NULL)
	{	
		int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
		{
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
			{
				return soap->error;
			}
		}
	}
	if (a->FrameRateRange != NULL)
	{	
		if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->FrameRateRange, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:FrameRateRange"))
	{
		return soap->error;
	}
	if (a->EncodingIntervalRange != NULL)
	{	
		if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->EncodingIntervalRange, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:EncodingIntervalRange"))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__JpegOptions * SOAP_FMAC4 soap_in_tt__JpegOptions(struct soap *soap, const char *tag, struct tt__JpegOptions *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_FrameRateRange = 1;
	size_t soap_flag_EncodingIntervalRange = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__JpegOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__JpegOptions, sizeof(struct tt__JpegOptions), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__JpegOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	
				if (a->ResolutionsAvailable == NULL)
				{	
					if (soap_blist_ResolutionsAvailable == NULL)
					{
						soap_blist_ResolutionsAvailable = soap_new_block(soap);
					}
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
					{
						return NULL;
					}
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	
					a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->FrameRateRange, "tt:IntRange"))
				{	
					soap_flag_FrameRateRange--;
					continue;
				}
				if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->EncodingIntervalRange, "tt:IntRange"))
					{	
						soap_flag_EncodingIntervalRange--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH)
					{
						soap->error = soap_ignore_element(soap);
					}
					if (soap->error == SOAP_NO_TAG)
					{
						break;
					}
					if (soap->error)
					{
						return NULL;
					}
		}
		if (a->ResolutionsAvailable != NULL)
		{
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (a->__sizeResolutionsAvailable)
		{
			a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		}
		else
		{	
			a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
			{
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__JpegOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__JpegOptions, 0, sizeof(struct tt__JpegOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || soap_flag_FrameRateRange > 0 || soap_flag_EncodingIntervalRange > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__JpegOptions(struct soap *soap, const struct tt__JpegOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__JpegOptions);
	if (soap_out_tt__JpegOptions(soap, tag?tag:"tt:JpegOptions", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__JpegOptions * SOAP_FMAC4 soap_get_tt__JpegOptions(struct soap *soap, struct tt__JpegOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__JpegOptions(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

//device video
SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Transport(struct soap *soap, struct tt__Transport *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__TransportProtocol(soap, &a->Protocol);
	a->Tunnel = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Transport(struct soap *soap, const struct tt__Transport *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Transport(soap, &a->Tunnel);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Transport(struct soap *soap, const char *tag, int id, const struct tt__Transport *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Transport), type))
	{
		return soap->error;
	}
	if (soap_out_tt__TransportProtocol(soap, "tt:Protocol", -1, &a->Protocol, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__Transport(soap, "tt:Tunnel", -1, &a->Tunnel, ""))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Transport * SOAP_FMAC4 soap_in_tt__Transport(struct soap *soap, const char *tag, struct tt__Transport *a, const char *type)
{
	size_t soap_flag_Protocol = 1;
	size_t soap_flag_Tunnel = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__Transport *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Transport, sizeof(struct tt__Transport), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__Transport(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Protocol && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__TransportProtocol(soap, "tt:Protocol", &a->Protocol, "tt:TransportProtocol"))
				{	
					soap_flag_Protocol--;
					continue;
				}
				if (soap_flag_Tunnel && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__Transport(soap, "tt:Tunnel", &a->Tunnel, "tt:Transport"))
					{	
						soap_flag_Tunnel--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH)
					{
						soap->error = soap_ignore_element(soap);
					}
					if (soap->error == SOAP_NO_TAG)
					{
						break;
					}
					if (soap->error)
					{
						return NULL;
					}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__Transport *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Transport, 0, sizeof(struct tt__Transport), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Protocol > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Transport(struct soap *soap, const struct tt__Transport *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Transport);
	if (soap_out_tt__Transport(soap, tag?tag:"tt:Transport", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Transport * SOAP_FMAC4 soap_get_tt__Transport(struct soap *soap, struct tt__Transport *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Transport(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__StreamSetup(struct soap *soap, struct tt__StreamSetup *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__StreamSetup))
	{
		soap_serialize_tt__StreamSetup(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__StreamSetup(struct soap *soap, const char *tag, int id, struct tt__StreamSetup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__StreamSetup);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__StreamSetup(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__StreamSetup ** SOAP_FMAC4 soap_in_PointerTott__StreamSetup(struct soap *soap, const char *tag, struct tt__StreamSetup **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__StreamSetup **)soap_malloc(soap, sizeof(struct tt__StreamSetup *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__StreamSetup(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__StreamSetup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__StreamSetup, sizeof(struct tt__StreamSetup), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__StreamSetup(struct soap *soap, struct tt__StreamSetup *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__StreamSetup);
	if (soap_out_PointerTott__StreamSetup(soap, tag?tag:"tt:StreamSetup", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__StreamSetup ** SOAP_FMAC4 soap_get_PointerTott__StreamSetup(struct soap *soap, struct tt__StreamSetup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__StreamSetup(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__TransportProtocol(struct soap *soap, enum tt__TransportProtocol *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__TransportProtocol
	*a = SOAP_DEFAULT_tt__TransportProtocol;
#else
	*a = (enum tt__TransportProtocol)0;
#endif
}

static const struct soap_code_map soap_codes_tt__TransportProtocol[] =
{	
	{ (long)tt__TransportProtocol__UDP, "UDP" },
	{ (long)tt__TransportProtocol__TCP, "TCP" },
	{ (long)tt__TransportProtocol__RTSP, "RTSP" },
	{ (long)tt__TransportProtocol__HTTP, "HTTP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__TransportProtocol2s(struct soap *soap, enum tt__TransportProtocol n)
{	
	const char *s = soap_code_str(soap_codes_tt__TransportProtocol, (long)n);
	if (s != NULL)
	{
		return s;
	}
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TransportProtocol(struct soap *soap, const char *tag, int id, const enum tt__TransportProtocol *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TransportProtocol), type) || soap_send(soap, soap_tt__TransportProtocol2s(soap, *a)))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__TransportProtocol(struct soap *soap, const char *s, enum tt__TransportProtocol *a)
{
	const struct soap_code_map *map;
	if (s == NULL)
	{
		return soap->error;
	}
	map = soap_code(soap_codes_tt__TransportProtocol, s);
	if (map != NULL)
	{
		*a = (enum tt__TransportProtocol)map->code;
	}
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
		{
			return soap->error = SOAP_TYPE;
		}
		*a = (enum tt__TransportProtocol)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__TransportProtocol * SOAP_FMAC4 soap_in_tt__TransportProtocol(struct soap *soap, const char *tag, enum tt__TransportProtocol *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (enum tt__TransportProtocol *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TransportProtocol, sizeof(enum tt__TransportProtocol), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	
		if ((a == NULL) || soap_s2tt__TransportProtocol(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	a = (enum tt__TransportProtocol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TransportProtocol, 0, sizeof(enum tt__TransportProtocol), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
	{
		return NULL;
	}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TransportProtocol(struct soap *soap, const enum tt__TransportProtocol *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__TransportProtocol);
	if (soap_out_tt__TransportProtocol(soap, tag?tag:"tt:TransportProtocol", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__TransportProtocol * SOAP_FMAC4 soap_get_tt__TransportProtocol(struct soap *soap, enum tt__TransportProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TransportProtocol(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__StreamType(struct soap *soap, enum tt__StreamType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__StreamType
	*a = SOAP_DEFAULT_tt__StreamType;
#else
	*a = (enum tt__StreamType)0;
#endif
}

static const struct soap_code_map soap_codes_tt__StreamType[] =
{	
	{ (long)tt__StreamType__RTP_Unicast, "RTP-Unicast" },
	{ (long)tt__StreamType__RTP_Multicast, "RTP-Multicast" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__StreamType2s(struct soap *soap, enum tt__StreamType n)
{	
	const char *s = soap_code_str(soap_codes_tt__StreamType, (long)n);
	if (s != NULL)
	{
		return s;
	}
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StreamType(struct soap *soap, const char *tag, int id, const enum tt__StreamType *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__StreamType), type) || soap_send(soap, soap_tt__StreamType2s(soap, *a)))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__StreamType(struct soap *soap, const char *s, enum tt__StreamType *a)
{
	const struct soap_code_map *map;
	if (s == NULL)
	{
		return soap->error;
	}
	map = soap_code(soap_codes_tt__StreamType, s);
	if (map != NULL)
	{
		*a = (enum tt__StreamType)map->code;
	}
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
		{
			return soap->error = SOAP_TYPE;
		}
		*a = (enum tt__StreamType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__StreamType * SOAP_FMAC4 soap_in_tt__StreamType(struct soap *soap, const char *tag, enum tt__StreamType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	return NULL;
	a = (enum tt__StreamType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__StreamType, sizeof(enum tt__StreamType), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	
		if ((a== NULL)|| soap_s2tt__StreamType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (enum tt__StreamType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__StreamType, 0, sizeof(enum tt__StreamType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__StreamType(struct soap *soap, const enum tt__StreamType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__StreamType);
	if (soap_out_tt__StreamType(soap, tag?tag:"tt:StreamType", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__StreamType * SOAP_FMAC4 soap_get_tt__StreamType(struct soap *soap, enum tt__StreamType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StreamType(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetSnapshotUri(struct soap *soap, struct __trt__GetSnapshotUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetSnapshotUri = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetSnapshotUri(struct soap *soap, const struct __trt__GetSnapshotUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetSnapshotUri(soap, &a->trt__GetSnapshotUri);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetSnapshotUri(struct soap *soap, const char *tag, int id, const struct __trt__GetSnapshotUri *a, const char *type)
{
	if (soap_out_PointerTo_trt__GetSnapshotUri(soap, "trt:GetSnapshotUri", -1, &a->trt__GetSnapshotUri, ""))
	{
		return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetSnapshotUri * SOAP_FMAC4 soap_in___trt__GetSnapshotUri(struct soap *soap, const char *tag, struct __trt__GetSnapshotUri *a, const char *type)
{
	size_t soap_flag_trt__GetSnapshotUri = 1;
	short soap_flag;
	a = (struct __trt__GetSnapshotUri *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetSnapshotUri, sizeof(struct __trt__GetSnapshotUri), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default___trt__GetSnapshotUri(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_trt__GetSnapshotUri && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_trt__GetSnapshotUri(soap, "trt:GetSnapshotUri", &a->trt__GetSnapshotUri, ""))
			{	
				soap_flag_trt__GetSnapshotUri--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{
					return NULL;
				}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetSnapshotUri(struct soap *soap, const struct __trt__GetSnapshotUri *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetSnapshotUri(soap, tag?tag:"-trt:GetSnapshotUri", id, a, type))
	{
		return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetSnapshotUri * SOAP_FMAC4 soap_get___trt__GetSnapshotUri(struct soap *soap, struct __trt__GetSnapshotUri *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetSnapshotUri(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetSynchronizationPoint(struct soap *soap, struct __trt__SetSynchronizationPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetSynchronizationPoint = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetSynchronizationPoint(struct soap *soap, const struct __trt__SetSynchronizationPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__SetSynchronizationPoint(soap, &a->trt__SetSynchronizationPoint);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetSynchronizationPoint(struct soap *soap, const char *tag, int id, const struct __trt__SetSynchronizationPoint *a, const char *type)
{
	if (soap_out_PointerTo_trt__SetSynchronizationPoint(soap, "trt:SetSynchronizationPoint", -1, &a->trt__SetSynchronizationPoint, ""))
	{
		return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetSynchronizationPoint * SOAP_FMAC4 soap_in___trt__SetSynchronizationPoint(struct soap *soap, const char *tag, struct __trt__SetSynchronizationPoint *a, const char *type)
{
	size_t soap_flag_trt__SetSynchronizationPoint = 1;
	short soap_flag;
	a = (struct __trt__SetSynchronizationPoint *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetSynchronizationPoint, sizeof(struct __trt__SetSynchronizationPoint), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default___trt__SetSynchronizationPoint(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_trt__SetSynchronizationPoint && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_trt__SetSynchronizationPoint(soap, "trt:SetSynchronizationPoint", &a->trt__SetSynchronizationPoint, ""))
			{	
				soap_flag_trt__SetSynchronizationPoint--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{
					return NULL;
				}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetSynchronizationPoint(struct soap *soap, const struct __trt__SetSynchronizationPoint *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__SetSynchronizationPoint(soap, tag?tag:"-trt:SetSynchronizationPoint", id, a, type))
	{
		return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetSynchronizationPoint * SOAP_FMAC4 soap_get___trt__SetSynchronizationPoint(struct soap *soap, struct __trt__SetSynchronizationPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetSynchronizationPoint(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__StopMulticastStreaming(struct soap *soap, struct __trt__StopMulticastStreaming *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__StopMulticastStreaming = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__StopMulticastStreaming(struct soap *soap, const struct __trt__StopMulticastStreaming *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__StopMulticastStreaming(soap, &a->trt__StopMulticastStreaming);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__StopMulticastStreaming(struct soap *soap, const char *tag, int id, const struct __trt__StopMulticastStreaming *a, const char *type)
{
	if (soap_out_PointerTo_trt__StopMulticastStreaming(soap, "trt:StopMulticastStreaming", -1, &a->trt__StopMulticastStreaming, ""))
	{
		return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__StopMulticastStreaming * SOAP_FMAC4 soap_in___trt__StopMulticastStreaming(struct soap *soap, const char *tag, struct __trt__StopMulticastStreaming *a, const char *type)
{
	size_t soap_flag_trt__StopMulticastStreaming = 1;
	short soap_flag;
	a = (struct __trt__StopMulticastStreaming *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__StopMulticastStreaming, sizeof(struct __trt__StopMulticastStreaming), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default___trt__StopMulticastStreaming(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_trt__StopMulticastStreaming && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_trt__StopMulticastStreaming(soap, "trt:StopMulticastStreaming", &a->trt__StopMulticastStreaming, ""))
			{	
				soap_flag_trt__StopMulticastStreaming--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{
					return NULL;
				}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__StopMulticastStreaming(struct soap *soap, const struct __trt__StopMulticastStreaming *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__StopMulticastStreaming(soap, tag?tag:"-trt:StopMulticastStreaming", id, a, type))
	{
		return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__StopMulticastStreaming * SOAP_FMAC4 soap_get___trt__StopMulticastStreaming(struct soap *soap, struct __trt__StopMulticastStreaming *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__StopMulticastStreaming(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__StartMulticastStreaming(struct soap *soap, struct __trt__StartMulticastStreaming *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__StartMulticastStreaming = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__StartMulticastStreaming(struct soap *soap, const struct __trt__StartMulticastStreaming *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__StartMulticastStreaming(soap, &a->trt__StartMulticastStreaming);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__StartMulticastStreaming(struct soap *soap, const char *tag, int id, const struct __trt__StartMulticastStreaming *a, const char *type)
{
	if (soap_out_PointerTo_trt__StartMulticastStreaming(soap, "trt:StartMulticastStreaming", -1, &a->trt__StartMulticastStreaming, ""))
	{
		return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__StartMulticastStreaming * SOAP_FMAC4 soap_in___trt__StartMulticastStreaming(struct soap *soap, const char *tag, struct __trt__StartMulticastStreaming *a, const char *type)
{
	size_t soap_flag_trt__StartMulticastStreaming = 1;
	short soap_flag;
	a = (struct __trt__StartMulticastStreaming *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__StartMulticastStreaming, sizeof(struct __trt__StartMulticastStreaming), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default___trt__StartMulticastStreaming(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_trt__StartMulticastStreaming && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_trt__StartMulticastStreaming(soap, "trt:StartMulticastStreaming", &a->trt__StartMulticastStreaming, ""))
			{	
				soap_flag_trt__StartMulticastStreaming--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{
					return NULL;
				}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__StartMulticastStreaming(struct soap *soap, const struct __trt__StartMulticastStreaming *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__StartMulticastStreaming(soap, tag?tag:"-trt:StartMulticastStreaming", id, a, type))
	{
		return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__StartMulticastStreaming * SOAP_FMAC4 soap_get___trt__StartMulticastStreaming(struct soap *soap, struct __trt__StartMulticastStreaming *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__StartMulticastStreaming(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetStreamUri(struct soap *soap, struct __trt__GetStreamUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetStreamUri = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetStreamUri(struct soap *soap, const struct __trt__GetStreamUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetStreamUri(soap, &a->trt__GetStreamUri);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetStreamUri(struct soap *soap, const char *tag, int id, const struct __trt__GetStreamUri *a, const char *type)
{
	if (soap_out_PointerTo_trt__GetStreamUri(soap, "trt:GetStreamUri", -1, &a->trt__GetStreamUri, ""))
	{
		return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetStreamUri * SOAP_FMAC4 soap_in___trt__GetStreamUri(struct soap *soap, const char *tag, struct __trt__GetStreamUri *a, const char *type)
{
	size_t soap_flag_trt__GetStreamUri = 1;
	short soap_flag;
	a = (struct __trt__GetStreamUri *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetStreamUri, sizeof(struct __trt__GetStreamUri), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default___trt__GetStreamUri(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_trt__GetStreamUri && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_trt__GetStreamUri(soap, "trt:GetStreamUri", &a->trt__GetStreamUri, ""))
			{	
				soap_flag_trt__GetStreamUri--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{
					return NULL;
				}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetStreamUri(struct soap *soap, const struct __trt__GetStreamUri *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetStreamUri(soap, tag?tag:"-trt:GetStreamUri", id, a, type))
	{
		return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetStreamUri * SOAP_FMAC4 soap_get___trt__GetStreamUri(struct soap *soap, struct __trt__GetStreamUri *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetStreamUri(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetSnapshotUriResponse(struct soap *soap, struct _trt__GetSnapshotUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MediaUri = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetSnapshotUriResponse(struct soap *soap, const struct _trt__GetSnapshotUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__MediaUri(soap, &a->MediaUri);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetSnapshotUriResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetSnapshotUriResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetSnapshotUriResponse), type))
	{
		return soap->error;
	}
	if (a->MediaUri != NULL)
	{
		soap_element_result(soap, "trt:MediaUri");
	}
	if (a->MediaUri != NULL)
	{	
		if (soap_out_PointerTott__MediaUri(soap, "trt:MediaUri", -1, &a->MediaUri, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "trt:MediaUri"))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetSnapshotUriResponse * SOAP_FMAC4 soap_in__trt__GetSnapshotUriResponse(struct soap *soap, const char *tag, struct _trt__GetSnapshotUriResponse *a, const char *type)
{
	size_t soap_flag_MediaUri = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct _trt__GetSnapshotUriResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetSnapshotUriResponse, sizeof(struct _trt__GetSnapshotUriResponse), 0, NULL, NULL, NULL);
	if (a ==NULL)
	{
		return NULL;
	}
	soap_default__trt__GetSnapshotUriResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MediaUri && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MediaUri(soap, "trt:MediaUri", &a->MediaUri, "tt:MediaUri"))
				{	
					soap_flag_MediaUri--;
					continue;
				}
				soap_check_result(soap, "trt:MediaUri");
				if (soap->error == SOAP_TAG_MISMATCH)
				{
					soap->error = soap_ignore_element(soap);
				}
				if (soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{
					return NULL;
				}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{
		a = (struct _trt__GetSnapshotUriResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetSnapshotUriResponse, 0, sizeof(struct _trt__GetSnapshotUriResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MediaUri > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetSnapshotUriResponse(struct soap *soap, const struct _trt__GetSnapshotUriResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetSnapshotUriResponse);
	if (soap_out__trt__GetSnapshotUriResponse(soap, tag?tag:"trt:GetSnapshotUriResponse", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetSnapshotUriResponse * SOAP_FMAC4 soap_get__trt__GetSnapshotUriResponse(struct soap *soap, struct _trt__GetSnapshotUriResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetSnapshotUriResponse(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetSnapshotUri(struct soap *soap, struct _trt__GetSnapshotUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetSnapshotUri(struct soap *soap, const struct _trt__GetSnapshotUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetSnapshotUri(struct soap *soap, const char *tag, int id, const struct _trt__GetSnapshotUri *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetSnapshotUri), type))
	{
		return soap->error;
	}
	if (a->ProfileToken != NULL)
	{	
		if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetSnapshotUri * SOAP_FMAC4 soap_in__trt__GetSnapshotUri(struct soap *soap, const char *tag, struct _trt__GetSnapshotUri *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct _trt__GetSnapshotUri *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetSnapshotUri, sizeof(struct _trt__GetSnapshotUri), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default__trt__GetSnapshotUri(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	
					soap_flag_ProfileToken--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH)
				{
					soap->error = soap_ignore_element(soap);
				}
				if (soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{
					return NULL;
				}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__GetSnapshotUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetSnapshotUri, 0, sizeof(struct _trt__GetSnapshotUri), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetSnapshotUri(struct soap *soap, const struct _trt__GetSnapshotUri *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetSnapshotUri);
	if (soap_out__trt__GetSnapshotUri(soap, tag?tag:"trt:GetSnapshotUri", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetSnapshotUri * SOAP_FMAC4 soap_get__trt__GetSnapshotUri(struct soap *soap, struct _trt__GetSnapshotUri *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetSnapshotUri(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}

	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__SetSynchronizationPointResponse(struct soap *soap, struct _trt__SetSynchronizationPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__SetSynchronizationPointResponse(struct soap *soap, const struct _trt__SetSynchronizationPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__SetSynchronizationPointResponse(struct soap *soap, const char *tag, int id, const struct _trt__SetSynchronizationPointResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__SetSynchronizationPointResponse), type))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__SetSynchronizationPointResponse * SOAP_FMAC4 soap_in__trt__SetSynchronizationPointResponse(struct soap *soap, const char *tag, struct _trt__SetSynchronizationPointResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct _trt__SetSynchronizationPointResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetSynchronizationPointResponse, sizeof(struct _trt__SetSynchronizationPointResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default__trt__SetSynchronizationPointResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{
				soap->error = soap_ignore_element(soap);
			}
			if (soap->error == SOAP_NO_TAG)
			{
				break;
			}
			if (soap->error)
			{
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__SetSynchronizationPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetSynchronizationPointResponse, 0, sizeof(struct _trt__SetSynchronizationPointResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__SetSynchronizationPointResponse(struct soap *soap, const struct _trt__SetSynchronizationPointResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__SetSynchronizationPointResponse);
	if (soap_out__trt__SetSynchronizationPointResponse(soap, tag?tag:"trt:SetSynchronizationPointResponse", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetSynchronizationPointResponse * SOAP_FMAC4 soap_get__trt__SetSynchronizationPointResponse(struct soap *soap, struct _trt__SetSynchronizationPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__SetSynchronizationPointResponse(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__SetSynchronizationPoint(struct soap *soap, struct _trt__SetSynchronizationPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__SetSynchronizationPoint(struct soap *soap, const struct _trt__SetSynchronizationPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__SetSynchronizationPoint(struct soap *soap, const char *tag, int id, const struct _trt__SetSynchronizationPoint *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__SetSynchronizationPoint), type))
	{
		return soap->error;
	}
	if (a->ProfileToken != NULL) 
	{	
		if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__SetSynchronizationPoint * SOAP_FMAC4 soap_in__trt__SetSynchronizationPoint(struct soap *soap, const char *tag, struct _trt__SetSynchronizationPoint *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__SetSynchronizationPoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetSynchronizationPoint, sizeof(struct _trt__SetSynchronizationPoint), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default__trt__SetSynchronizationPoint(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	
					soap_flag_ProfileToken--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH)
				{
					soap->error = soap_ignore_element(soap);
				}
				if (soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{
					return NULL;
				}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__SetSynchronizationPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetSynchronizationPoint, 0, sizeof(struct _trt__SetSynchronizationPoint), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__SetSynchronizationPoint(struct soap *soap, const struct _trt__SetSynchronizationPoint *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__SetSynchronizationPoint);
	if (soap_out__trt__SetSynchronizationPoint(soap, tag?tag:"trt:SetSynchronizationPoint", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetSynchronizationPoint * SOAP_FMAC4 soap_get__trt__SetSynchronizationPoint(struct soap *soap, struct _trt__SetSynchronizationPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__SetSynchronizationPoint(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__StopMulticastStreamingResponse(struct soap *soap, struct _trt__StopMulticastStreamingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__StopMulticastStreamingResponse(struct soap *soap, const struct _trt__StopMulticastStreamingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__StopMulticastStreamingResponse(struct soap *soap, const char *tag, int id, const struct _trt__StopMulticastStreamingResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__StopMulticastStreamingResponse), type))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__StopMulticastStreamingResponse * SOAP_FMAC4 soap_in__trt__StopMulticastStreamingResponse(struct soap *soap, const char *tag, struct _trt__StopMulticastStreamingResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct _trt__StopMulticastStreamingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__StopMulticastStreamingResponse, sizeof(struct _trt__StopMulticastStreamingResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default__trt__StopMulticastStreamingResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{
				soap->error = soap_ignore_element(soap);
			}
			if (soap->error == SOAP_NO_TAG)
			{
				break;
			}
			if (soap->error)
			{
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__StopMulticastStreamingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__StopMulticastStreamingResponse, 0, sizeof(struct _trt__StopMulticastStreamingResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__StopMulticastStreamingResponse(struct soap *soap, const struct _trt__StopMulticastStreamingResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__StopMulticastStreamingResponse);
	if (soap_out__trt__StopMulticastStreamingResponse(soap, tag?tag:"trt:StopMulticastStreamingResponse", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__StopMulticastStreamingResponse * SOAP_FMAC4 soap_get__trt__StopMulticastStreamingResponse(struct soap *soap, struct _trt__StopMulticastStreamingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__StopMulticastStreamingResponse(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__StopMulticastStreaming(struct soap *soap, struct _trt__StopMulticastStreaming *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__StopMulticastStreaming(struct soap *soap, const struct _trt__StopMulticastStreaming *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__StopMulticastStreaming(struct soap *soap, const char *tag, int id, const struct _trt__StopMulticastStreaming *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__StopMulticastStreaming), type))
	{
		return soap->error;
	}
	if (a->ProfileToken != NULL)
	{	
		if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__StopMulticastStreaming * SOAP_FMAC4 soap_in__trt__StopMulticastStreaming(struct soap *soap, const char *tag, struct _trt__StopMulticastStreaming *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct _trt__StopMulticastStreaming *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__StopMulticastStreaming, sizeof(struct _trt__StopMulticastStreaming), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default__trt__StopMulticastStreaming(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	
					soap_flag_ProfileToken--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH)
				{
					soap->error = soap_ignore_element(soap);
				}
				if (soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{
					return NULL;
				}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__StopMulticastStreaming *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__StopMulticastStreaming, 0, sizeof(struct _trt__StopMulticastStreaming), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__StopMulticastStreaming(struct soap *soap, const struct _trt__StopMulticastStreaming *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__StopMulticastStreaming);
	if (soap_out__trt__StopMulticastStreaming(soap, tag?tag:"trt:StopMulticastStreaming", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__StopMulticastStreaming * SOAP_FMAC4 soap_get__trt__StopMulticastStreaming(struct soap *soap, struct _trt__StopMulticastStreaming *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__StopMulticastStreaming(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__StartMulticastStreamingResponse(struct soap *soap, struct _trt__StartMulticastStreamingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__StartMulticastStreamingResponse(struct soap *soap, const struct _trt__StartMulticastStreamingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__StartMulticastStreamingResponse(struct soap *soap, const char *tag, int id, const struct _trt__StartMulticastStreamingResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__StartMulticastStreamingResponse), type))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__StartMulticastStreamingResponse * SOAP_FMAC4 soap_in__trt__StartMulticastStreamingResponse(struct soap *soap, const char *tag, struct _trt__StartMulticastStreamingResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct _trt__StartMulticastStreamingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__StartMulticastStreamingResponse, sizeof(struct _trt__StartMulticastStreamingResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default__trt__StartMulticastStreamingResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{
				soap->error = soap_ignore_element(soap);
			}
			if (soap->error == SOAP_NO_TAG)
			{
				break;
			}
			if (soap->error)
			{
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__StartMulticastStreamingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__StartMulticastStreamingResponse, 0, sizeof(struct _trt__StartMulticastStreamingResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__StartMulticastStreamingResponse(struct soap *soap, const struct _trt__StartMulticastStreamingResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__StartMulticastStreamingResponse);
	if (soap_out__trt__StartMulticastStreamingResponse(soap, tag?tag:"trt:StartMulticastStreamingResponse", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__StartMulticastStreamingResponse * SOAP_FMAC4 soap_get__trt__StartMulticastStreamingResponse(struct soap *soap, struct _trt__StartMulticastStreamingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__StartMulticastStreamingResponse(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__StartMulticastStreaming(struct soap *soap, struct _trt__StartMulticastStreaming *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__StartMulticastStreaming(struct soap *soap, const struct _trt__StartMulticastStreaming *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__StartMulticastStreaming(struct soap *soap, const char *tag, int id, const struct _trt__StartMulticastStreaming *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__StartMulticastStreaming), type))
	{
		return soap->error;
	}
	if (a->ProfileToken != NULL)
	{
		if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__StartMulticastStreaming * SOAP_FMAC4 soap_in__trt__StartMulticastStreaming(struct soap *soap, const char *tag, struct _trt__StartMulticastStreaming *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct _trt__StartMulticastStreaming *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__StartMulticastStreaming, sizeof(struct _trt__StartMulticastStreaming), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default__trt__StartMulticastStreaming(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	
					soap_flag_ProfileToken--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH)
				{
					soap->error = soap_ignore_element(soap);
				}
				if (soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{
					return NULL;
				}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
		a = (struct _trt__StartMulticastStreaming *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__StartMulticastStreaming, 0, sizeof(struct _trt__StartMulticastStreaming), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__StartMulticastStreaming(struct soap *soap, const struct _trt__StartMulticastStreaming *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__StartMulticastStreaming);
	if (soap_out__trt__StartMulticastStreaming(soap, tag?tag:"trt:StartMulticastStreaming", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__StartMulticastStreaming * SOAP_FMAC4 soap_get__trt__StartMulticastStreaming(struct soap *soap, struct _trt__StartMulticastStreaming *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__StartMulticastStreaming(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MediaUri(struct soap *soap, struct tt__MediaUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Uri);
	soap_default_xsd__boolean_(soap, &a->InvalidAfterConnect);
	soap_default_xsd__boolean_(soap, &a->InvalidAfterReboot);
	soap_default_string(soap, &a->Timeout);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MediaUri(struct soap *soap, const struct tt__MediaUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Uri);
	soap_embedded(soap, &a->InvalidAfterConnect, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->InvalidAfterReboot, SOAP_TYPE_xsd__boolean_);
	soap_serialize_string(soap, &a->Timeout);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MediaUri(struct soap *soap, const char *tag, int id, const struct tt__MediaUri *a, const char *type)
{
	if (a->__anyAttribute != NULL)
	{
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	}
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MediaUri), type))
	{
		return soap->error;
	}
	if (a->Uri != NULL)
	{	
		if (soap_out_string(soap, "tt:Uri", -1, &a->Uri, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:Uri"))
	{
		return soap->error;
	}
	if (soap_out_xsd__boolean_(soap, "tt:InvalidAfterConnect", -1, &a->InvalidAfterConnect, ""))
	{
		return soap->error;
	}
	if (soap_out_xsd__boolean_(soap, "tt:InvalidAfterReboot", -1, &a->InvalidAfterReboot, ""))
	{
		return soap->error;
	}
	if (a->Timeout != NULL)
	{	
		if (soap_out_string(soap, "tt:Timeout", -1, &a->Timeout, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:Timeout"))
	{
		return soap->error;
	}
	if (a->__any != NULL)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_outliteral(soap, "-any", a->__any + i, NULL);
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MediaUri * SOAP_FMAC4 soap_in_tt__MediaUri(struct soap *soap, const char *tag, struct tt__MediaUri *a, const char *type)
{
	size_t soap_flag_Uri = 1;
	size_t soap_flag_InvalidAfterConnect = 1;
	size_t soap_flag_InvalidAfterReboot = 1;
	size_t soap_flag_Timeout = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__MediaUri *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaUri, sizeof(struct tt__MediaUri), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__MediaUri(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Uri", &a->Uri, "xsd:string"))
				{	
					soap_flag_Uri--;
					continue;
				}
				if (soap_flag_InvalidAfterConnect && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_xsd__boolean_(soap, "tt:InvalidAfterConnect", &a->InvalidAfterConnect, "xsd:boolean"))
					{	
						soap_flag_InvalidAfterConnect--;
						continue;
					}
					if (soap_flag_InvalidAfterReboot && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_xsd__boolean_(soap, "tt:InvalidAfterReboot", &a->InvalidAfterReboot, "xsd:boolean"))
						{	
							soap_flag_InvalidAfterReboot--;
							continue;
						}
						if (soap_flag_Timeout && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
							if (soap_in_string(soap, "tt:Timeout", &a->Timeout, "xsd:string"))
							{	
								soap_flag_Timeout--;
								continue;
							}
							if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
							{	
								if (a->__any == NULL)
								{	
									if (soap_blist___any == NULL)
									{
										soap_blist___any = soap_new_block(soap);
									}
									a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
									if (a->__any == NULL)
										return NULL;
									*a->__any = NULL;
								}
								if (soap_inliteral(soap, "-any", a->__any))
								{	
									a->__size++;
									a->__any = NULL;
									continue;
								}
							}
							if (soap->error == SOAP_TAG_MISMATCH)
							{
								soap->error = soap_ignore_element(soap);
							}
							if (soap->error == SOAP_NO_TAG)
							{
								break;
							}
							if (soap->error)
							{
								return NULL;
							}
		}
		if (a->__any != NULL)
		{
			soap_pop_block(soap, soap_blist___any);
		}
		if (a->__size)
		{
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
			{
				soap_end_block(soap, soap_blist___any);
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__MediaUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaUri, 0, sizeof(struct tt__MediaUri), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Uri > 0 || soap_flag_InvalidAfterConnect > 0 || soap_flag_InvalidAfterReboot > 0 || soap_flag_Timeout > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MediaUri(struct soap *soap, const struct tt__MediaUri *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__MediaUri);
	if (soap_out_tt__MediaUri(soap, tag?tag:"tt:MediaUri", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaUri * SOAP_FMAC4 soap_get_tt__MediaUri(struct soap *soap, struct tt__MediaUri *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MediaUri(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetStreamUriResponse(struct soap *soap, struct _trt__GetStreamUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MediaUri = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetStreamUriResponse(struct soap *soap, const struct _trt__GetStreamUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__MediaUri(soap, &a->MediaUri);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetStreamUriResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetStreamUriResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetStreamUriResponse), type))
	{
		return soap->error;
	}
	if (a->MediaUri != NULL)
	{
		soap_element_result(soap, "trt:MediaUri");
	}
	if (a->MediaUri != NULL)
	{	
		if (soap_out_PointerTott__MediaUri(soap, "trt:MediaUri", -1, &a->MediaUri, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "trt:MediaUri"))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetStreamUriResponse * SOAP_FMAC4 soap_in__trt__GetStreamUriResponse(struct soap *soap, const char *tag, struct _trt__GetStreamUriResponse *a, const char *type)
{
	size_t soap_flag_MediaUri = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct _trt__GetStreamUriResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetStreamUriResponse, sizeof(struct _trt__GetStreamUriResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default__trt__GetStreamUriResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MediaUri && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MediaUri(soap, "trt:MediaUri", &a->MediaUri, "tt:MediaUri"))
				{	
					soap_flag_MediaUri--;
					continue;
				}
				soap_check_result(soap, "trt:MediaUri");
				if (soap->error == SOAP_TAG_MISMATCH)
				{
					soap->error = soap_ignore_element(soap);
				}
				if (soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{
					return NULL;
				}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__GetStreamUriResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetStreamUriResponse, 0, sizeof(struct _trt__GetStreamUriResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MediaUri > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetStreamUriResponse(struct soap *soap, const struct _trt__GetStreamUriResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetStreamUriResponse);
	if (soap_out__trt__GetStreamUriResponse(soap, tag?tag:"trt:GetStreamUriResponse", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetStreamUriResponse * SOAP_FMAC4 soap_get__trt__GetStreamUriResponse(struct soap *soap, struct _trt__GetStreamUriResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetStreamUriResponse(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__StreamSetup(struct soap *soap, struct tt__StreamSetup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__StreamType(soap, &a->Stream);
	a->Transport = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__StreamSetup(struct soap *soap, const struct tt__StreamSetup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Transport(soap, &a->Transport);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StreamSetup(struct soap *soap, const char *tag, int id, const struct tt__StreamSetup *a, const char *type)
{
	if (a->__anyAttribute != NULL)
	{
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	}
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__StreamSetup), type))
	{
		return soap->error;
	}
	if (soap_out_tt__StreamType(soap, "tt:Stream", -1, &a->Stream, ""))
	{
		return soap->error;
	}
	if (a->Transport != NULL)
	{	
		if (soap_out_PointerTott__Transport(soap, "tt:Transport", -1, &a->Transport, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:Transport"))
	{
		return soap->error;
	}
	if (a->__any != NULL)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_outliteral(soap, "-any", a->__any + i, NULL);
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__StreamSetup * SOAP_FMAC4 soap_in_tt__StreamSetup(struct soap *soap, const char *tag, struct tt__StreamSetup *a, const char *type)
{
	size_t soap_flag_Stream = 1;
	size_t soap_flag_Transport = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__StreamSetup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__StreamSetup, sizeof(struct tt__StreamSetup), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__StreamSetup(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Stream && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__StreamType(soap, "tt:Stream", &a->Stream, "tt:StreamType"))
				{	
					soap_flag_Stream--;
					continue;
				}
				if (soap_flag_Transport && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__Transport(soap, "tt:Transport", &a->Transport, "tt:Transport"))
					{	
						soap_flag_Transport--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
					{	
						if (a->__any == NULL)
						{	
							if (soap_blist___any == NULL)
							{
								soap_blist___any = soap_new_block(soap);
							}
							a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
							if (a->__any == NULL)
							{
								return NULL;
							}
							*a->__any = NULL;
						}
						if (soap_inliteral(soap, "-any", a->__any))
						{	
							a->__size++;
							a->__any = NULL;
							continue;
						}
					}
					if (soap->error == SOAP_TAG_MISMATCH)
					{
						soap->error = soap_ignore_element(soap);
					}
					if (soap->error == SOAP_NO_TAG)
					{
						break;
					}
					if (soap->error)
					{
						return NULL;
					}
		}
		if (a->__any != NULL)
		{
			soap_pop_block(soap, soap_blist___any);
		}
		if (a->__size)
		{
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
			{
				soap_end_block(soap, soap_blist___any);
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__StreamSetup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__StreamSetup, 0, sizeof(struct tt__StreamSetup), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Stream > 0 || soap_flag_Transport > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__StreamSetup(struct soap *soap, const struct tt__StreamSetup *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__StreamSetup);
	if (soap_out_tt__StreamSetup(soap, tag?tag:"tt:StreamSetup", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__StreamSetup * SOAP_FMAC4 soap_get_tt__StreamSetup(struct soap *soap, struct tt__StreamSetup *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StreamSetup(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetStreamUri(struct soap *soap, struct _trt__GetStreamUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->StreamSetup = NULL;
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetStreamUri(struct soap *soap, const struct _trt__GetStreamUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__StreamSetup(soap, &a->StreamSetup);
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetStreamUri(struct soap *soap, const char *tag, int id, const struct _trt__GetStreamUri *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetStreamUri), type))
	{
		return soap->error;
	}
	if (a->StreamSetup != NULL)
	{	
		if (soap_out_PointerTott__StreamSetup(soap, "trt:StreamSetup", -1, &a->StreamSetup, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "trt:StreamSetup"))
	{
		return soap->error;
	}
	if (a->ProfileToken != NULL)
	{	
		if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetStreamUri * SOAP_FMAC4 soap_in__trt__GetStreamUri(struct soap *soap, const char *tag, struct _trt__GetStreamUri *a, const char *type)
{
	size_t soap_flag_StreamSetup = 1;
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct _trt__GetStreamUri *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetStreamUri, sizeof(struct _trt__GetStreamUri), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default__trt__GetStreamUri(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StreamSetup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__StreamSetup(soap, "trt:StreamSetup", &a->StreamSetup, "tt:StreamSetup"))
				{	
					soap_flag_StreamSetup--;
					continue;
				}
				if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
					if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
					{	
						soap_flag_ProfileToken--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH)
					{
						soap->error = soap_ignore_element(soap);
					}
					if (soap->error == SOAP_NO_TAG)
					{
						break;
					}
					if (soap->error)
					{
						return NULL;
					}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__GetStreamUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetStreamUri, 0, sizeof(struct _trt__GetStreamUri), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StreamSetup > 0 || soap_flag_ProfileToken > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetStreamUri(struct soap *soap, const struct _trt__GetStreamUri *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetStreamUri);
	if (soap_out__trt__GetStreamUri(soap, tag?tag:"trt:GetStreamUri", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetStreamUri * SOAP_FMAC4 soap_get__trt__GetStreamUri(struct soap *soap, struct _trt__GetStreamUri *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetStreamUri(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, struct _trt__GetSnapshotUriResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetSnapshotUriResponse))
	{
		soap_serialize__trt__GetSnapshotUriResponse(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, const char *tag, int id, struct _trt__GetSnapshotUriResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetSnapshotUriResponse);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out__trt__GetSnapshotUriResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetSnapshotUriResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, const char *tag, struct _trt__GetSnapshotUriResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct _trt__GetSnapshotUriResponse **)soap_malloc(soap, sizeof(struct _trt__GetSnapshotUriResponse *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in__trt__GetSnapshotUriResponse(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__GetSnapshotUriResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetSnapshotUriResponse, sizeof(struct _trt__GetSnapshotUriResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, struct _trt__GetSnapshotUriResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetSnapshotUriResponse);
	if (soap_out_PointerTo_trt__GetSnapshotUriResponse(soap, tag?tag:"trt:GetSnapshotUriResponse", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetSnapshotUriResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, struct _trt__GetSnapshotUriResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetSnapshotUriResponse(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetSnapshotUri(struct soap *soap, struct _trt__GetSnapshotUri *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetSnapshotUri))
	{
		soap_serialize__trt__GetSnapshotUri(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetSnapshotUri(struct soap *soap, const char *tag, int id, struct _trt__GetSnapshotUri *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetSnapshotUri);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out__trt__GetSnapshotUri(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetSnapshotUri ** SOAP_FMAC4 soap_in_PointerTo_trt__GetSnapshotUri(struct soap *soap, const char *tag, struct _trt__GetSnapshotUri **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct _trt__GetSnapshotUri **)soap_malloc(soap, sizeof(struct _trt__GetSnapshotUri *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in__trt__GetSnapshotUri(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__GetSnapshotUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetSnapshotUri, sizeof(struct _trt__GetSnapshotUri), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetSnapshotUri(struct soap *soap, struct _trt__GetSnapshotUri *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetSnapshotUri);
	if (soap_out_PointerTo_trt__GetSnapshotUri(soap, tag?tag:"trt:GetSnapshotUri", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetSnapshotUri ** SOAP_FMAC4 soap_get_PointerTo_trt__GetSnapshotUri(struct soap *soap, struct _trt__GetSnapshotUri **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetSnapshotUri(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetSynchronizationPointResponse(struct soap *soap, struct _trt__SetSynchronizationPointResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetSynchronizationPointResponse))
	{
		soap_serialize__trt__SetSynchronizationPointResponse(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetSynchronizationPointResponse(struct soap *soap, const char *tag, int id, struct _trt__SetSynchronizationPointResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetSynchronizationPointResponse);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out__trt__SetSynchronizationPointResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetSynchronizationPointResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetSynchronizationPointResponse(struct soap *soap, const char *tag, struct _trt__SetSynchronizationPointResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct _trt__SetSynchronizationPointResponse **)soap_malloc(soap, sizeof(struct _trt__SetSynchronizationPointResponse *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in__trt__SetSynchronizationPointResponse(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__SetSynchronizationPointResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetSynchronizationPointResponse, sizeof(struct _trt__SetSynchronizationPointResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetSynchronizationPointResponse(struct soap *soap, struct _trt__SetSynchronizationPointResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetSynchronizationPointResponse);
	if (soap_out_PointerTo_trt__SetSynchronizationPointResponse(soap, tag?tag:"trt:SetSynchronizationPointResponse", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetSynchronizationPointResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetSynchronizationPointResponse(struct soap *soap, struct _trt__SetSynchronizationPointResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetSynchronizationPointResponse(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetSynchronizationPoint(struct soap *soap, struct _trt__SetSynchronizationPoint *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetSynchronizationPoint))
	{
		soap_serialize__trt__SetSynchronizationPoint(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetSynchronizationPoint(struct soap *soap, const char *tag, int id, struct _trt__SetSynchronizationPoint *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetSynchronizationPoint);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out__trt__SetSynchronizationPoint(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetSynchronizationPoint ** SOAP_FMAC4 soap_in_PointerTo_trt__SetSynchronizationPoint(struct soap *soap, const char *tag, struct _trt__SetSynchronizationPoint **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct _trt__SetSynchronizationPoint **)soap_malloc(soap, sizeof(struct _trt__SetSynchronizationPoint *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in__trt__SetSynchronizationPoint(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__SetSynchronizationPoint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetSynchronizationPoint, sizeof(struct _trt__SetSynchronizationPoint), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetSynchronizationPoint(struct soap *soap, struct _trt__SetSynchronizationPoint *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetSynchronizationPoint);
	if (soap_out_PointerTo_trt__SetSynchronizationPoint(soap, tag?tag:"trt:SetSynchronizationPoint", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetSynchronizationPoint ** SOAP_FMAC4 soap_get_PointerTo_trt__SetSynchronizationPoint(struct soap *soap, struct _trt__SetSynchronizationPoint **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetSynchronizationPoint(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__StopMulticastStreamingResponse(struct soap *soap, struct _trt__StopMulticastStreamingResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__StopMulticastStreamingResponse))
	{
		soap_serialize__trt__StopMulticastStreamingResponse(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__StopMulticastStreamingResponse(struct soap *soap, const char *tag, int id, struct _trt__StopMulticastStreamingResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__StopMulticastStreamingResponse);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out__trt__StopMulticastStreamingResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__StopMulticastStreamingResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__StopMulticastStreamingResponse(struct soap *soap, const char *tag, struct _trt__StopMulticastStreamingResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct _trt__StopMulticastStreamingResponse **)soap_malloc(soap, sizeof(struct _trt__StopMulticastStreamingResponse *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in__trt__StopMulticastStreamingResponse(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__StopMulticastStreamingResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__StopMulticastStreamingResponse, sizeof(struct _trt__StopMulticastStreamingResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__StopMulticastStreamingResponse(struct soap *soap, struct _trt__StopMulticastStreamingResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__StopMulticastStreamingResponse);
	if (soap_out_PointerTo_trt__StopMulticastStreamingResponse(soap, tag?tag:"trt:StopMulticastStreamingResponse", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__StopMulticastStreamingResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__StopMulticastStreamingResponse(struct soap *soap, struct _trt__StopMulticastStreamingResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__StopMulticastStreamingResponse(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__StopMulticastStreaming(struct soap *soap, struct _trt__StopMulticastStreaming *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__StopMulticastStreaming))
	{
		soap_serialize__trt__StopMulticastStreaming(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__StopMulticastStreaming(struct soap *soap, const char *tag, int id, struct _trt__StopMulticastStreaming *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__StopMulticastStreaming);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out__trt__StopMulticastStreaming(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__StopMulticastStreaming ** SOAP_FMAC4 soap_in_PointerTo_trt__StopMulticastStreaming(struct soap *soap, const char *tag, struct _trt__StopMulticastStreaming **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct _trt__StopMulticastStreaming **)soap_malloc(soap, sizeof(struct _trt__StopMulticastStreaming *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in__trt__StopMulticastStreaming(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__StopMulticastStreaming **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__StopMulticastStreaming, sizeof(struct _trt__StopMulticastStreaming), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__StopMulticastStreaming(struct soap *soap, struct _trt__StopMulticastStreaming *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__StopMulticastStreaming);
	if (soap_out_PointerTo_trt__StopMulticastStreaming(soap, tag?tag:"trt:StopMulticastStreaming", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__StopMulticastStreaming ** SOAP_FMAC4 soap_get_PointerTo_trt__StopMulticastStreaming(struct soap *soap, struct _trt__StopMulticastStreaming **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__StopMulticastStreaming(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__StartMulticastStreamingResponse(struct soap *soap, struct _trt__StartMulticastStreamingResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__StartMulticastStreamingResponse))
	{
		soap_serialize__trt__StartMulticastStreamingResponse(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__StartMulticastStreamingResponse(struct soap *soap, const char *tag, int id, struct _trt__StartMulticastStreamingResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__StartMulticastStreamingResponse);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out__trt__StartMulticastStreamingResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__StartMulticastStreamingResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__StartMulticastStreamingResponse(struct soap *soap, const char *tag, struct _trt__StartMulticastStreamingResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct _trt__StartMulticastStreamingResponse **)soap_malloc(soap, sizeof(struct _trt__StartMulticastStreamingResponse *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in__trt__StartMulticastStreamingResponse(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__StartMulticastStreamingResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__StartMulticastStreamingResponse, sizeof(struct _trt__StartMulticastStreamingResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__StartMulticastStreamingResponse(struct soap *soap, struct _trt__StartMulticastStreamingResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__StartMulticastStreamingResponse);
	if (soap_out_PointerTo_trt__StartMulticastStreamingResponse(soap, tag?tag:"trt:StartMulticastStreamingResponse", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__StartMulticastStreamingResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__StartMulticastStreamingResponse(struct soap *soap, struct _trt__StartMulticastStreamingResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__StartMulticastStreamingResponse(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__StartMulticastStreaming(struct soap *soap, struct _trt__StartMulticastStreaming *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__StartMulticastStreaming))
	{
		soap_serialize__trt__StartMulticastStreaming(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__StartMulticastStreaming(struct soap *soap, const char *tag, int id, struct _trt__StartMulticastStreaming *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__StartMulticastStreaming);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out__trt__StartMulticastStreaming(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__StartMulticastStreaming ** SOAP_FMAC4 soap_in_PointerTo_trt__StartMulticastStreaming(struct soap *soap, const char *tag, struct _trt__StartMulticastStreaming **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct _trt__StartMulticastStreaming **)soap_malloc(soap, sizeof(struct _trt__StartMulticastStreaming *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (!(*a = soap_in__trt__StartMulticastStreaming(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__StartMulticastStreaming **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__StartMulticastStreaming, sizeof(struct _trt__StartMulticastStreaming), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__StartMulticastStreaming(struct soap *soap, struct _trt__StartMulticastStreaming *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__StartMulticastStreaming);
	if (soap_out_PointerTo_trt__StartMulticastStreaming(soap, tag?tag:"trt:StartMulticastStreaming", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__StartMulticastStreaming ** SOAP_FMAC4 soap_get_PointerTo_trt__StartMulticastStreaming(struct soap *soap, struct _trt__StartMulticastStreaming **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__StartMulticastStreaming(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetStreamUriResponse(struct soap *soap, struct _trt__GetStreamUriResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetStreamUriResponse))
	{
		soap_serialize__trt__GetStreamUriResponse(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetStreamUriResponse(struct soap *soap, const char *tag, int id, struct _trt__GetStreamUriResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetStreamUriResponse);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out__trt__GetStreamUriResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetStreamUriResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetStreamUriResponse(struct soap *soap, const char *tag, struct _trt__GetStreamUriResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct _trt__GetStreamUriResponse **)soap_malloc(soap, sizeof(struct _trt__GetStreamUriResponse *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in__trt__GetStreamUriResponse(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__GetStreamUriResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetStreamUriResponse, sizeof(struct _trt__GetStreamUriResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetStreamUriResponse(struct soap *soap, struct _trt__GetStreamUriResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetStreamUriResponse);
	if (soap_out_PointerTo_trt__GetStreamUriResponse(soap, tag?tag:"trt:GetStreamUriResponse", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetStreamUriResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetStreamUriResponse(struct soap *soap, struct _trt__GetStreamUriResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetStreamUriResponse(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetStreamUri(struct soap *soap, struct _trt__GetStreamUri *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetStreamUri))
	{
		soap_serialize__trt__GetStreamUri(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetStreamUri(struct soap *soap, const char *tag, int id, struct _trt__GetStreamUri *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetStreamUri);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out__trt__GetStreamUri(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetStreamUri ** SOAP_FMAC4 soap_in_PointerTo_trt__GetStreamUri(struct soap *soap, const char *tag, struct _trt__GetStreamUri **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct _trt__GetStreamUri **)soap_malloc(soap, sizeof(struct _trt__GetStreamUri *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in__trt__GetStreamUri(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _trt__GetStreamUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetStreamUri, sizeof(struct _trt__GetStreamUri), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetStreamUri(struct soap *soap, struct _trt__GetStreamUri *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetStreamUri);
	if (soap_out_PointerTo_trt__GetStreamUri(soap, tag?tag:"trt:GetStreamUri", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetStreamUri ** SOAP_FMAC4 soap_get_PointerTo_trt__GetStreamUri(struct soap *soap, struct _trt__GetStreamUri **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetStreamUri(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Transport(struct soap *soap, struct tt__Transport *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Transport))
	{
		soap_serialize_tt__Transport(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Transport(struct soap *soap, const char *tag, int id, struct tt__Transport *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Transport);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__Transport(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Transport ** SOAP_FMAC4 soap_in_PointerTott__Transport(struct soap *soap, const char *tag, struct tt__Transport **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__Transport **)soap_malloc(soap, sizeof(struct tt__Transport *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__Transport(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__Transport **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Transport, sizeof(struct tt__Transport), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Transport(struct soap *soap, struct tt__Transport *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Transport);
	if (soap_out_PointerTott__Transport(soap, tag?tag:"tt:Transport", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Transport ** SOAP_FMAC4 soap_get_PointerTott__Transport(struct soap *soap, struct tt__Transport **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Transport(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MediaUri(struct soap *soap, struct tt__MediaUri *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MediaUri))
	{
		soap_serialize_tt__MediaUri(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MediaUri(struct soap *soap, const char *tag, int id, struct tt__MediaUri *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MediaUri);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__MediaUri(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MediaUri ** SOAP_FMAC4 soap_in_PointerTott__MediaUri(struct soap *soap, const char *tag, struct tt__MediaUri **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__MediaUri **)soap_malloc(soap, sizeof(struct tt__MediaUri *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__MediaUri(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__MediaUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MediaUri, sizeof(struct tt__MediaUri), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MediaUri(struct soap *soap, struct tt__MediaUri *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MediaUri);
	if (soap_out_PointerTott__MediaUri(soap, tag?tag:"tt:MediaUri", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaUri ** SOAP_FMAC4 soap_get_PointerTott__MediaUri(struct soap *soap, struct tt__MediaUri **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MediaUri(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

//device control
SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__GetImagingSettings(struct soap *soap, struct __timg__GetImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__GetImagingSettings = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__GetImagingSettings(struct soap *soap, const struct __timg__GetImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_timg__GetImagingSettings(soap, &a->timg__GetImagingSettings);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__GetImagingSettings(struct soap *soap, const char *tag, int id, const struct __timg__GetImagingSettings *a, const char *type)
{
	if (soap_out_PointerTo_timg__GetImagingSettings(soap, "timg:GetImagingSettings", -1, &a->timg__GetImagingSettings, ""))
	{
		return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetImagingSettings * SOAP_FMAC4 soap_in___timg__GetImagingSettings(struct soap *soap, const char *tag, struct __timg__GetImagingSettings *a, const char *type)
{
	size_t soap_flag_timg__GetImagingSettings = 1;
	short soap_flag;
	a = (struct __timg__GetImagingSettings *)soap_id_enter(soap, "", a, SOAP_TYPE___timg__GetImagingSettings, sizeof(struct __timg__GetImagingSettings), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default___timg__GetImagingSettings(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_timg__GetImagingSettings && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_timg__GetImagingSettings(soap, "timg:GetImagingSettings", &a->timg__GetImagingSettings, ""))
			{	
				soap_flag_timg__GetImagingSettings--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{
					return NULL;
				}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__GetImagingSettings(struct soap *soap, const struct __timg__GetImagingSettings *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___timg__GetImagingSettings(soap, tag?tag:"-timg:GetImagingSettings", id, a, type))
	{
		return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetImagingSettings * SOAP_FMAC4 soap_get___timg__GetImagingSettings(struct soap *soap, struct __timg__GetImagingSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__GetImagingSettings(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetImagingSettings(struct soap *soap, struct _timg__GetImagingSettings *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetImagingSettings))
	{
		soap_serialize__timg__GetImagingSettings(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetImagingSettings(struct soap *soap, const char *tag, int id, struct _timg__GetImagingSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetImagingSettings);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out__timg__GetImagingSettings(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__GetImagingSettings ** SOAP_FMAC4 soap_in_PointerTo_timg__GetImagingSettings(struct soap *soap, const char *tag, struct _timg__GetImagingSettings **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct _timg__GetImagingSettings **)soap_malloc(soap, sizeof(struct _timg__GetImagingSettings *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in__timg__GetImagingSettings(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _timg__GetImagingSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetImagingSettings, sizeof(struct _timg__GetImagingSettings), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetImagingSettings(struct soap *soap, struct _timg__GetImagingSettings *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetImagingSettings);
	if (soap_out_PointerTo_timg__GetImagingSettings(soap, tag?tag:"timg:GetImagingSettings", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetImagingSettings ** SOAP_FMAC4 soap_get_PointerTo_timg__GetImagingSettings(struct soap *soap, struct _timg__GetImagingSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetImagingSettings(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetImagingSettings(struct soap *soap, struct _timg__GetImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetImagingSettings(struct soap *soap, const struct _timg__GetImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->VideoSourceToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetImagingSettings(struct soap *soap, const char *tag, int id, const struct _timg__GetImagingSettings *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetImagingSettings), type))
	{
		return soap->error;
	}
	if (a->VideoSourceToken != NULL)
	{	
		if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, &a->VideoSourceToken, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "timg:VideoSourceToken"))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetImagingSettings * SOAP_FMAC4 soap_in__timg__GetImagingSettings(struct soap *soap, const char *tag, struct _timg__GetImagingSettings *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct _timg__GetImagingSettings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetImagingSettings, sizeof(struct _timg__GetImagingSettings), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default__timg__GetImagingSettings(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", &a->VideoSourceToken, "tt:ReferenceToken"))
				{	
					soap_flag_VideoSourceToken--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH)
				{
					soap->error = soap_ignore_element(soap);
				}
				if (soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{
					return NULL;
				}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _timg__GetImagingSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetImagingSettings, 0, sizeof(struct _timg__GetImagingSettings), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetImagingSettings(struct soap *soap, const struct _timg__GetImagingSettings *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__GetImagingSettings);
	if (soap_out__timg__GetImagingSettings(soap, tag?tag:"timg:GetImagingSettings", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetImagingSettings * SOAP_FMAC4 soap_get__timg__GetImagingSettings(struct soap *soap, struct _timg__GetImagingSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetImagingSettings(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetImagingSettingsResponse(struct soap *soap, struct _timg__GetImagingSettingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ImagingSettings = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetImagingSettingsResponse(struct soap *soap, const struct _timg__GetImagingSettingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ImagingSettings20(soap, &a->ImagingSettings);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetImagingSettingsResponse(struct soap *soap, const char *tag, int id, const struct _timg__GetImagingSettingsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetImagingSettingsResponse), type))
	{
		return soap->error;
	}
	if (a->ImagingSettings != NULL) 
	{
		soap_element_result(soap, "timg:ImagingSettings");
	}
	if (a->ImagingSettings != NULL)
	{	
		if (soap_out_PointerTott__ImagingSettings20(soap, "timg:ImagingSettings", -1, &a->ImagingSettings, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "timg:ImagingSettings"))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetImagingSettingsResponse * SOAP_FMAC4 soap_in__timg__GetImagingSettingsResponse(struct soap *soap, const char *tag, struct _timg__GetImagingSettingsResponse *a, const char *type)
{
	size_t soap_flag_ImagingSettings = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct _timg__GetImagingSettingsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetImagingSettingsResponse, sizeof(struct _timg__GetImagingSettingsResponse), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default__timg__GetImagingSettingsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ImagingSettings && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingSettings20(soap, "timg:ImagingSettings", &a->ImagingSettings, "tt:ImagingSettings20"))
				{	
					soap_flag_ImagingSettings--;
					continue;
				}
				soap_check_result(soap, "timg:ImagingSettings");
				if (soap->error == SOAP_TAG_MISMATCH)
				{
					soap->error = soap_ignore_element(soap);
				}
				if (soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{
					return NULL;
				}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _timg__GetImagingSettingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetImagingSettingsResponse, 0, sizeof(struct _timg__GetImagingSettingsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ImagingSettings > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetImagingSettingsResponse(struct soap *soap, const struct _timg__GetImagingSettingsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__GetImagingSettingsResponse);
	if (soap_out__timg__GetImagingSettingsResponse(soap, tag?tag:"timg:GetImagingSettingsResponse", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetImagingSettingsResponse * SOAP_FMAC4 soap_get__timg__GetImagingSettingsResponse(struct soap *soap, struct _timg__GetImagingSettingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetImagingSettingsResponse(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettings20(struct soap *soap, struct tt__ImagingSettings20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettings20))
	{
		soap_serialize_tt__ImagingSettings20(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettings20(struct soap *soap, const char *tag, int id, struct tt__ImagingSettings20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettings20);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__ImagingSettings20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingSettings20 ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettings20(struct soap *soap, const char *tag, struct tt__ImagingSettings20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__ImagingSettings20 **)soap_malloc(soap, sizeof(struct tt__ImagingSettings20 *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__ImagingSettings20(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__ImagingSettings20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettings20, sizeof(struct tt__ImagingSettings20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettings20(struct soap *soap, struct tt__ImagingSettings20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ImagingSettings20);
	if (soap_out_PointerTott__ImagingSettings20(soap, tag?tag:"tt:ImagingSettings20", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingSettings20 ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettings20(struct soap *soap, struct tt__ImagingSettings20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettings20(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingSettings20(struct soap *soap, struct tt__ImagingSettings20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->BacklightCompensation = NULL;
	a->Brightness = NULL;
	a->ColorSaturation = NULL;
	a->Contrast = NULL;
	a->Exposure = NULL;
	a->Focus = NULL;
	a->IrCutFilter = NULL;
	a->Sharpness = NULL;
	a->WideDynamicRange = NULL;
	a->WhiteBalance = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingSettings20(struct soap *soap, const struct tt__ImagingSettings20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__BacklightCompensation20(soap, &a->BacklightCompensation);
	soap_serialize_PointerTofloat(soap, &a->Brightness);
	soap_serialize_PointerTofloat(soap, &a->ColorSaturation);
	soap_serialize_PointerTofloat(soap, &a->Contrast);
	soap_serialize_PointerTott__Exposure20(soap, &a->Exposure);
	soap_serialize_PointerTott__FocusConfiguration20(soap, &a->Focus);
	soap_serialize_PointerTott__IrCutFilterMode(soap, &a->IrCutFilter);
	soap_serialize_PointerTofloat(soap, &a->Sharpness);
	soap_serialize_PointerTott__WideDynamicRange20(soap, &a->WideDynamicRange);
	soap_serialize_PointerTott__WhiteBalance20(soap, &a->WhiteBalance);
	soap_serialize_PointerTott__ImagingSettingsExtension20(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettings20(struct soap *soap, const char *tag, int id, const struct tt__ImagingSettings20 *a, const char *type)
{
	if (a->__anyAttribute != NULL)
	{
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	}
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettings20), type))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__BacklightCompensation20(soap, "tt:BacklightCompensation", -1, &a->BacklightCompensation, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTofloat(soap, "tt:Brightness", -1, &a->Brightness, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTofloat(soap, "tt:ColorSaturation", -1, &a->ColorSaturation, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTofloat(soap, "tt:Contrast", -1, &a->Contrast, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__Exposure20(soap, "tt:Exposure", -1, &a->Exposure, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__FocusConfiguration20(soap, "tt:Focus", -1, &a->Focus, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__IrCutFilterMode(soap, "tt:IrCutFilter", -1, &a->IrCutFilter, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTofloat(soap, "tt:Sharpness", -1, &a->Sharpness, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__WideDynamicRange20(soap, "tt:WideDynamicRange", -1, &a->WideDynamicRange, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__WhiteBalance20(soap, "tt:WhiteBalance", -1, &a->WhiteBalance, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__ImagingSettingsExtension20(soap, "tt:Extension", -1, &a->Extension, ""))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingSettings20 * SOAP_FMAC4 soap_in_tt__ImagingSettings20(struct soap *soap, const char *tag, struct tt__ImagingSettings20 *a, const char *type)
{
	size_t soap_flag_BacklightCompensation = 1;
	size_t soap_flag_Brightness = 1;
	size_t soap_flag_ColorSaturation = 1;
	size_t soap_flag_Contrast = 1;
	size_t soap_flag_Exposure = 1;
	size_t soap_flag_Focus = 1;
	size_t soap_flag_IrCutFilter = 1;
	size_t soap_flag_Sharpness = 1;
	size_t soap_flag_WideDynamicRange = 1;
	size_t soap_flag_WhiteBalance = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__ImagingSettings20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettings20, sizeof(struct tt__ImagingSettings20), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__ImagingSettings20(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BacklightCompensation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BacklightCompensation20(soap, "tt:BacklightCompensation", &a->BacklightCompensation, "tt:BacklightCompensation20"))
				{	
					soap_flag_BacklightCompensation--;
					continue;
				}
				if (soap_flag_Brightness && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTofloat(soap, "tt:Brightness", &a->Brightness, "xsd:float"))
					{	
						soap_flag_Brightness--;
						continue;
					}
					if (soap_flag_ColorSaturation && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTofloat(soap, "tt:ColorSaturation", &a->ColorSaturation, "xsd:float"))
						{	
							soap_flag_ColorSaturation--;
							continue;
						}	
						if (soap_flag_Contrast && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_PointerTofloat(soap, "tt:Contrast", &a->Contrast, "xsd:float"))
							{	
								soap_flag_Contrast--;
								continue;
							}
							if (soap_flag_Exposure && soap->error == SOAP_TAG_MISMATCH)
								if (soap_in_PointerTott__Exposure20(soap, "tt:Exposure", &a->Exposure, "tt:Exposure20"))
								{	
									soap_flag_Exposure--;
									continue;
								}
								if (soap_flag_Focus && soap->error == SOAP_TAG_MISMATCH)
									if (soap_in_PointerTott__FocusConfiguration20(soap, "tt:Focus", &a->Focus, "tt:FocusConfiguration20"))
									{	
										soap_flag_Focus--;
										continue;
									}
									if (soap_flag_IrCutFilter && soap->error == SOAP_TAG_MISMATCH)
										if (soap_in_PointerTott__IrCutFilterMode(soap, "tt:IrCutFilter", &a->IrCutFilter, "tt:IrCutFilterMode"))
										{	
											soap_flag_IrCutFilter--;
											continue;
										}
										if (soap_flag_Sharpness && soap->error == SOAP_TAG_MISMATCH)
											if (soap_in_PointerTofloat(soap, "tt:Sharpness", &a->Sharpness, "xsd:float"))
											{	
												soap_flag_Sharpness--;
												continue;
											}
											if (soap_flag_WideDynamicRange && soap->error == SOAP_TAG_MISMATCH)
												if (soap_in_PointerTott__WideDynamicRange20(soap, "tt:WideDynamicRange", &a->WideDynamicRange, "tt:WideDynamicRange20"))
												{	
													soap_flag_WideDynamicRange--;
													continue;
												}
												if (soap_flag_WhiteBalance && soap->error == SOAP_TAG_MISMATCH)
													if (soap_in_PointerTott__WhiteBalance20(soap, "tt:WhiteBalance", &a->WhiteBalance, "tt:WhiteBalance20"))
													{	
														soap_flag_WhiteBalance--;
														continue;
													}
													if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
														if (soap_in_PointerTott__ImagingSettingsExtension20(soap, "tt:Extension", &a->Extension, "tt:ImagingSettingsExtension20"))
														{	
															soap_flag_Extension--;
															continue;
														}
														if (soap->error == SOAP_TAG_MISMATCH)
														{
															soap->error = soap_ignore_element(soap);
														}
														if (soap->error == SOAP_NO_TAG)
														{
															break;
														}
														if (soap->error)
														{
															return NULL;
														}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__ImagingSettings20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettings20, 0, sizeof(struct tt__ImagingSettings20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingSettings20(struct soap *soap, const struct tt__ImagingSettings20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ImagingSettings20);
	if (soap_out_tt__ImagingSettings20(soap, tag?tag:"tt:ImagingSettings20", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingSettings20 * SOAP_FMAC4 soap_get_tt__ImagingSettings20(struct soap *soap, struct tt__ImagingSettings20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettings20(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BacklightCompensation20(struct soap *soap, struct tt__BacklightCompensation20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BacklightCompensation20))
	{
		soap_serialize_tt__BacklightCompensation20(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BacklightCompensation20(struct soap *soap, const char *tag, int id, struct tt__BacklightCompensation20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BacklightCompensation20);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__BacklightCompensation20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__BacklightCompensation20 ** SOAP_FMAC4 soap_in_PointerTott__BacklightCompensation20(struct soap *soap, const char *tag, struct tt__BacklightCompensation20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__BacklightCompensation20 **)soap_malloc(soap, sizeof(struct tt__BacklightCompensation20 *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__BacklightCompensation20(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__BacklightCompensation20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BacklightCompensation20, sizeof(struct tt__BacklightCompensation20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BacklightCompensation20(struct soap *soap, struct tt__BacklightCompensation20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__BacklightCompensation20);
	if (soap_out_PointerTott__BacklightCompensation20(soap, tag?tag:"tt:BacklightCompensation20", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BacklightCompensation20 ** SOAP_FMAC4 soap_get_PointerTott__BacklightCompensation20(struct soap *soap, struct tt__BacklightCompensation20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BacklightCompensation20(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__BacklightCompensationMode(struct soap *soap, enum tt__BacklightCompensationMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__BacklightCompensationMode
	*a = SOAP_DEFAULT_tt__BacklightCompensationMode;
#else
	*a = (enum tt__BacklightCompensationMode)0;
#endif
}

static const struct soap_code_map soap_codes_tt__BacklightCompensationMode[] =
{	
	{ (long)tt__BacklightCompensationMode__OFF, "OFF" },
	{ (long)tt__BacklightCompensationMode__ON, "ON" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__BacklightCompensationMode2s(struct soap *soap, enum tt__BacklightCompensationMode n)
{	
	const char *s = soap_code_str(soap_codes_tt__BacklightCompensationMode, (long)n);
	if (s != NULL)
	{
		return s;
	}
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensationMode(struct soap *soap, const char *tag, int id, const enum tt__BacklightCompensationMode *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BacklightCompensationMode), type) || soap_send(soap, soap_tt__BacklightCompensationMode2s(soap, *a)))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__BacklightCompensationMode(struct soap *soap, const char *s, enum tt__BacklightCompensationMode *a)
{
	const struct soap_code_map *map;
	if (s == NULL)
	{
		return soap->error;
	}
	map = soap_code(soap_codes_tt__BacklightCompensationMode, s);
	if (map != NULL)
	{
		*a = (enum tt__BacklightCompensationMode)map->code;
	}
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
		{
			return soap->error = SOAP_TYPE;
		}
		*a = (enum tt__BacklightCompensationMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__BacklightCompensationMode * SOAP_FMAC4 soap_in_tt__BacklightCompensationMode(struct soap *soap, const char *tag, enum tt__BacklightCompensationMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (enum tt__BacklightCompensationMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensationMode, sizeof(enum tt__BacklightCompensationMode), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	
		if ((a==NULL) || soap_s2tt__BacklightCompensationMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (enum tt__BacklightCompensationMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensationMode, 0, sizeof(enum tt__BacklightCompensationMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__BacklightCompensationMode(struct soap *soap, const enum tt__BacklightCompensationMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__BacklightCompensationMode);
	if (soap_out_tt__BacklightCompensationMode(soap, tag?tag:"tt:BacklightCompensationMode", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__BacklightCompensationMode * SOAP_FMAC4 soap_get_tt__BacklightCompensationMode(struct soap *soap, enum tt__BacklightCompensationMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BacklightCompensationMode(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__BacklightCompensation20(struct soap *soap, struct tt__BacklightCompensation20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__BacklightCompensationMode(soap, &a->Mode);
	a->Level = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__BacklightCompensation20(struct soap *soap, const struct tt__BacklightCompensation20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Mode, SOAP_TYPE_tt__BacklightCompensationMode);
	soap_serialize_PointerTofloat(soap, &a->Level);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensation20(struct soap *soap, const char *tag, int id, const struct tt__BacklightCompensation20 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BacklightCompensation20), type))
	{
		return soap->error;
	}
	if (soap_out_tt__BacklightCompensationMode(soap, "tt:Mode", -1, &a->Mode, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTofloat(soap, "tt:Level", -1, &a->Level, ""))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__BacklightCompensation20 * SOAP_FMAC4 soap_in_tt__BacklightCompensation20(struct soap *soap, const char *tag, struct tt__BacklightCompensation20 *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__BacklightCompensation20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensation20, sizeof(struct tt__BacklightCompensation20), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__BacklightCompensation20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__BacklightCompensationMode(soap, "tt:Mode", &a->Mode, "tt:BacklightCompensationMode"))
				{	
					soap_flag_Mode--;
					continue;
				}
				if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTofloat(soap, "tt:Level", &a->Level, "xsd:float"))
					{	
						soap_flag_Level--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH)
					{
						soap->error = soap_ignore_element(soap);
					}
					if (soap->error == SOAP_NO_TAG)
					{
						break;
					}
					if (soap->error)
					{
						return NULL;
					}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	a = (struct tt__BacklightCompensation20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensation20, 0, sizeof(struct tt__BacklightCompensation20), 0, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
	{
		return NULL;
	}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__BacklightCompensation20(struct soap *soap, const struct tt__BacklightCompensation20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__BacklightCompensation20);
	if (soap_out_tt__BacklightCompensation20(soap, tag?tag:"tt:BacklightCompensation20", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BacklightCompensation20 * SOAP_FMAC4 soap_get_tt__BacklightCompensation20(struct soap *soap, struct tt__BacklightCompensation20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BacklightCompensation20(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Exposure20(struct soap *soap, struct tt__Exposure20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Exposure20))
	{
		soap_serialize_tt__Exposure20(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Exposure20(struct soap *soap, const char *tag, int id, struct tt__Exposure20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Exposure20);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__Exposure20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Exposure20 ** SOAP_FMAC4 soap_in_PointerTott__Exposure20(struct soap *soap, const char *tag, struct tt__Exposure20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__Exposure20 **)soap_malloc(soap, sizeof(struct tt__Exposure20 *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__Exposure20(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__Exposure20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Exposure20, sizeof(struct tt__Exposure20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Exposure20(struct soap *soap, struct tt__Exposure20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Exposure20);
	if (soap_out_PointerTott__Exposure20(soap, tag?tag:"tt:Exposure20", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Exposure20 ** SOAP_FMAC4 soap_get_PointerTott__Exposure20(struct soap *soap, struct tt__Exposure20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Exposure20(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ExposureMode(struct soap *soap, enum tt__ExposureMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__ExposureMode
	*a = SOAP_DEFAULT_tt__ExposureMode;
#else
	*a = (enum tt__ExposureMode)0;
#endif
}

static const struct soap_code_map soap_codes_tt__ExposureMode[] =
{	
	{ (long)tt__ExposureMode__AUTO, "AUTO" },
	{ (long)tt__ExposureMode__MANUAL, "MANUAL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ExposureMode2s(struct soap *soap, enum tt__ExposureMode n)
{	
	const char *s = soap_code_str(soap_codes_tt__ExposureMode, (long)n);
	if (s!= NULL)
	{
		return s;
	}
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ExposureMode(struct soap *soap, const char *tag, int id, const enum tt__ExposureMode *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ExposureMode), type) || soap_send(soap, soap_tt__ExposureMode2s(soap, *a)))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ExposureMode(struct soap *soap, const char *s, enum tt__ExposureMode *a)
{
	const struct soap_code_map *map;
	if (s == NULL)
	{
		return soap->error;
	}
	map = soap_code(soap_codes_tt__ExposureMode, s);
	if (map != NULL)
	{
		*a = (enum tt__ExposureMode)map->code;
	}
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
		{
			return soap->error = SOAP_TYPE;
		}
		*a = (enum tt__ExposureMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__ExposureMode * SOAP_FMAC4 soap_in_tt__ExposureMode(struct soap *soap, const char *tag, enum tt__ExposureMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (enum tt__ExposureMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ExposureMode, sizeof(enum tt__ExposureMode), 0, NULL, NULL, NULL);
	if (a == NULL)
	{	
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	
		if (a == NULL || soap_s2tt__ExposureMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (enum tt__ExposureMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ExposureMode, 0, sizeof(enum tt__ExposureMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ExposureMode(struct soap *soap, const enum tt__ExposureMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ExposureMode);
	if (soap_out_tt__ExposureMode(soap, tag?tag:"tt:ExposureMode", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ExposureMode * SOAP_FMAC4 soap_get_tt__ExposureMode(struct soap *soap, enum tt__ExposureMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ExposureMode(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ExposurePriority(struct soap *soap, enum tt__ExposurePriority *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__ExposurePriority
	*a = SOAP_DEFAULT_tt__ExposurePriority;
#else
	*a = (enum tt__ExposurePriority)0;
#endif
}

static const struct soap_code_map soap_codes_tt__ExposurePriority[] =
{	
	{ (long)tt__ExposurePriority__LowNoise, "LowNoise" },
	{ (long)tt__ExposurePriority__FrameRate, "FrameRate" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ExposurePriority2s(struct soap *soap, enum tt__ExposurePriority n)
{	
	const char *s = soap_code_str(soap_codes_tt__ExposurePriority, (long)n);
	if (s != NULL)
	{
		return s;
	}
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ExposurePriority(struct soap *soap, const char *tag, int id, const enum tt__ExposurePriority *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ExposurePriority), type) || soap_send(soap, soap_tt__ExposurePriority2s(soap, *a)))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ExposurePriority(struct soap *soap, const char *s, enum tt__ExposurePriority *a)
{
	const struct soap_code_map *map;
	if (s == NULL)
	{
		return soap->error;
	}
	map = soap_code(soap_codes_tt__ExposurePriority, s);
	if (map != NULL)
	{
		*a = (enum tt__ExposurePriority)map->code;
	}
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
		{
			return soap->error = SOAP_TYPE;
		}
		*a = (enum tt__ExposurePriority)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__ExposurePriority * SOAP_FMAC4 soap_in_tt__ExposurePriority(struct soap *soap, const char *tag, enum tt__ExposurePriority *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (enum tt__ExposurePriority *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ExposurePriority, sizeof(enum tt__ExposurePriority), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	
		if ((a == NULL) || soap_s2tt__ExposurePriority(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (enum tt__ExposurePriority *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ExposurePriority, 0, sizeof(enum tt__ExposurePriority), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ExposurePriority(struct soap *soap, const enum tt__ExposurePriority *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ExposurePriority);
	if (soap_out_tt__ExposurePriority(soap, tag?tag:"tt:ExposurePriority", id, a, type))
	{
		return soap->error;
	}

	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ExposurePriority * SOAP_FMAC4 soap_get_tt__ExposurePriority(struct soap *soap, enum tt__ExposurePriority *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ExposurePriority(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ExposurePriority(struct soap *soap, enum tt__ExposurePriority *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_tt__ExposurePriority);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ExposurePriority(struct soap *soap, const char *tag, int id, enum tt__ExposurePriority *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ExposurePriority);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__ExposurePriority(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__ExposurePriority ** SOAP_FMAC4 soap_in_PointerTott__ExposurePriority(struct soap *soap, const char *tag, enum tt__ExposurePriority **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (enum tt__ExposurePriority **)soap_malloc(soap, sizeof(enum tt__ExposurePriority *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__ExposurePriority(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (enum tt__ExposurePriority **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ExposurePriority, sizeof(enum tt__ExposurePriority), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ExposurePriority(struct soap *soap, enum tt__ExposurePriority *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ExposurePriority);
	if (soap_out_PointerTott__ExposurePriority(soap, tag?tag:"tt:ExposurePriority", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ExposurePriority ** SOAP_FMAC4 soap_get_PointerTott__ExposurePriority(struct soap *soap, enum tt__ExposurePriority **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ExposurePriority(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Exposure20(struct soap *soap, struct tt__Exposure20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ExposureMode(soap, &a->Mode);
	a->Priority = NULL;
	a->Window = NULL;
	a->MinExposureTime = NULL;
	a->MaxExposureTime = NULL;
	a->MinGain = NULL;
	a->MaxGain = NULL;
	a->MinIris = NULL;
	a->MaxIris = NULL;
	a->ExposureTime = NULL;
	a->Gain = NULL;
	a->Iris = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Exposure20(struct soap *soap, const struct tt__Exposure20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Mode, SOAP_TYPE_tt__ExposureMode);
	soap_serialize_PointerTott__ExposurePriority(soap, &a->Priority);
	soap_serialize_PointerTott__Rectangle(soap, &a->Window);
	soap_serialize_PointerTofloat(soap, &a->MinExposureTime);
	soap_serialize_PointerTofloat(soap, &a->MaxExposureTime);
	soap_serialize_PointerTofloat(soap, &a->MinGain);
	soap_serialize_PointerTofloat(soap, &a->MaxGain);
	soap_serialize_PointerTofloat(soap, &a->MinIris);
	soap_serialize_PointerTofloat(soap, &a->MaxIris);
	soap_serialize_PointerTofloat(soap, &a->ExposureTime);
	soap_serialize_PointerTofloat(soap, &a->Gain);
	soap_serialize_PointerTofloat(soap, &a->Iris);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Exposure20(struct soap *soap, const char *tag, int id, const struct tt__Exposure20 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Exposure20), type))
	{
		return soap->error;
	}
	if (soap_out_tt__ExposureMode(soap, "tt:Mode", -1, &a->Mode, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__ExposurePriority(soap, "tt:Priority", -1, &a->Priority, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__Rectangle(soap, "tt:Window", -1, &a->Window, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTofloat(soap, "tt:MinExposureTime", -1, &a->MinExposureTime, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTofloat(soap, "tt:MaxExposureTime", -1, &a->MaxExposureTime, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTofloat(soap, "tt:MinGain", -1, &a->MinGain, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTofloat(soap, "tt:MaxGain", -1, &a->MaxGain, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTofloat(soap, "tt:MinIris", -1, &a->MinIris, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTofloat(soap, "tt:MaxIris", -1, &a->MaxIris, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTofloat(soap, "tt:ExposureTime", -1, &a->ExposureTime, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTofloat(soap, "tt:Gain", -1, &a->Gain, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTofloat(soap, "tt:Iris", -1, &a->Iris, ""))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Exposure20 * SOAP_FMAC4 soap_in_tt__Exposure20(struct soap *soap, const char *tag, struct tt__Exposure20 *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Priority = 1;
	size_t soap_flag_Window = 1;
	size_t soap_flag_MinExposureTime = 1;
	size_t soap_flag_MaxExposureTime = 1;
	size_t soap_flag_MinGain = 1;
	size_t soap_flag_MaxGain = 1;
	size_t soap_flag_MinIris = 1;
	size_t soap_flag_MaxIris = 1;
	size_t soap_flag_ExposureTime = 1;
	size_t soap_flag_Gain = 1;
	size_t soap_flag_Iris = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__Exposure20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Exposure20, sizeof(struct tt__Exposure20), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__Exposure20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__ExposureMode(soap, "tt:Mode", &a->Mode, "tt:ExposureMode"))
				{	
					soap_flag_Mode--;
					continue;
				}
				if (soap_flag_Priority && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__ExposurePriority(soap, "tt:Priority", &a->Priority, "tt:ExposurePriority"))
					{	
						soap_flag_Priority--;
						continue;
					}
					if (soap_flag_Window && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTott__Rectangle(soap, "tt:Window", &a->Window, "tt:Rectangle"))
						{	
							soap_flag_Window--;
							continue;
						}
						if (soap_flag_MinExposureTime && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_PointerTofloat(soap, "tt:MinExposureTime", &a->MinExposureTime, "xsd:float"))
							{	
								soap_flag_MinExposureTime--;
								continue;
							}
							if (soap_flag_MaxExposureTime && soap->error == SOAP_TAG_MISMATCH)
								if (soap_in_PointerTofloat(soap, "tt:MaxExposureTime", &a->MaxExposureTime, "xsd:float"))
								{	
									soap_flag_MaxExposureTime--;
									continue;
								}
								if (soap_flag_MinGain && soap->error == SOAP_TAG_MISMATCH)
									if (soap_in_PointerTofloat(soap, "tt:MinGain", &a->MinGain, "xsd:float"))
									{	
										soap_flag_MinGain--;
										continue;
									}
									if (soap_flag_MaxGain && soap->error == SOAP_TAG_MISMATCH)
										if (soap_in_PointerTofloat(soap, "tt:MaxGain", &a->MaxGain, "xsd:float"))
										{	
											soap_flag_MaxGain--;
											continue;
										}
										if (soap_flag_MinIris && soap->error == SOAP_TAG_MISMATCH)
											if (soap_in_PointerTofloat(soap, "tt:MinIris", &a->MinIris, "xsd:float"))
											{	
												soap_flag_MinIris--;
												continue;
											}
											if (soap_flag_MaxIris && soap->error == SOAP_TAG_MISMATCH)
												if (soap_in_PointerTofloat(soap, "tt:MaxIris", &a->MaxIris, "xsd:float"))
												{	
													soap_flag_MaxIris--;
													continue;
												}
												if (soap_flag_ExposureTime && soap->error == SOAP_TAG_MISMATCH)
													if (soap_in_PointerTofloat(soap, "tt:ExposureTime", &a->ExposureTime, "xsd:float"))
													{	
														soap_flag_ExposureTime--;
														continue;
													}
													if (soap_flag_Gain && soap->error == SOAP_TAG_MISMATCH)
														if (soap_in_PointerTofloat(soap, "tt:Gain", &a->Gain, "xsd:float"))
														{	
															soap_flag_Gain--;
															continue;
														}
														if (soap_flag_Iris && soap->error == SOAP_TAG_MISMATCH)
															if (soap_in_PointerTofloat(soap, "tt:Iris", &a->Iris, "xsd:float"))
															{	
																soap_flag_Iris--;
																continue;
															}
															if (soap->error == SOAP_TAG_MISMATCH)
															{
																soap->error = soap_ignore_element(soap);
															}
															if (soap->error == SOAP_NO_TAG)
															{
																break;
															}
															if (soap->error)
															{
																return NULL;
															}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__Exposure20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Exposure20, 0, sizeof(struct tt__Exposure20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Exposure20(struct soap *soap, const struct tt__Exposure20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Exposure20);
	if (soap_out_tt__Exposure20(soap, tag?tag:"tt:Exposure20", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Exposure20 * SOAP_FMAC4 soap_get_tt__Exposure20(struct soap *soap, struct tt__Exposure20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Exposure20(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Rectangle(struct soap *soap, struct tt__Rectangle *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Rectangle))
	{
		soap_serialize_tt__Rectangle(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Rectangle(struct soap *soap, const char *tag, int id, struct tt__Rectangle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Rectangle);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__Rectangle(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Rectangle ** SOAP_FMAC4 soap_in_PointerTott__Rectangle(struct soap *soap, const char *tag, struct tt__Rectangle **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__Rectangle **)soap_malloc(soap, sizeof(struct tt__Rectangle *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__Rectangle(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__Rectangle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Rectangle, sizeof(struct tt__Rectangle), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Rectangle(struct soap *soap, struct tt__Rectangle *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Rectangle);
	if (soap_out_PointerTott__Rectangle(soap, tag?tag:"tt:Rectangle", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Rectangle ** SOAP_FMAC4 soap_get_PointerTott__Rectangle(struct soap *soap, struct tt__Rectangle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Rectangle(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Rectangle(struct soap *soap, struct tt__Rectangle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->bottom = NULL;
	a->top = NULL;
	a->right = NULL;
	a->left = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Rectangle(struct soap *soap, const struct tt__Rectangle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Rectangle(struct soap *soap, const char *tag, int id, const struct tt__Rectangle *a, const char *type)
{
	if (a->bottom)
	{
		soap_set_attr(soap, "bottom", soap_float2s(soap, *a->bottom), 1);
	}
	if (a->top)
	{
		soap_set_attr(soap, "top", soap_float2s(soap, *a->top), 1);
	}
	if (a->right)
	{
		soap_set_attr(soap, "right", soap_float2s(soap, *a->right), 1);
	}
	if (a->left)
	{
		soap_set_attr(soap, "left", soap_float2s(soap, *a->left), 1);
	}
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Rectangle), type))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Rectangle * SOAP_FMAC4 soap_in_tt__Rectangle(struct soap *soap, const char *tag, struct tt__Rectangle *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__Rectangle *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Rectangle, sizeof(struct tt__Rectangle), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__Rectangle(soap, a);
	{	
		const char *t = soap_attr_value(soap, "bottom", 0);
		if (t != NULL)
		{
			if (NULL==(a->bottom = (float *)soap_malloc(soap, sizeof(float))))
			{	
				soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->bottom))
			{
				return NULL;
			}
		}
		else if (soap->error)
		{
			return NULL;
		}
	}
	{	
		const char *t = soap_attr_value(soap, "top", 0);
		if (t != NULL)
		{
			if (NULL==(a->top = (float *)soap_malloc(soap, sizeof(float))))
			{	
				soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->top))
			{
				return NULL;
			}
		}
		else if (soap->error)
		{
			return NULL;
		}
	}
	{	
		const char *t = soap_attr_value(soap, "right", 0);
		if (t != NULL)
		{
			if (NULL==(a->right = (float *)soap_malloc(soap, sizeof(float))))
			{	
				soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->right))
			{
				return NULL;
			}
		}
		else if (soap->error)
		{
			return NULL;
		}
	}
	{	
		const char *t = soap_attr_value(soap, "left", 0);
		if (t != NULL)
		{
			if (NULL==(a->left = (float *)soap_malloc(soap, sizeof(float))))
			{	
				soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->left))
			{
				return NULL;
			}
		}
		else if (soap->error)
		{
			return NULL;
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{
				soap->error = soap_ignore_element(soap);
			}
			if (soap->error == SOAP_NO_TAG)
			{
				break;
			}
			if (soap->error)
			{
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__Rectangle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Rectangle, 0, sizeof(struct tt__Rectangle), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Rectangle(struct soap *soap, const struct tt__Rectangle *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Rectangle);
	if (soap_out_tt__Rectangle(soap, tag?tag:"tt:Rectangle", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Rectangle * SOAP_FMAC4 soap_get_tt__Rectangle(struct soap *soap, struct tt__Rectangle *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Rectangle(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusConfiguration20(struct soap *soap, struct tt__FocusConfiguration20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusConfiguration20))
	{
		soap_serialize_tt__FocusConfiguration20(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusConfiguration20(struct soap *soap, const char *tag, int id, struct tt__FocusConfiguration20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusConfiguration20);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__FocusConfiguration20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FocusConfiguration20 ** SOAP_FMAC4 soap_in_PointerTott__FocusConfiguration20(struct soap *soap, const char *tag, struct tt__FocusConfiguration20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__FocusConfiguration20 **)soap_malloc(soap, sizeof(struct tt__FocusConfiguration20 *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__FocusConfiguration20(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__FocusConfiguration20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusConfiguration20, sizeof(struct tt__FocusConfiguration20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusConfiguration20(struct soap *soap, struct tt__FocusConfiguration20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FocusConfiguration20);
	if (soap_out_PointerTott__FocusConfiguration20(soap, tag?tag:"tt:FocusConfiguration20", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusConfiguration20 ** SOAP_FMAC4 soap_get_PointerTott__FocusConfiguration20(struct soap *soap, struct tt__FocusConfiguration20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusConfiguration20(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FocusConfiguration20(struct soap *soap, struct tt__FocusConfiguration20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__AutoFocusMode(soap, &a->AutoFocusMode);
	a->DefaultSpeed = NULL;
	a->NearLimit = NULL;
	a->FarLimit = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FocusConfiguration20(struct soap *soap, const struct tt__FocusConfiguration20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->AutoFocusMode, SOAP_TYPE_tt__AutoFocusMode);
	soap_serialize_PointerTofloat(soap, &a->DefaultSpeed);
	soap_serialize_PointerTofloat(soap, &a->NearLimit);
	soap_serialize_PointerTofloat(soap, &a->FarLimit);
	soap_serialize_PointerTott__FocusConfiguration20Extension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusConfiguration20(struct soap *soap, const char *tag, int id, const struct tt__FocusConfiguration20 *a, const char *type)
{
	if (a->__anyAttribute != NULL)
	{
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	}
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusConfiguration20), type))
	{
		return soap->error;
	}
	if (soap_out_tt__AutoFocusMode(soap, "tt:AutoFocusMode", -1, &a->AutoFocusMode, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTofloat(soap, "tt:DefaultSpeed", -1, &a->DefaultSpeed, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTofloat(soap, "tt:NearLimit", -1, &a->NearLimit, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTofloat(soap, "tt:FarLimit", -1, &a->FarLimit, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__FocusConfiguration20Extension(soap, "tt:Extension", -1, &a->Extension, ""))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FocusConfiguration20 * SOAP_FMAC4 soap_in_tt__FocusConfiguration20(struct soap *soap, const char *tag, struct tt__FocusConfiguration20 *a, const char *type)
{
	size_t soap_flag_AutoFocusMode = 1;
	size_t soap_flag_DefaultSpeed = 1;
	size_t soap_flag_NearLimit = 1;
	size_t soap_flag_FarLimit = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__FocusConfiguration20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusConfiguration20, sizeof(struct tt__FocusConfiguration20), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__FocusConfiguration20(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AutoFocusMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__AutoFocusMode(soap, "tt:AutoFocusMode", &a->AutoFocusMode, "tt:AutoFocusMode"))
				{	
					soap_flag_AutoFocusMode--;
					continue;
				}
				if (soap_flag_DefaultSpeed && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTofloat(soap, "tt:DefaultSpeed", &a->DefaultSpeed, "xsd:float"))
					{	
						soap_flag_DefaultSpeed--;
						continue;
					}
					if (soap_flag_NearLimit && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTofloat(soap, "tt:NearLimit", &a->NearLimit, "xsd:float"))
						{	
							soap_flag_NearLimit--;
							continue;
						}
						if (soap_flag_FarLimit && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_PointerTofloat(soap, "tt:FarLimit", &a->FarLimit, "xsd:float"))
							{	
								soap_flag_FarLimit--;
								continue;
							}
							if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
								if (soap_in_PointerTott__FocusConfiguration20Extension(soap, "tt:Extension", &a->Extension, "tt:FocusConfiguration20Extension"))
								{	
									soap_flag_Extension--;
									continue;
								}
								if (soap->error == SOAP_TAG_MISMATCH)
								{
									soap->error = soap_ignore_element(soap);
								}
								if (soap->error == SOAP_NO_TAG)
								{
									break;
								}
								if (soap->error)
								{
									return NULL;
								}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__FocusConfiguration20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusConfiguration20, 0, sizeof(struct tt__FocusConfiguration20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AutoFocusMode > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FocusConfiguration20(struct soap *soap, const struct tt__FocusConfiguration20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__FocusConfiguration20);
	if (soap_out_tt__FocusConfiguration20(soap, tag?tag:"tt:FocusConfiguration20", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusConfiguration20 * SOAP_FMAC4 soap_get_tt__FocusConfiguration20(struct soap *soap, struct tt__FocusConfiguration20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusConfiguration20(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AutoFocusMode(struct soap *soap, enum tt__AutoFocusMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__AutoFocusMode
	*a = SOAP_DEFAULT_tt__AutoFocusMode;
#else
	*a = (enum tt__AutoFocusMode)0;
#endif
}

static const struct soap_code_map soap_codes_tt__AutoFocusMode[] =
{	
	{ (long)tt__AutoFocusMode__AUTO, "AUTO" },
	{ (long)tt__AutoFocusMode__MANUAL, "MANUAL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__AutoFocusMode2s(struct soap *soap, enum tt__AutoFocusMode n)
{	
	const char *s = soap_code_str(soap_codes_tt__AutoFocusMode, (long)n);
	if (s != NULL)
	{
		return s;
	}
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AutoFocusMode(struct soap *soap, const char *tag, int id, const enum tt__AutoFocusMode *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AutoFocusMode), type) || soap_send(soap, soap_tt__AutoFocusMode2s(soap, *a)))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__AutoFocusMode(struct soap *soap, const char *s, enum tt__AutoFocusMode *a)
{
	const struct soap_code_map *map;
	if (s == NULL)
	{
		return soap->error;
	}
	map = soap_code(soap_codes_tt__AutoFocusMode, s);
	if (map != NULL)
	{
		*a = (enum tt__AutoFocusMode)map->code;
	}
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
		{
			return soap->error = SOAP_TYPE;
		}
		*a = (enum tt__AutoFocusMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__AutoFocusMode * SOAP_FMAC4 soap_in_tt__AutoFocusMode(struct soap *soap, const char *tag, enum tt__AutoFocusMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (enum tt__AutoFocusMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AutoFocusMode, sizeof(enum tt__AutoFocusMode), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	
		if ((a==NULL) || soap_s2tt__AutoFocusMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{
		a = (enum tt__AutoFocusMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AutoFocusMode, 0, sizeof(enum tt__AutoFocusMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AutoFocusMode(struct soap *soap, const enum tt__AutoFocusMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AutoFocusMode);
	if (soap_out_tt__AutoFocusMode(soap, tag?tag:"tt:AutoFocusMode", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__AutoFocusMode * SOAP_FMAC4 soap_get_tt__AutoFocusMode(struct soap *soap, enum tt__AutoFocusMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AutoFocusMode(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusConfiguration20Extension(struct soap *soap, struct tt__FocusConfiguration20Extension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusConfiguration20Extension))
	{
		soap_serialize_tt__FocusConfiguration20Extension(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusConfiguration20Extension(struct soap *soap, const char *tag, int id, struct tt__FocusConfiguration20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusConfiguration20Extension);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__FocusConfiguration20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FocusConfiguration20Extension ** SOAP_FMAC4 soap_in_PointerTott__FocusConfiguration20Extension(struct soap *soap, const char *tag, struct tt__FocusConfiguration20Extension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__FocusConfiguration20Extension **)soap_malloc(soap, sizeof(struct tt__FocusConfiguration20Extension *))))
		{	
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__FocusConfiguration20Extension(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__FocusConfiguration20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusConfiguration20Extension, sizeof(struct tt__FocusConfiguration20Extension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusConfiguration20Extension(struct soap *soap, struct tt__FocusConfiguration20Extension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FocusConfiguration20Extension);
	if (soap_out_PointerTott__FocusConfiguration20Extension(soap, tag?tag:"tt:FocusConfiguration20Extension", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusConfiguration20Extension ** SOAP_FMAC4 soap_get_PointerTott__FocusConfiguration20Extension(struct soap *soap, struct tt__FocusConfiguration20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusConfiguration20Extension(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FocusConfiguration20Extension(struct soap *soap, struct tt__FocusConfiguration20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FocusConfiguration20Extension(struct soap *soap, const struct tt__FocusConfiguration20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusConfiguration20Extension(struct soap *soap, const char *tag, int id, const struct tt__FocusConfiguration20Extension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusConfiguration20Extension), type))
	{
		return soap->error;
	}
	if (a->__any != NULL)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_outliteral(soap, "-any", a->__any + i, NULL);
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FocusConfiguration20Extension * SOAP_FMAC4 soap_in_tt__FocusConfiguration20Extension(struct soap *soap, const char *tag, struct tt__FocusConfiguration20Extension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__FocusConfiguration20Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusConfiguration20Extension, sizeof(struct tt__FocusConfiguration20Extension), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__FocusConfiguration20Extension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
					{
						soap_blist___any = soap_new_block(soap);
					}
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
					{
						return NULL;
					}
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{
				soap->error = soap_ignore_element(soap);
			}
			if (soap->error == SOAP_NO_TAG)
			{
				break;
			}
			if (soap->error)
			{
				return NULL;
			}
		}
		if (a->__any != NULL)
		{
			soap_pop_block(soap, soap_blist___any);
		}
		if (a->__size)
		{
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
			{
				soap_end_block(soap, soap_blist___any);
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__FocusConfiguration20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusConfiguration20Extension, 0, sizeof(struct tt__FocusConfiguration20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FocusConfiguration20Extension(struct soap *soap, const struct tt__FocusConfiguration20Extension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__FocusConfiguration20Extension);
	if (soap_out_tt__FocusConfiguration20Extension(soap, tag?tag:"tt:FocusConfiguration20Extension", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusConfiguration20Extension * SOAP_FMAC4 soap_get_tt__FocusConfiguration20Extension(struct soap *soap, struct tt__FocusConfiguration20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusConfiguration20Extension(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IrCutFilterMode(struct soap *soap, enum tt__IrCutFilterMode *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_tt__IrCutFilterMode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IrCutFilterMode(struct soap *soap, const char *tag, int id, enum tt__IrCutFilterMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IrCutFilterMode);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__IrCutFilterMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__IrCutFilterMode ** SOAP_FMAC4 soap_in_PointerTott__IrCutFilterMode(struct soap *soap, const char *tag, enum tt__IrCutFilterMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a== NULL)
	{
		if (NULL==(a = (enum tt__IrCutFilterMode **)soap_malloc(soap, sizeof(enum tt__IrCutFilterMode *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__IrCutFilterMode(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (enum tt__IrCutFilterMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IrCutFilterMode, sizeof(enum tt__IrCutFilterMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IrCutFilterMode(struct soap *soap, enum tt__IrCutFilterMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IrCutFilterMode);
	if (soap_out_PointerTott__IrCutFilterMode(soap, tag?tag:"tt:IrCutFilterMode", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IrCutFilterMode ** SOAP_FMAC4 soap_get_PointerTott__IrCutFilterMode(struct soap *soap, enum tt__IrCutFilterMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IrCutFilterMode(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IrCutFilterMode(struct soap *soap, enum tt__IrCutFilterMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__IrCutFilterMode
	*a = SOAP_DEFAULT_tt__IrCutFilterMode;
#else
	*a = (enum tt__IrCutFilterMode)0;
#endif
}

static const struct soap_code_map soap_codes_tt__IrCutFilterMode[] =
{	
	{ (long)tt__IrCutFilterMode__ON, "ON" },
	{ (long)tt__IrCutFilterMode__OFF, "OFF" },
	{ (long)tt__IrCutFilterMode__AUTO, "AUTO" },
	{ 0, NULL }
};
SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__IrCutFilterMode2s(struct soap *soap, enum tt__IrCutFilterMode n)
{	
	const char *s = soap_code_str(soap_codes_tt__IrCutFilterMode, (long)n);
	if (s != NULL)
	{
		return s;
	}
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterMode(struct soap *soap, const char *tag, int id, const enum tt__IrCutFilterMode *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IrCutFilterMode), type) || soap_send(soap, soap_tt__IrCutFilterMode2s(soap, *a)))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__IrCutFilterMode(struct soap *soap, const char *s, enum tt__IrCutFilterMode *a)
{
	const struct soap_code_map *map;
	if (s == NULL)
	{
		return soap->error;
	}
	map = soap_code(soap_codes_tt__IrCutFilterMode, s);
	if (map != NULL)
	{
		*a = (enum tt__IrCutFilterMode)map->code;
	}
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
		{
			return soap->error = SOAP_TYPE;
		}
		*a = (enum tt__IrCutFilterMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__IrCutFilterMode * SOAP_FMAC4 soap_in_tt__IrCutFilterMode(struct soap *soap, const char *tag, enum tt__IrCutFilterMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (enum tt__IrCutFilterMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterMode, sizeof(enum tt__IrCutFilterMode), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	
		if ((a==NULL) || soap_s2tt__IrCutFilterMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (enum tt__IrCutFilterMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IrCutFilterMode, 0, sizeof(enum tt__IrCutFilterMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IrCutFilterMode(struct soap *soap, const enum tt__IrCutFilterMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IrCutFilterMode);
	if (soap_out_tt__IrCutFilterMode(soap, tag?tag:"tt:IrCutFilterMode", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IrCutFilterMode * SOAP_FMAC4 soap_get_tt__IrCutFilterMode(struct soap *soap, enum tt__IrCutFilterMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IrCutFilterMode(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WideDynamicRange20(struct soap *soap, struct tt__WideDynamicRange20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WideDynamicRange20))
	{
		soap_serialize_tt__WideDynamicRange20(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WideDynamicRange20(struct soap *soap, const char *tag, int id, struct tt__WideDynamicRange20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WideDynamicRange20);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__WideDynamicRange20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__WideDynamicRange20 ** SOAP_FMAC4 soap_in_PointerTott__WideDynamicRange20(struct soap *soap, const char *tag, struct tt__WideDynamicRange20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__WideDynamicRange20 **)soap_malloc(soap, sizeof(struct tt__WideDynamicRange20 *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__WideDynamicRange20(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__WideDynamicRange20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WideDynamicRange20, sizeof(struct tt__WideDynamicRange20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WideDynamicRange20(struct soap *soap, struct tt__WideDynamicRange20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__WideDynamicRange20);
	if (soap_out_PointerTott__WideDynamicRange20(soap, tag?tag:"tt:WideDynamicRange20", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WideDynamicRange20 ** SOAP_FMAC4 soap_get_PointerTott__WideDynamicRange20(struct soap *soap, struct tt__WideDynamicRange20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WideDynamicRange20(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WideDynamicMode(struct soap *soap, enum tt__WideDynamicMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__WideDynamicMode
	*a = SOAP_DEFAULT_tt__WideDynamicMode;
#else
	*a = (enum tt__WideDynamicMode)0;
#endif
}

static const struct soap_code_map soap_codes_tt__WideDynamicMode[] =
{	
	{ (long)tt__WideDynamicMode__OFF, "OFF" },
	{ (long)tt__WideDynamicMode__ON, "ON" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__WideDynamicMode2s(struct soap *soap, enum tt__WideDynamicMode n)
{	
	const char *s = soap_code_str(soap_codes_tt__WideDynamicMode, (long)n);
	if (s != NULL)
	{
		return s;
	}
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicMode(struct soap *soap, const char *tag, int id, const enum tt__WideDynamicMode *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WideDynamicMode), type) || soap_send(soap, soap_tt__WideDynamicMode2s(soap, *a)))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__WideDynamicMode(struct soap *soap, const char *s, enum tt__WideDynamicMode *a)
{
	const struct soap_code_map *map;
	if (s == NULL)
	{
		return soap->error;
	}
	map = soap_code(soap_codes_tt__WideDynamicMode, s);
	if (map != NULL)
	{
		*a = (enum tt__WideDynamicMode)map->code;
	}
	else
	{
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
		{
			return soap->error = SOAP_TYPE;
		}
		*a = (enum tt__WideDynamicMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__WideDynamicMode * SOAP_FMAC4 soap_in_tt__WideDynamicMode(struct soap *soap, const char *tag, enum tt__WideDynamicMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (enum tt__WideDynamicMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicMode, sizeof(enum tt__WideDynamicMode), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	
		if ((a==NULL) || soap_s2tt__WideDynamicMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (enum tt__WideDynamicMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicMode, 0, sizeof(enum tt__WideDynamicMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WideDynamicMode(struct soap *soap, const enum tt__WideDynamicMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__WideDynamicMode);
	if (soap_out_tt__WideDynamicMode(soap, tag?tag:"tt:WideDynamicMode", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__WideDynamicMode * SOAP_FMAC4 soap_get_tt__WideDynamicMode(struct soap *soap, enum tt__WideDynamicMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WideDynamicMode(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WideDynamicRange20(struct soap *soap, struct tt__WideDynamicRange20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__WideDynamicMode(soap, &a->Mode);
	a->Level = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__WideDynamicRange20(struct soap *soap, const struct tt__WideDynamicRange20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Mode, SOAP_TYPE_tt__WideDynamicMode);
	soap_serialize_PointerTofloat(soap, &a->Level);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicRange20(struct soap *soap, const char *tag, int id, const struct tt__WideDynamicRange20 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WideDynamicRange20), type))
	{
		return soap->error;
	}
	if (soap_out_tt__WideDynamicMode(soap, "tt:Mode", -1, &a->Mode, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTofloat(soap, "tt:Level", -1, &a->Level, ""))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__WideDynamicRange20 * SOAP_FMAC4 soap_in_tt__WideDynamicRange20(struct soap *soap, const char *tag, struct tt__WideDynamicRange20 *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__WideDynamicRange20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicRange20, sizeof(struct tt__WideDynamicRange20), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__WideDynamicRange20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__WideDynamicMode(soap, "tt:Mode", &a->Mode, "tt:WideDynamicMode"))
				{	
					soap_flag_Mode--;
					continue;
				}
				if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTofloat(soap, "tt:Level", &a->Level, "xsd:float"))
					{	
						soap_flag_Level--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH)
					{
						soap->error = soap_ignore_element(soap);
					}
					if (soap->error == SOAP_NO_TAG)
					{
						break;
					}
					if (soap->error)
					{
						return NULL;
					}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__WideDynamicRange20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicRange20, 0, sizeof(struct tt__WideDynamicRange20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
	{
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WideDynamicRange20(struct soap *soap, const struct tt__WideDynamicRange20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__WideDynamicRange20);
	if (soap_out_tt__WideDynamicRange20(soap, tag?tag:"tt:WideDynamicRange20", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WideDynamicRange20 * SOAP_FMAC4 soap_get_tt__WideDynamicRange20(struct soap *soap, struct tt__WideDynamicRange20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WideDynamicRange20(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalance20(struct soap *soap, struct tt__WhiteBalance20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalance20))
	{
		soap_serialize_tt__WhiteBalance20(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalance20(struct soap *soap, const char *tag, int id, struct tt__WhiteBalance20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalance20);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__WhiteBalance20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__WhiteBalance20 ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalance20(struct soap *soap, const char *tag, struct tt__WhiteBalance20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__WhiteBalance20 **)soap_malloc(soap, sizeof(struct tt__WhiteBalance20 *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__WhiteBalance20(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__WhiteBalance20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalance20, sizeof(struct tt__WhiteBalance20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalance20(struct soap *soap, struct tt__WhiteBalance20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__WhiteBalance20);
	if (soap_out_PointerTott__WhiteBalance20(soap, tag?tag:"tt:WhiteBalance20", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalance20 ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalance20(struct soap *soap, struct tt__WhiteBalance20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalance20(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WhiteBalance20(struct soap *soap, struct tt__WhiteBalance20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__WhiteBalanceMode(soap, &a->Mode);
	a->CrGain = NULL;
	a->CbGain = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__WhiteBalance20(struct soap *soap, const struct tt__WhiteBalance20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Mode, SOAP_TYPE_tt__WhiteBalanceMode);
	soap_serialize_PointerTofloat(soap, &a->CrGain);
	soap_serialize_PointerTofloat(soap, &a->CbGain);
	soap_serialize_PointerTott__WhiteBalance20Extension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalance20(struct soap *soap, const char *tag, int id, const struct tt__WhiteBalance20 *a, const char *type)
{
	if (a->__anyAttribute != NULL)
	{
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	}
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalance20), type))
	{
		return soap->error;
	}
	if (soap_out_tt__WhiteBalanceMode(soap, "tt:Mode", -1, &a->Mode, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTofloat(soap, "tt:CrGain", -1, &a->CrGain, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTofloat(soap, "tt:CbGain", -1, &a->CbGain, ""))
	{
		return soap->error;
	}
	if (soap_out_PointerTott__WhiteBalance20Extension(soap, "tt:Extension", -1, &a->Extension, ""))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__WhiteBalance20 * SOAP_FMAC4 soap_in_tt__WhiteBalance20(struct soap *soap, const char *tag, struct tt__WhiteBalance20 *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_CrGain = 1;
	size_t soap_flag_CbGain = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__WhiteBalance20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalance20, sizeof(struct tt__WhiteBalance20), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__WhiteBalance20(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__WhiteBalanceMode(soap, "tt:Mode", &a->Mode, "tt:WhiteBalanceMode"))
				{	
					soap_flag_Mode--;
					continue;
				}
				if (soap_flag_CrGain && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTofloat(soap, "tt:CrGain", &a->CrGain, "xsd:float"))
					{	
						soap_flag_CrGain--;
						continue;
					}
					if (soap_flag_CbGain && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerTofloat(soap, "tt:CbGain", &a->CbGain, "xsd:float"))
						{	
							soap_flag_CbGain--;
							continue;
						}
						if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
							if (soap_in_PointerTott__WhiteBalance20Extension(soap, "tt:Extension", &a->Extension, "tt:WhiteBalance20Extension"))
							{	
								soap_flag_Extension--;
								continue;
							}
							if (soap->error == SOAP_TAG_MISMATCH)
							{
								soap->error = soap_ignore_element(soap);
							}
							if (soap->error == SOAP_NO_TAG)
							{
								break;
							}
							if (soap->error)
							{
								return NULL;
							}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__WhiteBalance20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalance20, 0, sizeof(struct tt__WhiteBalance20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WhiteBalance20(struct soap *soap, const struct tt__WhiteBalance20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__WhiteBalance20);
	if (soap_out_tt__WhiteBalance20(soap, tag?tag:"tt:WhiteBalance20", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalance20 * SOAP_FMAC4 soap_get_tt__WhiteBalance20(struct soap *soap, struct tt__WhiteBalance20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalance20(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WhiteBalanceMode(struct soap *soap, enum tt__WhiteBalanceMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__WhiteBalanceMode
	*a = SOAP_DEFAULT_tt__WhiteBalanceMode;
#else
	*a = (enum tt__WhiteBalanceMode)0;
#endif
}

static const struct soap_code_map soap_codes_tt__WhiteBalanceMode[] =
{	
	{ (long)tt__WhiteBalanceMode__AUTO, "AUTO" },
	{ (long)tt__WhiteBalanceMode__MANUAL, "MANUAL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__WhiteBalanceMode2s(struct soap *soap, enum tt__WhiteBalanceMode n)
{	
	const char *s = soap_code_str(soap_codes_tt__WhiteBalanceMode, (long)n);
	if (s!= NULL)
	{
		return s;
	}
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalanceMode(struct soap *soap, const char *tag, int id, const enum tt__WhiteBalanceMode *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalanceMode), type) || soap_send(soap, soap_tt__WhiteBalanceMode2s(soap, *a)))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__WhiteBalanceMode(struct soap *soap, const char *s, enum tt__WhiteBalanceMode *a)
{
	const struct soap_code_map *map;
	if (s == NULL)
	{
		return soap->error;
	}
	map = soap_code(soap_codes_tt__WhiteBalanceMode, s);
	if (map != NULL)
	{
		*a = (enum tt__WhiteBalanceMode)map->code;
	}
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
		{
			return soap->error = SOAP_TYPE;
		}
		*a = (enum tt__WhiteBalanceMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__WhiteBalanceMode * SOAP_FMAC4 soap_in_tt__WhiteBalanceMode(struct soap *soap, const char *tag, enum tt__WhiteBalanceMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (enum tt__WhiteBalanceMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalanceMode, sizeof(enum tt__WhiteBalanceMode), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	
		if ((a==NULL) || soap_s2tt__WhiteBalanceMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (enum tt__WhiteBalanceMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalanceMode, 0, sizeof(enum tt__WhiteBalanceMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WhiteBalanceMode(struct soap *soap, const enum tt__WhiteBalanceMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__WhiteBalanceMode);
	if (soap_out_tt__WhiteBalanceMode(soap, tag?tag:"tt:WhiteBalanceMode", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__WhiteBalanceMode * SOAP_FMAC4 soap_get_tt__WhiteBalanceMode(struct soap *soap, enum tt__WhiteBalanceMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalanceMode(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalance20Extension(struct soap *soap, struct tt__WhiteBalance20Extension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalance20Extension))
	{
		soap_serialize_tt__WhiteBalance20Extension(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalance20Extension(struct soap *soap, const char *tag, int id, struct tt__WhiteBalance20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalance20Extension);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__WhiteBalance20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__WhiteBalance20Extension ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalance20Extension(struct soap *soap, const char *tag, struct tt__WhiteBalance20Extension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a== NULL)
	{
		if (NULL==(a = (struct tt__WhiteBalance20Extension **)soap_malloc(soap, sizeof(struct tt__WhiteBalance20Extension *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__WhiteBalance20Extension(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__WhiteBalance20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalance20Extension, sizeof(struct tt__WhiteBalance20Extension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalance20Extension(struct soap *soap, struct tt__WhiteBalance20Extension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__WhiteBalance20Extension);
	if (soap_out_PointerTott__WhiteBalance20Extension(soap, tag?tag:"tt:WhiteBalance20Extension", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalance20Extension ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalance20Extension(struct soap *soap, struct tt__WhiteBalance20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalance20Extension(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WhiteBalance20Extension(struct soap *soap, struct tt__WhiteBalance20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__WhiteBalance20Extension(struct soap *soap, const struct tt__WhiteBalance20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalance20Extension(struct soap *soap, const char *tag, int id, const struct tt__WhiteBalance20Extension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalance20Extension), type))
	{
		return soap->error;
	}
	if (a->__any != NULL)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_outliteral(soap, "-any", a->__any + i, NULL);
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__WhiteBalance20Extension * SOAP_FMAC4 soap_in_tt__WhiteBalance20Extension(struct soap *soap, const char *tag, struct tt__WhiteBalance20Extension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__WhiteBalance20Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalance20Extension, sizeof(struct tt__WhiteBalance20Extension), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__WhiteBalance20Extension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
					{
						soap_blist___any = soap_new_block(soap);
					}
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
					{
						return NULL;
					}
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{
				soap->error = soap_ignore_element(soap);
			}
			if (soap->error == SOAP_NO_TAG)
			{
				break;
			}
			if (soap->error)
			{
				return NULL;
			}
		}
		if (a->__any != NULL)
		{
			soap_pop_block(soap, soap_blist___any);
		}
		if (a->__size)
		{
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
			{
				soap_end_block(soap, soap_blist___any);
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__WhiteBalance20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalance20Extension, 0, sizeof(struct tt__WhiteBalance20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WhiteBalance20Extension(struct soap *soap, const struct tt__WhiteBalance20Extension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__WhiteBalance20Extension);
	if (soap_out_tt__WhiteBalance20Extension(soap, tag?tag:"tt:WhiteBalance20Extension", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalance20Extension * SOAP_FMAC4 soap_get_tt__WhiteBalance20Extension(struct soap *soap, struct tt__WhiteBalance20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalance20Extension(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettingsExtension20(struct soap *soap, struct tt__ImagingSettingsExtension20 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettingsExtension20))
	{
		soap_serialize_tt__ImagingSettingsExtension20(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettingsExtension20(struct soap *soap, const char *tag, int id, struct tt__ImagingSettingsExtension20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettingsExtension20);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__ImagingSettingsExtension20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension20 ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettingsExtension20(struct soap *soap, const char *tag, struct tt__ImagingSettingsExtension20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct tt__ImagingSettingsExtension20 **)soap_malloc(soap, sizeof(struct tt__ImagingSettingsExtension20 *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__ImagingSettingsExtension20(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__ImagingSettingsExtension20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettingsExtension20, sizeof(struct tt__ImagingSettingsExtension20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettingsExtension20(struct soap *soap, struct tt__ImagingSettingsExtension20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ImagingSettingsExtension20);
	if (soap_out_PointerTott__ImagingSettingsExtension20(soap, tag?tag:"tt:ImagingSettingsExtension20", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension20 ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettingsExtension20(struct soap *soap, struct tt__ImagingSettingsExtension20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettingsExtension20(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingSettingsExtension20(struct soap *soap, struct tt__ImagingSettingsExtension20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingSettingsExtension20(struct soap *soap, const struct tt__ImagingSettingsExtension20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettingsExtension20(struct soap *soap, const char *tag, int id, const struct tt__ImagingSettingsExtension20 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettingsExtension20), type))
	{
		return soap->error;
	}
	if (a->__any != NULL)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_outliteral(soap, "-any", a->__any + i, NULL);
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension20 * SOAP_FMAC4 soap_in_tt__ImagingSettingsExtension20(struct soap *soap, const char *tag, struct tt__ImagingSettingsExtension20 *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__ImagingSettingsExtension20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettingsExtension20, sizeof(struct tt__ImagingSettingsExtension20), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default_tt__ImagingSettingsExtension20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	
				if (a->__any == NULL)
				{	
					if (soap_blist___any == NULL)
					{
						soap_blist___any = soap_new_block(soap);
					}
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
					{
						return NULL;
					}
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	
					a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{
				soap->error = soap_ignore_element(soap);
			}
			if (soap->error == SOAP_NO_TAG)
			{
				break;
			}
			if (soap->error)
			{
				return NULL;
			}
		}
		if (a->__any != NULL)
		{
			soap_pop_block(soap, soap_blist___any);
		}
		if (a->__size)
		{
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
			{
				soap_end_block(soap, soap_blist___any);
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__ImagingSettingsExtension20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettingsExtension20, 0, sizeof(struct tt__ImagingSettingsExtension20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingSettingsExtension20(struct soap *soap, const struct tt__ImagingSettingsExtension20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ImagingSettingsExtension20);
	if (soap_out_tt__ImagingSettingsExtension20(soap, tag?tag:"tt:ImagingSettingsExtension20", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension20 * SOAP_FMAC4 soap_get_tt__ImagingSettingsExtension20(struct soap *soap, struct tt__ImagingSettingsExtension20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettingsExtension20(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__SetImagingSettings(struct soap *soap, struct __timg__SetImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__SetImagingSettings = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__SetImagingSettings(struct soap *soap, const struct __timg__SetImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_timg__SetImagingSettings(soap, &a->timg__SetImagingSettings);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__SetImagingSettings(struct soap *soap, const char *tag, int id, const struct __timg__SetImagingSettings *a, const char *type)
{
	if (soap_out_PointerTo_timg__SetImagingSettings(soap, "timg:SetImagingSettings", -1, &a->timg__SetImagingSettings, ""))
	{
		return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__SetImagingSettings * SOAP_FMAC4 soap_in___timg__SetImagingSettings(struct soap *soap, const char *tag, struct __timg__SetImagingSettings *a, const char *type)
{
	size_t soap_flag_timg__SetImagingSettings = 1;
	short soap_flag;
	a = (struct __timg__SetImagingSettings *)soap_id_enter(soap, "", a, SOAP_TYPE___timg__SetImagingSettings, sizeof(struct __timg__SetImagingSettings), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default___timg__SetImagingSettings(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_timg__SetImagingSettings && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_timg__SetImagingSettings(soap, "timg:SetImagingSettings", &a->timg__SetImagingSettings, ""))
			{	
				soap_flag_timg__SetImagingSettings--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{
					return NULL;
				}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__SetImagingSettings(struct soap *soap, const struct __timg__SetImagingSettings *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___timg__SetImagingSettings(soap, tag?tag:"-timg:SetImagingSettings", id, a, type))
	{
		return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__SetImagingSettings * SOAP_FMAC4 soap_get___timg__SetImagingSettings(struct soap *soap, struct __timg__SetImagingSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__SetImagingSettings(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__SetImagingSettings(struct soap *soap, struct _timg__SetImagingSettings *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__SetImagingSettings))
	{
		soap_serialize__timg__SetImagingSettings(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__SetImagingSettings(struct soap *soap, const char *tag, int id, struct _timg__SetImagingSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__SetImagingSettings);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out__timg__SetImagingSettings(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__SetImagingSettings ** SOAP_FMAC4 soap_in_PointerTo_timg__SetImagingSettings(struct soap *soap, const char *tag, struct _timg__SetImagingSettings **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct _timg__SetImagingSettings **)soap_malloc(soap, sizeof(struct _timg__SetImagingSettings *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in__timg__SetImagingSettings(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _timg__SetImagingSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__SetImagingSettings, sizeof(struct _timg__SetImagingSettings), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__SetImagingSettings(struct soap *soap, struct _timg__SetImagingSettings *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__SetImagingSettings);
	if (soap_out_PointerTo_timg__SetImagingSettings(soap, tag?tag:"timg:SetImagingSettings", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__SetImagingSettings ** SOAP_FMAC4 soap_get_PointerTo_timg__SetImagingSettings(struct soap *soap, struct _timg__SetImagingSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__SetImagingSettings(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__SetImagingSettings(struct soap *soap, struct _timg__SetImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
	a->ImagingSettings = NULL;
	a->ForcePersistence_x0020 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__SetImagingSettings(struct soap *soap, const struct _timg__SetImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->VideoSourceToken);
	soap_serialize_PointerTott__ImagingSettings20(soap, &a->ImagingSettings);
	soap_serialize_PointerToxsd__boolean_(soap, &a->ForcePersistence_x0020);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__SetImagingSettings(struct soap *soap, const char *tag, int id, const struct _timg__SetImagingSettings *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__SetImagingSettings), type))
	{
		return soap->error;
	}
	if (a->VideoSourceToken != NULL)
	{	
		if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, &a->VideoSourceToken, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "timg:VideoSourceToken"))
	{
		return soap->error;
	}
	if (a->ImagingSettings != NULL)
	{
		if (soap_out_PointerTott__ImagingSettings20(soap, "timg:ImagingSettings", -1, &a->ImagingSettings, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "timg:ImagingSettings"))
	{
		return soap->error;
	}
	if (soap_out_PointerToxsd__boolean_(soap, "timg:ForcePersistence ", -1, &a->ForcePersistence_x0020, ""))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__SetImagingSettings * SOAP_FMAC4 soap_in__timg__SetImagingSettings(struct soap *soap, const char *tag, struct _timg__SetImagingSettings *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	size_t soap_flag_ImagingSettings = 1;
	size_t soap_flag_ForcePersistence_x0020 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct _timg__SetImagingSettings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__SetImagingSettings, sizeof(struct _timg__SetImagingSettings), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	soap_default__timg__SetImagingSettings(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", &a->VideoSourceToken, "tt:ReferenceToken"))
				{	
					soap_flag_VideoSourceToken--;
					continue;
				}
				if (soap_flag_ImagingSettings && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__ImagingSettings20(soap, "timg:ImagingSettings", &a->ImagingSettings, "tt:ImagingSettings20"))
					{	
						soap_flag_ImagingSettings--;
						continue;
					}
					if (soap_flag_ForcePersistence_x0020 && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_PointerToxsd__boolean_(soap, "timg:ForcePersistence ", &a->ForcePersistence_x0020, "xsd:boolean"))
						{	
							soap_flag_ForcePersistence_x0020--;
							continue;
						}
						if (soap->error == SOAP_TAG_MISMATCH)
						{
							soap->error = soap_ignore_element(soap);
						}
						if (soap->error == SOAP_NO_TAG)
						{
							break;
						}
						if (soap->error)
						{
							return NULL;
						}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _timg__SetImagingSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__SetImagingSettings, 0, sizeof(struct _timg__SetImagingSettings), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken > 0 || soap_flag_ImagingSettings > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__SetImagingSettings(struct soap *soap, const struct _timg__SetImagingSettings *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__SetImagingSettings);
	if (soap_out__timg__SetImagingSettings(soap, tag?tag:"timg:SetImagingSettings", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__SetImagingSettings * SOAP_FMAC4 soap_get__timg__SetImagingSettings(struct soap *soap, struct _timg__SetImagingSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__SetImagingSettings(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofloat(struct soap *soap, float *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_float);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofloat(struct soap *soap, const char *tag, int id, float *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_float);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_float(soap, tag, id, *a, type);
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_in_PointerTofloat(struct soap *soap, const char *tag, float **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (float **)soap_malloc(soap, sizeof(float *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_float(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (float **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_float, sizeof(float), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofloat(struct soap *soap, float *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofloat);
	if (soap_out_PointerTofloat(soap, tag?tag:"float", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_get_PointerTofloat(struct soap *soap, float **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofloat(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__SetImagingSettingsResponse(struct soap *soap, struct _timg__SetImagingSettingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__SetImagingSettingsResponse(struct soap *soap, const struct _timg__SetImagingSettingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__SetImagingSettingsResponse(struct soap *soap, const char *tag, int id, const struct _timg__SetImagingSettingsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__SetImagingSettingsResponse), type))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__SetImagingSettingsResponse * SOAP_FMAC4 soap_in__timg__SetImagingSettingsResponse(struct soap *soap, const char *tag, struct _timg__SetImagingSettingsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct _timg__SetImagingSettingsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__SetImagingSettingsResponse, sizeof(struct _timg__SetImagingSettingsResponse), 0, NULL, NULL, NULL);
	if (a== NULL)
	{
		return NULL;
	}
	soap_default__timg__SetImagingSettingsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{
				soap->error = soap_ignore_element(soap);
			}
			if (soap->error == SOAP_NO_TAG)
			{
				break;
			}
			if (soap->error)
			{
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _timg__SetImagingSettingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__SetImagingSettingsResponse, 0, sizeof(struct _timg__SetImagingSettingsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__SetImagingSettingsResponse(struct soap *soap, const struct _timg__SetImagingSettingsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__SetImagingSettingsResponse);
	if (soap_out__timg__SetImagingSettingsResponse(soap, tag?tag:"timg:SetImagingSettingsResponse", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__SetImagingSettingsResponse * SOAP_FMAC4 soap_get__timg__SetImagingSettingsResponse(struct soap *soap, struct _timg__SetImagingSettingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__SetImagingSettingsResponse(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

//device IO control
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRelayOutputState(struct soap *soap, struct _tds__SetRelayOutputState *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRelayOutputState))
	{
		soap_serialize__tds__SetRelayOutputState(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRelayOutputState(struct soap *soap, const char *tag, int id, struct _tds__SetRelayOutputState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRelayOutputState);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out__tds__SetRelayOutputState(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetRelayOutputState ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRelayOutputState(struct soap *soap, const char *tag, struct _tds__SetRelayOutputState **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct _tds__SetRelayOutputState **)soap_malloc(soap, sizeof(struct _tds__SetRelayOutputState *))))
		{
			return NULL;
		}

	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in__tds__SetRelayOutputState(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _tds__SetRelayOutputState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRelayOutputState, sizeof(struct _tds__SetRelayOutputState), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRelayOutputState(struct soap *soap, struct _tds__SetRelayOutputState *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetRelayOutputState);
	if (soap_out_PointerTo_tds__SetRelayOutputState(soap, tag?tag:"tds:SetRelayOutputState", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputState ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRelayOutputState(struct soap *soap, struct _tds__SetRelayOutputState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRelayOutputState(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, struct _tds__SendAuxiliaryCommand *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SendAuxiliaryCommand))
	{
		soap_serialize__tds__SendAuxiliaryCommand(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, struct _tds__SendAuxiliaryCommand *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SendAuxiliaryCommand);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out__tds__SendAuxiliaryCommand(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommand ** SOAP_FMAC4 soap_in_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, struct _tds__SendAuxiliaryCommand **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a == NULL)
	{
		if (NULL==(a = (struct _tds__SendAuxiliaryCommand **)soap_malloc(soap, sizeof(struct _tds__SendAuxiliaryCommand *))))
		{
			return NULL;
		}

	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in__tds__SendAuxiliaryCommand(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _tds__SendAuxiliaryCommand **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SendAuxiliaryCommand, sizeof(struct _tds__SendAuxiliaryCommand), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, struct _tds__SendAuxiliaryCommand *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SendAuxiliaryCommand);
	if (soap_out_PointerTo_tds__SendAuxiliaryCommand(soap, tag?tag:"tds:SendAuxiliaryCommand", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommand ** SOAP_FMAC4 soap_get_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, struct _tds__SendAuxiliaryCommand **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SendAuxiliaryCommand(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RelayMode(struct soap *soap, enum tt__RelayMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__RelayMode
	*a = SOAP_DEFAULT_tt__RelayMode;
#else
	*a = (enum tt__RelayMode)0;
#endif
}

static const struct soap_code_map soap_codes_tt__RelayMode[] =
{	
	{ (long)tt__RelayMode__Monostable, "Monostable" },
	{ (long)tt__RelayMode__Bistable, "Bistable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__RelayMode2s(struct soap *soap, enum tt__RelayMode n)
{	
	const char *s = soap_code_str(soap_codes_tt__RelayMode, (long)n);
	if (s != NULL)
	{
		return s;
	}
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayMode(struct soap *soap, const char *tag, int id, const enum tt__RelayMode *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayMode), type) || soap_send(soap, soap_tt__RelayMode2s(soap, *a)))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__RelayMode(struct soap *soap, const char *s, enum tt__RelayMode *a)
{
	const struct soap_code_map *map;
	if (s == NULL)
	{
		return soap->error;
	}
	map = soap_code(soap_codes_tt__RelayMode, s);
	if (map != NULL)
	{
		*a = (enum tt__RelayMode)map->code;
	}
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
		{
			return soap->error = SOAP_TYPE;
		}
		*a = (enum tt__RelayMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__RelayMode * SOAP_FMAC4 soap_in_tt__RelayMode(struct soap *soap, const char *tag, enum tt__RelayMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (enum tt__RelayMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayMode, sizeof(enum tt__RelayMode), 0, NULL, NULL, NULL);
	if (a == NULL)
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	
		if ((a== NULL) || soap_s2tt__RelayMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (enum tt__RelayMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayMode, 0, sizeof(enum tt__RelayMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelayMode(struct soap *soap, const enum tt__RelayMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RelayMode);
	if (soap_out_tt__RelayMode(soap, tag?tag:"tt:RelayMode", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__RelayMode * SOAP_FMAC4 soap_get_tt__RelayMode(struct soap *soap, enum tt__RelayMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayMode(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RelayIdleState(struct soap *soap, enum tt__RelayIdleState *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__RelayIdleState
	*a = SOAP_DEFAULT_tt__RelayIdleState;
#else
	*a = (enum tt__RelayIdleState)0;
#endif
}

static const struct soap_code_map soap_codes_tt__RelayIdleState[] =
{	
	{ (long)tt__RelayIdleState__closed, "closed" },
	{ (long)tt__RelayIdleState__open, "open" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__RelayIdleState2s(struct soap *soap, enum tt__RelayIdleState n)
{	
	const char *s = soap_code_str(soap_codes_tt__RelayIdleState, (long)n);
	if (s != NULL)
	{
		return s;
	}
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayIdleState(struct soap *soap, const char *tag, int id, const enum tt__RelayIdleState *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayIdleState), type) || soap_send(soap, soap_tt__RelayIdleState2s(soap, *a)))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__RelayIdleState(struct soap *soap, const char *s, enum tt__RelayIdleState *a)
{
	const struct soap_code_map *map;
	if (s ==NULL)
	{
		return soap->error;
	}
	map = soap_code(soap_codes_tt__RelayIdleState, s);
	if (map!= NULL)
	{
		*a = (enum tt__RelayIdleState)map->code;
	}
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
		{
			return soap->error = SOAP_TYPE;
		}
		*a = (enum tt__RelayIdleState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__RelayIdleState * SOAP_FMAC4 soap_in_tt__RelayIdleState(struct soap *soap, const char *tag, enum tt__RelayIdleState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (enum tt__RelayIdleState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayIdleState, sizeof(enum tt__RelayIdleState), 0, NULL, NULL, NULL);
	if (a==NULL)
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	
		if (a==NULL || soap_s2tt__RelayIdleState(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (enum tt__RelayIdleState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayIdleState, 0, sizeof(enum tt__RelayIdleState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelayIdleState(struct soap *soap, const enum tt__RelayIdleState *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RelayIdleState);
	if (soap_out_tt__RelayIdleState(soap, tag?tag:"tt:RelayIdleState", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__RelayIdleState * SOAP_FMAC4 soap_get_tt__RelayIdleState(struct soap *soap, enum tt__RelayIdleState *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayIdleState(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RelayLogicalState(struct soap *soap, enum tt__RelayLogicalState *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_tt__RelayLogicalState
	*a = SOAP_DEFAULT_tt__RelayLogicalState;
#else
	*a = (enum tt__RelayLogicalState)0;
#endif
}

static const struct soap_code_map soap_codes_tt__RelayLogicalState[] =
{	
	{ (long)tt__RelayLogicalState__active, "active" },
	{ (long)tt__RelayLogicalState__inactive, "inactive" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__RelayLogicalState2s(struct soap *soap, enum tt__RelayLogicalState n)
{	
	const char *s = soap_code_str(soap_codes_tt__RelayLogicalState, (long)n);
	if (s != NULL)
	{
		return s;
	}
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayLogicalState(struct soap *soap, const char *tag, int id, const enum tt__RelayLogicalState *a, const char *type)
{	
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayLogicalState), type) || soap_send(soap, soap_tt__RelayLogicalState2s(soap, *a)))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__RelayLogicalState(struct soap *soap, const char *s, enum tt__RelayLogicalState *a)
{
	const struct soap_code_map *map;
	if (s == NULL)
	{
		return soap->error;
	}
	map = soap_code(soap_codes_tt__RelayLogicalState, s);
	if (map != NULL)
	{
		*a = (enum tt__RelayLogicalState)map->code;
	}
	else
	{	
		long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
		{
			return soap->error = SOAP_TYPE;
		}
		*a = (enum tt__RelayLogicalState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__RelayLogicalState * SOAP_FMAC4 soap_in_tt__RelayLogicalState(struct soap *soap, const char *tag, enum tt__RelayLogicalState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (enum tt__RelayLogicalState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayLogicalState, sizeof(enum tt__RelayLogicalState), 0, NULL, NULL, NULL);
	if (a==NULL)
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	
		if (a==NULL || soap_s2tt__RelayLogicalState(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))

		{
			return NULL;
		}
	}
	else
	{	
		a = (enum tt__RelayLogicalState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayLogicalState, 0, sizeof(enum tt__RelayLogicalState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelayLogicalState(struct soap *soap, const enum tt__RelayLogicalState *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RelayLogicalState);
	if (soap_out_tt__RelayLogicalState(soap, tag?tag:"tt:RelayLogicalState", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__RelayLogicalState * SOAP_FMAC4 soap_get_tt__RelayLogicalState(struct soap *soap, enum tt__RelayLogicalState *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayLogicalState(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SendAuxiliaryCommand(struct soap *soap, struct __tds__SendAuxiliaryCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SendAuxiliaryCommand = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SendAuxiliaryCommand(struct soap *soap, const struct __tds__SendAuxiliaryCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SendAuxiliaryCommand(soap, &a->tds__SendAuxiliaryCommand);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, const struct __tds__SendAuxiliaryCommand *a, const char *type)
{
	if (soap_out_PointerTo_tds__SendAuxiliaryCommand(soap, "tds:SendAuxiliaryCommand", -1, &a->tds__SendAuxiliaryCommand, ""))
	{
		return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SendAuxiliaryCommand * SOAP_FMAC4 soap_in___tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, struct __tds__SendAuxiliaryCommand *a, const char *type)
{
	size_t soap_flag_tds__SendAuxiliaryCommand = 1;
	short soap_flag;
	a = (struct __tds__SendAuxiliaryCommand *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SendAuxiliaryCommand, sizeof(struct __tds__SendAuxiliaryCommand), 0, NULL, NULL, NULL);
	if (a==NULL)
	{
		return NULL;
	}
	soap_default___tds__SendAuxiliaryCommand(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__SendAuxiliaryCommand && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__SendAuxiliaryCommand(soap, "tds:SendAuxiliaryCommand", &a->tds__SendAuxiliaryCommand, ""))
			{	
				soap_flag_tds__SendAuxiliaryCommand--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{
					return NULL;
				}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SendAuxiliaryCommand(struct soap *soap, const struct __tds__SendAuxiliaryCommand *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SendAuxiliaryCommand(soap, tag?tag:"-tds:SendAuxiliaryCommand", id, a, type))
	{
		return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SendAuxiliaryCommand * SOAP_FMAC4 soap_get___tds__SendAuxiliaryCommand(struct soap *soap, struct __tds__SendAuxiliaryCommand *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SendAuxiliaryCommand(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetRelayOutputState(struct soap *soap, struct __tds__SetRelayOutputState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetRelayOutputState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetRelayOutputState(struct soap *soap, const struct __tds__SetRelayOutputState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetRelayOutputState(soap, &a->tds__SetRelayOutputState);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetRelayOutputState(struct soap *soap, const char *tag, int id, const struct __tds__SetRelayOutputState *a, const char *type)
{
	if (soap_out_PointerTo_tds__SetRelayOutputState(soap, "tds:SetRelayOutputState", -1, &a->tds__SetRelayOutputState, ""))
	{
		return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRelayOutputState * SOAP_FMAC4 soap_in___tds__SetRelayOutputState(struct soap *soap, const char *tag, struct __tds__SetRelayOutputState *a, const char *type)
{
	size_t soap_flag_tds__SetRelayOutputState = 1;
	short soap_flag;
	a = (struct __tds__SetRelayOutputState *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetRelayOutputState, sizeof(struct __tds__SetRelayOutputState), 0, NULL, NULL, NULL);
	if (a==NULL)
	{
		return NULL;
	}
	soap_default___tds__SetRelayOutputState(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__SetRelayOutputState && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__SetRelayOutputState(soap, "tds:SetRelayOutputState", &a->tds__SetRelayOutputState, ""))
			{	
				soap_flag_tds__SetRelayOutputState--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{
					return NULL;
				}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetRelayOutputState(struct soap *soap, const struct __tds__SetRelayOutputState *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetRelayOutputState(soap, tag?tag:"-tds:SetRelayOutputState", id, a, type))
	{
		return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRelayOutputState * SOAP_FMAC4 soap_get___tds__SetRelayOutputState(struct soap *soap, struct __tds__SetRelayOutputState *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetRelayOutputState(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetRelayOutputSettings(struct soap *soap, struct __tds__SetRelayOutputSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetRelayOutputSettings = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetRelayOutputSettings(struct soap *soap, const struct __tds__SetRelayOutputSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetRelayOutputSettings(soap, &a->tds__SetRelayOutputSettings);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetRelayOutputSettings(struct soap *soap, const char *tag, int id, const struct __tds__SetRelayOutputSettings *a, const char *type)
{
	if (soap_out_PointerTo_tds__SetRelayOutputSettings(soap, "tds:SetRelayOutputSettings", -1, &a->tds__SetRelayOutputSettings, ""))
	{
		return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRelayOutputSettings * SOAP_FMAC4 soap_in___tds__SetRelayOutputSettings(struct soap *soap, const char *tag, struct __tds__SetRelayOutputSettings *a, const char *type)
{
	size_t soap_flag_tds__SetRelayOutputSettings = 1;
	short soap_flag;
	a = (struct __tds__SetRelayOutputSettings *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetRelayOutputSettings, sizeof(struct __tds__SetRelayOutputSettings), 0, NULL, NULL, NULL);
	if (a==NULL)
	{
		return NULL;
	}
	soap_default___tds__SetRelayOutputSettings(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__SetRelayOutputSettings && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__SetRelayOutputSettings(soap, "tds:SetRelayOutputSettings", &a->tds__SetRelayOutputSettings, ""))
			{	
				soap_flag_tds__SetRelayOutputSettings--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	
					soap->error = SOAP_OK;
					break;
				}
				if (soap_flag && soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{
					return NULL;
				}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetRelayOutputSettings(struct soap *soap, const struct __tds__SetRelayOutputSettings *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetRelayOutputSettings(soap, tag?tag:"-tds:SetRelayOutputSettings", id, a, type))
	{
		return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRelayOutputSettings * SOAP_FMAC4 soap_get___tds__SetRelayOutputSettings(struct soap *soap, struct __tds__SetRelayOutputSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetRelayOutputSettings(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			{
				return NULL;
			}
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetRelayOutputs(struct soap *soap, struct __tds__GetRelayOutputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetRelayOutputs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetRelayOutputs(struct soap *soap, const struct __tds__GetRelayOutputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetRelayOutputs(soap, &a->tds__GetRelayOutputs);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetRelayOutputs(struct soap *soap, const char *tag, int id, const struct __tds__GetRelayOutputs *a, const char *type)
{
	if (soap_out_PointerTo_tds__GetRelayOutputs(soap, "tds:GetRelayOutputs", -1, &a->tds__GetRelayOutputs, ""))
	{
		return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetRelayOutputs * SOAP_FMAC4 soap_in___tds__GetRelayOutputs(struct soap *soap, const char *tag, struct __tds__GetRelayOutputs *a, const char *type)
{
	size_t soap_flag_tds__GetRelayOutputs = 1;
	short soap_flag;
	a = (struct __tds__GetRelayOutputs *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetRelayOutputs, sizeof(struct __tds__GetRelayOutputs), 0, NULL, NULL, NULL);
	if (a==NULL)
	{
		return NULL;
	}
	soap_default___tds__GetRelayOutputs(soap, a);
	for (soap_flag = 0;; soap_flag = 1)
	{	
		soap->error = SOAP_TAG_MISMATCH;
		if (soap_flag_tds__GetRelayOutputs && soap->error == SOAP_TAG_MISMATCH)
			if (soap_in_PointerTo_tds__GetRelayOutputs(soap, "tds:GetRelayOutputs", &a->tds__GetRelayOutputs, ""))
			{	
				soap_flag_tds__GetRelayOutputs--;
				continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
			break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
			{
				break;
			}
			if (soap->error)
			{
				return NULL;
			}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetRelayOutputs(struct soap *soap, const struct __tds__GetRelayOutputs *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetRelayOutputs(soap, tag?tag:"-tds:GetRelayOutputs", id, a, type))
	{
		return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct __tds__GetRelayOutputs * SOAP_FMAC4 soap_get___tds__GetRelayOutputs(struct soap *soap, struct __tds__GetRelayOutputs *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetRelayOutputs(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetRelayOutputs(struct soap *soap, struct _tds__GetRelayOutputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetRelayOutputs(struct soap *soap, const struct _tds__GetRelayOutputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRelayOutputs(struct soap *soap, const char *tag, int id, const struct _tds__GetRelayOutputs *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRelayOutputs), type))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetRelayOutputs * SOAP_FMAC4 soap_in__tds__GetRelayOutputs(struct soap *soap, const char *tag, struct _tds__GetRelayOutputs *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct _tds__GetRelayOutputs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRelayOutputs, sizeof(struct _tds__GetRelayOutputs), 0, NULL, NULL, NULL);
	if (a==NULL)
	{
		return NULL;
	}
	soap_default__tds__GetRelayOutputs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{
				soap->error = soap_ignore_element(soap);
			}
			if (soap->error == SOAP_NO_TAG)
			{
				break;
			}
			if (soap->error)
			{
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _tds__GetRelayOutputs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRelayOutputs, 0, sizeof(struct _tds__GetRelayOutputs), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetRelayOutputs(struct soap *soap, const struct _tds__GetRelayOutputs *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetRelayOutputs);
	if (soap_out__tds__GetRelayOutputs(soap, tag?tag:"tds:GetRelayOutputs", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRelayOutputs * SOAP_FMAC4 soap_get__tds__GetRelayOutputs(struct soap *soap, struct _tds__GetRelayOutputs *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRelayOutputs(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}



SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SendAuxiliaryCommandResponse(struct soap *soap, struct _tds__SendAuxiliaryCommandResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__AuxiliaryData(soap, &a->AuxiliaryCommandResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SendAuxiliaryCommandResponse(struct soap *soap, const struct _tds__SendAuxiliaryCommandResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__AuxiliaryData(soap, &a->AuxiliaryCommandResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, int id, const struct _tds__SendAuxiliaryCommandResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SendAuxiliaryCommandResponse), type))
	{
		return soap->error;
	}
	if (a->AuxiliaryCommandResponse != NULL)
	{
		soap_element_result(soap, "tds:AuxiliaryCommandResponse");
	}
	if (soap_out_tt__AuxiliaryData(soap, "tds:AuxiliaryCommandResponse", -1, &a->AuxiliaryCommandResponse, ""))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_in__tds__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, struct _tds__SendAuxiliaryCommandResponse *a, const char *type)
{
	size_t soap_flag_AuxiliaryCommandResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct _tds__SendAuxiliaryCommandResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, sizeof(struct _tds__SendAuxiliaryCommandResponse), 0, NULL, NULL, NULL);
	if (a==NULL)
	{
		return NULL;
	}
	soap_default__tds__SendAuxiliaryCommandResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AuxiliaryCommandResponse && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__AuxiliaryData(soap, "tds:AuxiliaryCommandResponse", &a->AuxiliaryCommandResponse, "tt:AuxiliaryData"))
				{	
					soap_flag_AuxiliaryCommandResponse--;
					continue;
				}
				soap_check_result(soap, "tds:AuxiliaryCommandResponse");
				if (soap->error == SOAP_TAG_MISMATCH)
				{
					soap->error = soap_ignore_element(soap);
				}
				if (soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{
					return NULL;
				}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _tds__SendAuxiliaryCommandResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, 0, sizeof(struct _tds__SendAuxiliaryCommandResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SendAuxiliaryCommandResponse(struct soap *soap, const struct _tds__SendAuxiliaryCommandResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SendAuxiliaryCommandResponse);
	if (soap_out__tds__SendAuxiliaryCommandResponse(soap, tag?tag:"tds:SendAuxiliaryCommandResponse", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_get__tds__SendAuxiliaryCommandResponse(struct soap *soap, struct _tds__SendAuxiliaryCommandResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SendAuxiliaryCommandResponse(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SendAuxiliaryCommand(struct soap *soap, struct _tds__SendAuxiliaryCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__AuxiliaryData(soap, &a->AuxiliaryCommand);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SendAuxiliaryCommand(struct soap *soap, const struct _tds__SendAuxiliaryCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__AuxiliaryData(soap, &a->AuxiliaryCommand);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, const struct _tds__SendAuxiliaryCommand *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SendAuxiliaryCommand), type))
	{
		return soap->error;
	}
	if (a->AuxiliaryCommand !=NULL)
	{	
		if (soap_out_tt__AuxiliaryData(soap, "tds:AuxiliaryCommand", -1, &a->AuxiliaryCommand, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tds:AuxiliaryCommand"))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommand * SOAP_FMAC4 soap_in__tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, struct _tds__SendAuxiliaryCommand *a, const char *type)
{
	size_t soap_flag_AuxiliaryCommand = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct _tds__SendAuxiliaryCommand *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SendAuxiliaryCommand, sizeof(struct _tds__SendAuxiliaryCommand), 0, NULL, NULL, NULL);
	if (a==NULL)
	{
		return NULL;
	}
	soap_default__tds__SendAuxiliaryCommand(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AuxiliaryCommand && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__AuxiliaryData(soap, "tds:AuxiliaryCommand", &a->AuxiliaryCommand, "tt:AuxiliaryData"))
				{	
					soap_flag_AuxiliaryCommand--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH)
				{
					soap->error = soap_ignore_element(soap);
				}
				if (soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{
					return NULL;
				}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _tds__SendAuxiliaryCommand *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SendAuxiliaryCommand, 0, sizeof(struct _tds__SendAuxiliaryCommand), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AuxiliaryCommand > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SendAuxiliaryCommand(struct soap *soap, const struct _tds__SendAuxiliaryCommand *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SendAuxiliaryCommand);
	if (soap_out__tds__SendAuxiliaryCommand(soap, tag?tag:"tds:SendAuxiliaryCommand", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommand * SOAP_FMAC4 soap_get__tds__SendAuxiliaryCommand(struct soap *soap, struct _tds__SendAuxiliaryCommand *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SendAuxiliaryCommand(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRelayOutputStateResponse(struct soap *soap, struct _tds__SetRelayOutputStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRelayOutputStateResponse(struct soap *soap, const struct _tds__SetRelayOutputStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputStateResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetRelayOutputStateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputStateResponse), type))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRelayOutputStateResponse * SOAP_FMAC4 soap_in__tds__SetRelayOutputStateResponse(struct soap *soap, const char *tag, struct _tds__SetRelayOutputStateResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct _tds__SetRelayOutputStateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputStateResponse, sizeof(struct _tds__SetRelayOutputStateResponse), 0, NULL, NULL, NULL);
	if (a==NULL)
	{
		return NULL;
	}
	soap_default__tds__SetRelayOutputStateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{
				soap->error = soap_ignore_element(soap);
			}
			if (soap->error == SOAP_NO_TAG)
			{
				break;
			}
			if (soap->error)
			{
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _tds__SetRelayOutputStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputStateResponse, 0, sizeof(struct _tds__SetRelayOutputStateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRelayOutputStateResponse(struct soap *soap, const struct _tds__SetRelayOutputStateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetRelayOutputStateResponse);
	if (soap_out__tds__SetRelayOutputStateResponse(soap, tag?tag:"tds:SetRelayOutputStateResponse", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputStateResponse * SOAP_FMAC4 soap_get__tds__SetRelayOutputStateResponse(struct soap *soap, struct _tds__SetRelayOutputStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputStateResponse(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRelayOutputState(struct soap *soap, struct _tds__SetRelayOutputState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->RelayOutputToken);
	soap_default_tt__RelayLogicalState(soap, &a->LogicalState);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRelayOutputState(struct soap *soap, const struct _tds__SetRelayOutputState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->RelayOutputToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputState(struct soap *soap, const char *tag, int id, const struct _tds__SetRelayOutputState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputState), type))
	{
		return soap->error;
	}
	if (a->RelayOutputToken != NULL)
	{	
		if (soap_out_tt__ReferenceToken(soap, "tds:RelayOutputToken", -1, &a->RelayOutputToken, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tds:RelayOutputToken"))
	{
		return soap->error;
	}
	if (soap_out_tt__RelayLogicalState(soap, "tds:LogicalState", -1, &a->LogicalState, ""))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRelayOutputState * SOAP_FMAC4 soap_in__tds__SetRelayOutputState(struct soap *soap, const char *tag, struct _tds__SetRelayOutputState *a, const char *type)
{
	size_t soap_flag_RelayOutputToken = 1;
	size_t soap_flag_LogicalState = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct _tds__SetRelayOutputState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputState, sizeof(struct _tds__SetRelayOutputState), 0, NULL, NULL, NULL);
	if (a==NULL)
	{
		return NULL;
	}
	soap_default__tds__SetRelayOutputState(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RelayOutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:RelayOutputToken", &a->RelayOutputToken, "tt:ReferenceToken"))
				{	
					soap_flag_RelayOutputToken--;
					continue;
				}
				if (soap_flag_LogicalState && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_tt__RelayLogicalState(soap, "tds:LogicalState", &a->LogicalState, "tt:RelayLogicalState"))
					{	
						soap_flag_LogicalState--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH)
					{
						soap->error = soap_ignore_element(soap);
					}
					if (soap->error == SOAP_NO_TAG)
					{
						break;
					}
					if (soap->error)
					{
						return NULL;
					}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _tds__SetRelayOutputState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputState, 0, sizeof(struct _tds__SetRelayOutputState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RelayOutputToken > 0 || soap_flag_LogicalState > 0))
	{	
		soap->error = SOAP_OCCURS;	
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRelayOutputState(struct soap *soap, const struct _tds__SetRelayOutputState *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetRelayOutputState);
	if (soap_out__tds__SetRelayOutputState(soap, tag?tag:"tds:SetRelayOutputState", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputState * SOAP_FMAC4 soap_get__tds__SetRelayOutputState(struct soap *soap, struct _tds__SetRelayOutputState *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputState(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRelayOutputSettingsResponse(struct soap *soap, struct _tds__SetRelayOutputSettingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRelayOutputSettingsResponse(struct soap *soap, const struct _tds__SetRelayOutputSettingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetRelayOutputSettingsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputSettingsResponse), type))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettingsResponse * SOAP_FMAC4 soap_in__tds__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, struct _tds__SetRelayOutputSettingsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct _tds__SetRelayOutputSettingsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, sizeof(struct _tds__SetRelayOutputSettingsResponse), 0, NULL, NULL, NULL);
	if (a==NULL)
	{
		return NULL;
	}
	soap_default__tds__SetRelayOutputSettingsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{
				soap->error = soap_ignore_element(soap);
			}
			if (soap->error == SOAP_NO_TAG)
			{
				break;
			}
			if (soap->error)
			{
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _tds__SetRelayOutputSettingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, 0, sizeof(struct _tds__SetRelayOutputSettingsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRelayOutputSettingsResponse(struct soap *soap, const struct _tds__SetRelayOutputSettingsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetRelayOutputSettingsResponse);
	if (soap_out__tds__SetRelayOutputSettingsResponse(soap, tag?tag:"tds:SetRelayOutputSettingsResponse", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettingsResponse * SOAP_FMAC4 soap_get__tds__SetRelayOutputSettingsResponse(struct soap *soap, struct _tds__SetRelayOutputSettingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputSettingsResponse(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RelayOutputSettings(struct soap *soap, struct tt__RelayOutputSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RelayMode(soap, &a->Mode);
	soap_default_string(soap, &a->DelayTime);
	soap_default_tt__RelayIdleState(soap, &a->IdleState);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RelayOutputSettings(struct soap *soap, const struct tt__RelayOutputSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->DelayTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayOutputSettings(struct soap *soap, const char *tag, int id, const struct tt__RelayOutputSettings *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayOutputSettings), type))
	{
		return soap->error;
	}
	if (soap_out_tt__RelayMode(soap, "tt:Mode", -1, &a->Mode, ""))
	{
		return soap->error;
	}
	if (a->DelayTime != NULL)
	{	
		if (soap_out_string(soap, "tt:DelayTime", -1, &a->DelayTime, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:DelayTime"))
	{
		return soap->error;
	}
	if (soap_out_tt__RelayIdleState(soap, "tt:IdleState", -1, &a->IdleState, ""))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RelayOutputSettings * SOAP_FMAC4 soap_in_tt__RelayOutputSettings(struct soap *soap, const char *tag, struct tt__RelayOutputSettings *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_DelayTime = 1;
	size_t soap_flag_IdleState = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__RelayOutputSettings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayOutputSettings, sizeof(struct tt__RelayOutputSettings), 0, NULL, NULL, NULL);
	if (a==NULL)
	{
		return NULL;
	}
	soap_default_tt__RelayOutputSettings(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__RelayMode(soap, "tt:Mode", &a->Mode, "tt:RelayMode"))
				{
					soap_flag_Mode--;
					continue;
				}
				if (soap_flag_DelayTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
					if (soap_in_string(soap, "tt:DelayTime", &a->DelayTime, "xsd:string"))
					{	
						soap_flag_DelayTime--;
						continue;
					}
					if (soap_flag_IdleState && soap->error == SOAP_TAG_MISMATCH)
						if (soap_in_tt__RelayIdleState(soap, "tt:IdleState", &a->IdleState, "tt:RelayIdleState"))
						{	
							soap_flag_IdleState--;
							continue;
						}
						if (soap->error == SOAP_TAG_MISMATCH)
						{
							soap->error = soap_ignore_element(soap);
						}
						if (soap->error == SOAP_NO_TAG)
						{
							break;
						}
						if (soap->error)
						{
							return NULL;
						}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__RelayOutputSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayOutputSettings, 0, sizeof(struct tt__RelayOutputSettings), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0 || soap_flag_DelayTime > 0 || soap_flag_IdleState > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelayOutputSettings(struct soap *soap, const struct tt__RelayOutputSettings *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RelayOutputSettings);
	if (soap_out_tt__RelayOutputSettings(soap, tag?tag:"tt:RelayOutputSettings", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelayOutputSettings * SOAP_FMAC4 soap_get_tt__RelayOutputSettings(struct soap *soap, struct tt__RelayOutputSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayOutputSettings(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRelayOutputSettings(struct soap *soap, struct _tds__SetRelayOutputSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->RelayOutputToken);
	a->Properties = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRelayOutputSettings(struct soap *soap, const struct _tds__SetRelayOutputSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->RelayOutputToken);
	soap_serialize_PointerTott__RelayOutputSettings(soap, &a->Properties);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputSettings(struct soap *soap, const char *tag, int id, const struct _tds__SetRelayOutputSettings *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputSettings), type))
	{
		return soap->error;
	}
	if (a->RelayOutputToken != NULL)
	{	
		if (soap_out_tt__ReferenceToken(soap, "tds:RelayOutputToken", -1, &a->RelayOutputToken, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tds:RelayOutputToken"))
	{
		return soap->error;
	}
	if (a->Properties != NULL)
	{	
		if (soap_out_PointerTott__RelayOutputSettings(soap, "tds:Properties", -1, &a->Properties, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tds:Properties"))
	{
		return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettings * SOAP_FMAC4 soap_in__tds__SetRelayOutputSettings(struct soap *soap, const char *tag, struct _tds__SetRelayOutputSettings *a, const char *type)
{
	size_t soap_flag_RelayOutputToken = 1;
	size_t soap_flag_Properties = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct _tds__SetRelayOutputSettings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputSettings, sizeof(struct _tds__SetRelayOutputSettings), 0, NULL, NULL, NULL);
	if (a==NULL)
	{
		return NULL;
	}
	soap_default__tds__SetRelayOutputSettings(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RelayOutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:RelayOutputToken", &a->RelayOutputToken, "tt:ReferenceToken"))
				{	
					soap_flag_RelayOutputToken--;
					continue;
				}
				if (soap_flag_Properties && soap->error == SOAP_TAG_MISMATCH)
					if (soap_in_PointerTott__RelayOutputSettings(soap, "tds:Properties", &a->Properties, "tt:RelayOutputSettings"))
					{	
						soap_flag_Properties--;
						continue;
					}
					if (soap->error == SOAP_TAG_MISMATCH)
					{
						soap->error = soap_ignore_element(soap);
					}
					if (soap->error == SOAP_NO_TAG)
					{
						break;
					}
					if (soap->error)
					{
						return NULL;
					}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _tds__SetRelayOutputSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputSettings, 0, sizeof(struct _tds__SetRelayOutputSettings), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RelayOutputToken > 0 || soap_flag_Properties > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRelayOutputSettings(struct soap *soap, const struct _tds__SetRelayOutputSettings *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetRelayOutputSettings);
	if (soap_out__tds__SetRelayOutputSettings(soap, tag?tag:"tds:SetRelayOutputSettings", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettings * SOAP_FMAC4 soap_get__tds__SetRelayOutputSettings(struct soap *soap, struct _tds__SetRelayOutputSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputSettings(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RelayOutput(struct soap *soap, struct tt__RelayOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->Properties = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RelayOutput(struct soap *soap, const struct tt__RelayOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__RelayOutputSettings(soap, &a->Properties);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayOutput(struct soap *soap, const char *tag, int id, const struct tt__RelayOutput *a, const char *type)
{
	if (a->token != NULL)
	{
		soap_set_attr(soap, "token", a->token, 1);
	}
	if (a->__anyAttribute != NULL)
	{
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	}
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayOutput), type))
	{
		return soap->error;
	}
	if (a->Properties != NULL)
	{	
		if (soap_out_PointerTott__RelayOutputSettings(soap, "tt:Properties", -1, &a->Properties, ""))
		{
			return soap->error;
		}
	}
	else if (soap_element_nil(soap, "tt:Properties"))
	{
		return soap->error;
	}
	if (a->__any != NULL)
	{	
		int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_outliteral(soap, "-any", a->__any + i, NULL);
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RelayOutput * SOAP_FMAC4 soap_in_tt__RelayOutput(struct soap *soap, const char *tag, struct tt__RelayOutput *a, const char *type)
{
	size_t soap_flag_Properties = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct tt__RelayOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayOutput, sizeof(struct tt__RelayOutput), 0, NULL, NULL, NULL);
	if (a==NULL)
	{
		return NULL;
	}
	soap_default_tt__RelayOutput(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, 0, 64))
	{
		return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
	{
		return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Properties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RelayOutputSettings(soap, "tt:Properties", &a->Properties, "tt:RelayOutputSettings"))
				{	
					soap_flag_Properties--;
					continue;
				}
				if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
				{	
					if (a->__any == NULL)
					{	
						if (soap_blist___any == NULL)
						{
							soap_blist___any = soap_new_block(soap);
						}
						a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
						if (a->__any == NULL)
						{
							return NULL;
						}
						*a->__any = NULL;
					}
					if (soap_inliteral(soap, "-any", a->__any))
					{	
						a->__size++;
						a->__any = NULL;
						continue;
					}
				}
				if (soap->error == SOAP_TAG_MISMATCH)
				{
					soap->error = soap_ignore_element(soap);
				}
				if (soap->error == SOAP_NO_TAG)
				{
					break;
				}
				if (soap->error)
				{
					return NULL;
				}
		}
		if (a->__any != NULL)
		{
			soap_pop_block(soap, soap_blist___any);
		}
		if (a->__size)
		{
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	
			a->__any = NULL;
			if (soap_blist___any)
			{
				soap_end_block(soap, soap_blist___any);
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__RelayOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayOutput, 0, sizeof(struct tt__RelayOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Properties > 0))
	{	
		soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelayOutput(struct soap *soap, const struct tt__RelayOutput *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RelayOutput);
	if (soap_out_tt__RelayOutput(soap, tag?tag:"tt:RelayOutput", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelayOutput * SOAP_FMAC4 soap_get_tt__RelayOutput(struct soap *soap, struct tt__RelayOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayOutput(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetRelayOutputsResponse(struct soap *soap, struct _tds__GetRelayOutputsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRelayOutputs = 0;
	a->RelayOutputs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetRelayOutputsResponse(struct soap *soap, const struct _tds__GetRelayOutputsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->RelayOutputs != NULL)
	{	
		int i;
		for (i = 0; i < a->__sizeRelayOutputs; i++)
		{
			soap_embedded(soap, a->RelayOutputs + i, SOAP_TYPE_tt__RelayOutput);
			soap_serialize_tt__RelayOutput(soap, a->RelayOutputs + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRelayOutputsResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetRelayOutputsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRelayOutputsResponse), type))
	{
		return soap->error;
	}
	soap_element_result(soap, "-sizeRelayOutputs");
	if (a->RelayOutputs != NULL)
	{	
		int i;
		for (i = 0; i < a->__sizeRelayOutputs; i++)
		{
			if (soap_out_tt__RelayOutput(soap, "tds:RelayOutputs", -1, a->RelayOutputs + i, ""))
			{
				return soap->error;
			}
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetRelayOutputsResponse * SOAP_FMAC4 soap_in__tds__GetRelayOutputsResponse(struct soap *soap, const char *tag, struct _tds__GetRelayOutputsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_RelayOutputs = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
	{
		return NULL;
	}
	a = (struct _tds__GetRelayOutputsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRelayOutputsResponse, sizeof(struct _tds__GetRelayOutputsResponse), 0, NULL, NULL, NULL);
	if (a==NULL)
	{
		return NULL;
	}
	soap_default__tds__GetRelayOutputsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	
			soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:RelayOutputs", 1, NULL))
			{	
				if (a->RelayOutputs == NULL)
				{	
					if (soap_blist_RelayOutputs == NULL)
					{
						soap_blist_RelayOutputs = soap_new_block(soap);
					}
					a->RelayOutputs = (struct tt__RelayOutput *)soap_push_block(soap, soap_blist_RelayOutputs, sizeof(struct tt__RelayOutput));
					if (a->RelayOutputs == NULL)
					{
						return NULL;
					}
					soap_default_tt__RelayOutput(soap, a->RelayOutputs);
				}
				soap_revert(soap);
				if (soap_in_tt__RelayOutput(soap, "tds:RelayOutputs", a->RelayOutputs, "tt:RelayOutput"))
				{	
					a->__sizeRelayOutputs++;
					a->RelayOutputs = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeRelayOutputs");
			if (soap->error == SOAP_TAG_MISMATCH)
			{
				soap->error = soap_ignore_element(soap);
			}
			if (soap->error == SOAP_NO_TAG)
			{
				break;
			}
			if (soap->error)
			{
				return NULL;
			}
		}
		if (a->RelayOutputs != NULL)
		{
			soap_pop_block(soap, soap_blist_RelayOutputs);
		}
		if (a->__sizeRelayOutputs)
		{
			a->RelayOutputs = (struct tt__RelayOutput *)soap_save_block(soap, soap_blist_RelayOutputs, NULL, 1);
		}
		else
		{	
			a->RelayOutputs = NULL;
			if (soap_blist_RelayOutputs)
			{
				soap_end_block(soap, soap_blist_RelayOutputs);
			}
		}
		if (soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _tds__GetRelayOutputsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRelayOutputsResponse, 0, sizeof(struct _tds__GetRelayOutputsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetRelayOutputsResponse(struct soap *soap, const struct _tds__GetRelayOutputsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetRelayOutputsResponse);
	if (soap_out__tds__GetRelayOutputsResponse(soap, tag?tag:"tds:GetRelayOutputsResponse", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRelayOutputsResponse * SOAP_FMAC4 soap_get__tds__GetRelayOutputsResponse(struct soap *soap, struct _tds__GetRelayOutputsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRelayOutputsResponse(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AuxiliaryData(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AuxiliaryData))
	{
		soap_serialize_tt__AuxiliaryData(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AuxiliaryData(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AuxiliaryData);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__AuxiliaryData(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTott__AuxiliaryData(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a==NULL)
	{
		if (NULL==(a = (char ***)soap_malloc(soap, sizeof(char **))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__AuxiliaryData(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AuxiliaryData, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AuxiliaryData(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AuxiliaryData);
	if (soap_out_PointerTott__AuxiliaryData(soap, tag?tag:"byte", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTott__AuxiliaryData(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AuxiliaryData(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AuxiliaryData(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__AuxiliaryData);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__AuxiliaryData(struct soap *soap, const char *tag, char **a, const char *type)
{	
	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__AuxiliaryData, 1, 0, 128);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AuxiliaryData(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AuxiliaryData);
	if (soap_out_tt__AuxiliaryData(soap, tag?tag:"byte", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__AuxiliaryData(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AuxiliaryData(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelayOutputSettings(struct soap *soap, struct tt__RelayOutputSettings *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RelayOutputSettings))
	{
		soap_serialize_tt__RelayOutputSettings(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelayOutputSettings(struct soap *soap, const char *tag, int id, struct tt__RelayOutputSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelayOutputSettings);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__RelayOutputSettings(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RelayOutputSettings ** SOAP_FMAC4 soap_in_PointerTott__RelayOutputSettings(struct soap *soap, const char *tag, struct tt__RelayOutputSettings **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a==NULL)
	{
		if (NULL==(a = (struct tt__RelayOutputSettings **)soap_malloc(soap, sizeof(struct tt__RelayOutputSettings *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__RelayOutputSettings(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__RelayOutputSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelayOutputSettings, sizeof(struct tt__RelayOutputSettings), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelayOutputSettings(struct soap *soap, struct tt__RelayOutputSettings *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RelayOutputSettings);
	if (soap_out_PointerTott__RelayOutputSettings(soap, tag?tag:"tt:RelayOutputSettings", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelayOutputSettings ** SOAP_FMAC4 soap_get_PointerTott__RelayOutputSettings(struct soap *soap, struct tt__RelayOutputSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelayOutputSettings(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelayOutput(struct soap *soap, struct tt__RelayOutput *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RelayOutput))
	{
		soap_serialize_tt__RelayOutput(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelayOutput(struct soap *soap, const char *tag, int id, struct tt__RelayOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelayOutput);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out_tt__RelayOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RelayOutput ** SOAP_FMAC4 soap_in_PointerTott__RelayOutput(struct soap *soap, const char *tag, struct tt__RelayOutput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a==NULL)
	{
		if (NULL==(a = (struct tt__RelayOutput **)soap_malloc(soap, sizeof(struct tt__RelayOutput *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in_tt__RelayOutput(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct tt__RelayOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelayOutput, sizeof(struct tt__RelayOutput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelayOutput(struct soap *soap, struct tt__RelayOutput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RelayOutput);
	if (soap_out_PointerTott__RelayOutput(soap, tag?tag:"tt:RelayOutput", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelayOutput ** SOAP_FMAC4 soap_get_PointerTott__RelayOutput(struct soap *soap, struct tt__RelayOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelayOutput(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SendAuxiliaryCommandResponse(struct soap *soap, struct _tds__SendAuxiliaryCommandResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SendAuxiliaryCommandResponse))
		soap_serialize__tds__SendAuxiliaryCommandResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, int id, struct _tds__SendAuxiliaryCommandResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SendAuxiliaryCommandResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SendAuxiliaryCommandResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommandResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, struct _tds__SendAuxiliaryCommandResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a==NULL)
	{
		if (NULL==(a = (struct _tds__SendAuxiliaryCommandResponse **)soap_malloc(soap, sizeof(struct _tds__SendAuxiliaryCommandResponse *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in__tds__SendAuxiliaryCommandResponse(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _tds__SendAuxiliaryCommandResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, sizeof(struct _tds__SendAuxiliaryCommandResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SendAuxiliaryCommandResponse(struct soap *soap, struct _tds__SendAuxiliaryCommandResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SendAuxiliaryCommandResponse);
	if (soap_out_PointerTo_tds__SendAuxiliaryCommandResponse(soap, tag?tag:"tds:SendAuxiliaryCommandResponse", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommandResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SendAuxiliaryCommandResponse(struct soap *soap, struct _tds__SendAuxiliaryCommandResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SendAuxiliaryCommandResponse(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRelayOutputStateResponse(struct soap *soap, struct _tds__SetRelayOutputStateResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRelayOutputStateResponse))
	{
		soap_serialize__tds__SetRelayOutputStateResponse(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRelayOutputStateResponse(struct soap *soap, const char *tag, int id, struct _tds__SetRelayOutputStateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRelayOutputStateResponse);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out__tds__SetRelayOutputStateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetRelayOutputStateResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRelayOutputStateResponse(struct soap *soap, const char *tag, struct _tds__SetRelayOutputStateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a==NULL)
	{
		if (NULL==(a = (struct _tds__SetRelayOutputStateResponse **)soap_malloc(soap, sizeof(struct _tds__SetRelayOutputStateResponse *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in__tds__SetRelayOutputStateResponse(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _tds__SetRelayOutputStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRelayOutputStateResponse, sizeof(struct _tds__SetRelayOutputStateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRelayOutputStateResponse(struct soap *soap, struct _tds__SetRelayOutputStateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetRelayOutputStateResponse);
	if (soap_out_PointerTo_tds__SetRelayOutputStateResponse(soap, tag?tag:"tds:SetRelayOutputStateResponse", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputStateResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRelayOutputStateResponse(struct soap *soap, struct _tds__SetRelayOutputStateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRelayOutputStateResponse(soap, tag, p, type)) != NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRelayOutputSettingsResponse(struct soap *soap, struct _tds__SetRelayOutputSettingsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRelayOutputSettingsResponse))
	{
		soap_serialize__tds__SetRelayOutputSettingsResponse(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, int id, struct _tds__SetRelayOutputSettingsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRelayOutputSettingsResponse);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out__tds__SetRelayOutputSettingsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettingsResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, struct _tds__SetRelayOutputSettingsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a==NULL)
	{
		if (NULL==(a = (struct _tds__SetRelayOutputSettingsResponse **)soap_malloc(soap, sizeof(struct _tds__SetRelayOutputSettingsResponse *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in__tds__SetRelayOutputSettingsResponse(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _tds__SetRelayOutputSettingsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, sizeof(struct _tds__SetRelayOutputSettingsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRelayOutputSettingsResponse(struct soap *soap, struct _tds__SetRelayOutputSettingsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetRelayOutputSettingsResponse);
	if (soap_out_PointerTo_tds__SetRelayOutputSettingsResponse(soap, tag?tag:"tds:SetRelayOutputSettingsResponse", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettingsResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRelayOutputSettingsResponse(struct soap *soap, struct _tds__SetRelayOutputSettingsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRelayOutputSettingsResponse(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, struct _tds__SetRelayOutputSettings *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRelayOutputSettings))
	{
		soap_serialize__tds__SetRelayOutputSettings(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, const char *tag, int id, struct _tds__SetRelayOutputSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRelayOutputSettings);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out__tds__SetRelayOutputSettings(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettings ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, const char *tag, struct _tds__SetRelayOutputSettings **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a==NULL)
	{
		if (NULL==(a = (struct _tds__SetRelayOutputSettings **)soap_malloc(soap, sizeof(struct _tds__SetRelayOutputSettings *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in__tds__SetRelayOutputSettings(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _tds__SetRelayOutputSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRelayOutputSettings, sizeof(struct _tds__SetRelayOutputSettings), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, struct _tds__SetRelayOutputSettings *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetRelayOutputSettings);
	if (soap_out_PointerTo_tds__SetRelayOutputSettings(soap, tag?tag:"tds:SetRelayOutputSettings", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettings ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, struct _tds__SetRelayOutputSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRelayOutputSettings(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetRelayOutputsResponse(struct soap *soap, struct _tds__GetRelayOutputsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetRelayOutputsResponse))
	{
		soap_serialize__tds__GetRelayOutputsResponse(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetRelayOutputsResponse(struct soap *soap, const char *tag, int id, struct _tds__GetRelayOutputsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetRelayOutputsResponse);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out__tds__GetRelayOutputsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetRelayOutputsResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetRelayOutputsResponse(struct soap *soap, const char *tag, struct _tds__GetRelayOutputsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a==NULL)
	{
		if (NULL==(a = (struct _tds__GetRelayOutputsResponse **)soap_malloc(soap, sizeof(struct _tds__GetRelayOutputsResponse *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in__tds__GetRelayOutputsResponse(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _tds__GetRelayOutputsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRelayOutputsResponse, sizeof(struct _tds__GetRelayOutputsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetRelayOutputsResponse(struct soap *soap, struct _tds__GetRelayOutputsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetRelayOutputsResponse);
	if (soap_out_PointerTo_tds__GetRelayOutputsResponse(soap, tag?tag:"tds:GetRelayOutputsResponse", id, a, type))
	{
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRelayOutputsResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetRelayOutputsResponse(struct soap *soap, struct _tds__GetRelayOutputsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetRelayOutputsResponse(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetRelayOutputs(struct soap *soap, struct _tds__GetRelayOutputs *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetRelayOutputs))
	{
		soap_serialize__tds__GetRelayOutputs(soap, *a);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetRelayOutputs(struct soap *soap, const char *tag, int id, struct _tds__GetRelayOutputs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetRelayOutputs);
	if (id < 0)
	{
		return soap->error;
	}
	return soap_out__tds__GetRelayOutputs(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetRelayOutputs ** SOAP_FMAC4 soap_in_PointerTo_tds__GetRelayOutputs(struct soap *soap, const char *tag, struct _tds__GetRelayOutputs **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
	{
		return NULL;
	}
	if (a==NULL)
	{
		if (NULL==(a = (struct _tds__GetRelayOutputs **)soap_malloc(soap, sizeof(struct _tds__GetRelayOutputs *))))
		{
			return NULL;
		}
	}
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	
		soap_revert(soap);
		if (NULL==(*a = soap_in__tds__GetRelayOutputs(soap, tag, *a, type)))
		{
			return NULL;
		}
	}
	else
	{	
		a = (struct _tds__GetRelayOutputs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRelayOutputs, sizeof(struct _tds__GetRelayOutputs), 0);
		if (soap->body && soap_element_end_in(soap, tag))
		{
			return NULL;
		}
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetRelayOutputs(struct soap *soap, struct _tds__GetRelayOutputs *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetRelayOutputs);
	if (soap_out_PointerTo_tds__GetRelayOutputs(soap, tag?tag:"tds:GetRelayOutputs", id, a, type))
	{	
		return soap->error;
	}
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRelayOutputs ** SOAP_FMAC4 soap_get_PointerTo_tds__GetRelayOutputs(struct soap *soap, struct _tds__GetRelayOutputs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetRelayOutputs(soap, tag, p, type))!= NULL)
	{
		if (soap_getindependent(soap))
		{
			return NULL;
		}
	}
	return p;
}

//device alarm

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif
